<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Android开发者工具</title>
    <url>/2014/10/26/AndroidDevTools/</url>
    <content><![CDATA[<p>Android Api中文版</p>
<p>地址：<a href="http://wikidroid.sinaapp.com/Android中文API" target="_blank" rel="noopener">http://wikidroid.sinaapp.com/Android中文API</a>)</p>
<p>Android API指南中文版</p>
<p>地址：<a href="http://wiki.eoeandroid.com/Android_API_Guides" target="_blank" rel="noopener">http://wiki.eoeandroid.com/Android_API_Guides</a></p>
<p>Android Dev Guides<br>Google Java编程风格指南中文版</p>
<p>英文地址：<a href="http://google-styleguide.googlecode.com/svn/trunk/javaguide.html" target="_blank" rel="noopener">http://google-styleguide.googlecode.com/svn/trunk/javaguide.html</a></p>
<p>地址0：<a href="http://hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">http://hawstein.com/posts/google-java-style.html</a></p>
<p>地址1：<a href="https://github.com/codeset/google-java-styleguide" target="_blank" rel="noopener">https://github.com/codeset/google-java-styleguide</a></p>
<p>Android Proguard混淆配置指南</p>
<p>地址：<a href="https://github.com/inferjay/AndroidProguardGuide/" target="_blank" rel="noopener">https://github.com/inferjay/AndroidProguardGuide/</a></p>
<p>Gradle插件使用指南中文版</p>
<p>地址：<a href="http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision" target="_blank" rel="noopener">http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision</a></p>
<p>Gradle User Guide</p>
<p>Gradle 1.12用户指南：<a href="http://pan.baidu.com/s/1dD7sC2d" target="_blank" rel="noopener">http://pan.baidu.com/s/1dD7sC2d</a></p>
<p>Android Dev Tutorials<br>Android学习之路</p>
<p>地址：<a href="http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="noopener">http://stormzhang.github.io/android/2014/07/07/learn-android-from-rookie/</a></p>
<p>Google Android官方培训课程中文版</p>
<p>地址：<a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">http://hukai.me/android-training-course-in-chinese/index.html</a></p>
<p>Developing Android Apps</p>
<p>地址：<a href="https://www.udacity.com/course/ud853" target="_blank" rel="noopener">https://www.udacity.com/course/ud853</a></p>
<p>Java Design Patterns Samples in Java.</p>
<p>Java Design Patterns</p>
<p>Design Guides<br>Android设计指南非官方简体中文版</p>
<p>Topfun镜像地址：<a href="http://www.topfun.us/adchs/index.html" target="_blank" rel="noopener">http://www.topfun.us/adchs/index.html</a></p>
<p>Github镜像地址：<a href="http://adchs.github.io" target="_blank" rel="noopener">http://adchs.github.io</a></p>
<p>ApkBus镜像地址：<a href="http://www.apkbus.com/design/" target="_blank" rel="noopener">http://www.apkbus.com/design/</a></p>
<p>Segmentfault镜像地址：<a href="http://mirrors.segmentfault.com/adchs/" target="_blank" rel="noopener">http://mirrors.segmentfault.com/adchs/</a></p>
<p>多看阅读镜像地址：<a href="http://www.duokan.com/book/47790" target="_blank" rel="noopener">http://www.duokan.com/book/47790</a></p>
<p>Android Cheatsheet for Graphic Designers</p>
<p>地址:<a href="http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/" target="_blank" rel="noopener">http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/</a></p>
<p>Google Material Design 中文版</p>
<p>地址：<a href="http://design.1sters.com" target="_blank" rel="noopener">http://design.1sters.com</a></p>
<p>地址： <a href="http://www.ui.cn/Material/" target="_blank" rel="noopener">http://www.ui.cn/Material/</a></p>
<p>Designer’s Guide To dpi</p>
<p>地址：<a href="http://sebastien-gabriel.com/designers-guide-to-dpi/home" target="_blank" rel="noopener">http://sebastien-gabriel.com/designers-guide-to-dpi/home</a></p>
<p>Email Design Guide</p>
<p>地址：<a href="http://mailchimp.com/resources/email-design-guide/" target="_blank" rel="noopener">http://mailchimp.com/resources/email-design-guide/</a></p>
<p>更多内容请访问： <a href="http://www.androiddevtools.cn" target="_blank" rel="noopener">http://www.androiddevtools.cn</a><br>License</p>
<blockquote>
<p>Copyright 2014 inferjay (<a href="http://www.androiddevtools.cn" target="_blank" rel="noopener">http://www.androiddevtools.cn</a>)<br>Licensed under the Apache License, Version 2.0 (the “License”);<br>you may not use this file except in compliance with the License.<br>You may obtain a copy of the License at<br>    <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank" rel="noopener">http://www.apache.org/licenses/LICENSE-2.0</a><br>Unless required by applicable law or agreed to in writing, software<br>distributed under the License is distributed on an “AS IS” BASIS,<br>WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.<br>See the License for the specific language governing permissions and<br>limitations under the License.</p>
</blockquote>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android DiskLruCache完全解析，硬盘缓存的最佳方案</title>
    <url>/2014/11/05/android-DisLrukCache/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>　　上篇文章<a href="../android-LruCache">Android高效加载大图、多图解决方案</a>是翻译自Android Doc的，其中防止多图OOM的核心解决思路就是使用LruCache技术。但LruCache只是管理了内存中图片的存储与释放，如果图片从内存中被移除的话，那么又需要从网络上重新加载一次图片，这显然非常耗时。对此，Google又提供了一套硬盘缓存的解决方案：DiskLruCache(非Google官方编写，但获得官方认证)。只可惜，Android Doc中并没有对DiskLruCache的用法给出详细的说明，而网上关于DiskLruCache的资料也少之又少，因此今天我准备专门写一篇博客来详细讲解DiskLruCache的用法，以及分析它的工作原理，这应该也是目前网上关于DiskLruCache最详细的资料了。。</p>
<p>　　那么我们先来看一下有哪些应用程序已经使用了DiskLruCache技术。在我所接触的应用范围里，Dropbox、Twitter、网易新闻等都是使用DiskLruCache来进行硬盘缓存的，其中Dropbox和Twitter大多数人应该都没用过，那么我们就从大家最熟悉的网易新闻开始着手分析，来对DiskLruCache有一个最初的认识吧。</p>
<h3 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h3><p>　　相信所有人都知道，网易新闻中的数据都是从网络上获取的，包括了很多的新闻内容和新闻图片，如下图所示：<img src="http://img.blog.csdn.net/20140803100719140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>　　但是不知道大家有没有发现，这些内容和图片在从网络上获取到之后都会存入到本地缓存中，因此即使手机在没有网络的情况下依然能够加载出以前浏览过的新闻。而使用的缓存技术不用多说，自然是DiskLruCache了，那么首先第一个问题，这些数据都被缓存在了手机的什么位置呢？</p>
<p>　　其实DiskLruCache并没有限制数据的缓存位置，可以自由地进行设定，但是通常情况下多数应用程序都会将缓存的位置选择为 /sdcard/Android/data/<application package>/cache 这个路径。选择在这个位置有两点好处：第一，这是存储在SD卡上的，因此即使缓存再多的数据也不会对手机的内置存储空间有任何影响，只要SD卡空间足够就行。第二，这个路径被Android系统认定为应用程序的缓存路径，当程序被卸载的时候，这里的数据也会一起被清除掉，这样就不会出现删除程序之后手机上还有很多残留数据的问题。</p>
<p>　　那么这里还是以网易新闻为例，它的客户端的包名是com.netease.newsreader.activity，因此数据缓存地址就应该是 /sdcard/Android/data/com.netease.newsreader.activity/cache ，我们进入到这个目录中看一下，结果如下图所示：<img src="http://img.blog.csdn.net/20140803104231765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>　　可以看到有很多个文件夹，因为网易新闻对多种类型的数据都进行了缓存，这里简单起见我们只分析图片缓存就好，所以进入到bitmap文件夹当中。然后你将会看到一堆文件名很长的文件，这些文件命名没有任何规则，完全看不懂是什么意思，但如果你一直向下滚动，将会看到一个名为journal的文件，如下图所示：<br><img src="http://img.blog.csdn.net/20140803140924754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>　　那么这些文件到底都是什么呢？看到这里相信有些朋友已经是一头雾水了，这里我简单解释一下。上面那些文件名很长的文件就是一张张缓存的图片，每个文件都对应着一张图片，而journal文件是DiskLruCache的一个日志文件，程序对每张图片的操作记录都存放在这个文件中，基本上看到journal这个文件就标志着该程序使用DiskLruCache技术了。</p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>　　好了，对DiskLruCache有了最初的认识之后，下面我们来学习一下DiskLruCache的用法吧。由于DiskLruCache并不是由Google官方编写的，所以这个类并没有被包含在Android API当中，我们需要将这个类从网上下载下来，然后手动添加到项目当中。DiskLruCache的源码在Google Source上，地址如下：</p>
<p><a href="http://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/DiskLruCache.java" target="_blank" rel="noopener">http://android.googlesource.com/platform/libcore/+/jb-mr2-release/luni/src/main/java/libcore/io/DiskLruCache.java</a></p>
<p>　　下载好了源码之后，只需要在项目中新建一个libcore.io包，然后将DiskLruCache.java文件复制到这个包中即可。</p>
<h3 id="打开缓存"><a href="#打开缓存" class="headerlink" title="打开缓存"></a>打开缓存</h3><p>　　这样的话我们就把准备工作做好了，下面看一下DiskLruCache到底该如何使用。首先你要知道，DiskLruCache是不能new出实例的，如果我们要创建一个DiskLruCache的实例，则需要调用它的open()方法，接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span></span><br></pre></td></tr></table></figure>
<p>　　open()方法接收四个参数，第一个参数指定的是数据的缓存地址，第二个参数指定当前应用程序的版本号，第三个参数指定同一个key可以对应多少个缓存文件，基本都是传1，第四个参数指定最多可以缓存多少字节的数据。<br>其中缓存地址前面已经说过了，通常都会存放在 /sdcard/Android/data/<application package>/cache 这个路径下面，但同时我们又需要考虑如果这个手机没有SD卡，或者SD正好被移除了的情况，因此比较优秀的程序都会专门写一个方法来获取缓存地址，如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getDiskCacheDir</span><span class="params">(Context context, String uniqueName)</span> </span>&#123;</span><br><span class="line">    String cachePath;</span><br><span class="line">    <span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())</span><br><span class="line">            || !Environment.isExternalStorageRemovable()) &#123;</span><br><span class="line">        cachePath = context.getExternalCacheDir().getPath();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cachePath = context.getCacheDir().getPath();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(cachePath + File.separator + uniqueName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　可以看到，当SD卡存在或者SD卡不可被移除的时候，就调用getExternalCacheDir()方法来获取缓存路径，否则就调用getCacheDir()方法来获取缓存路径。前者获取到的就是 /sdcard/Android/data/<application package>/cache 这个路径，而后者获取到的是 /data/data/<application package>/cache 这个路径。<br>　　接着又将获取到的路径和一个uniqueName进行拼接，作为最终的缓存路径返回。那么这个uniqueName又是什么呢？其实这就是为了对不同类型的数据进行区分而设定的一个唯一值，比如说在网易新闻缓存路径下看到的bitmap、object等文件夹。</p>
<p>　　接着是应用程序版本号，我们可以使用如下代码简单地获取到当前应用程序的版本号：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAppVersion</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageInfo info = context.getPackageManager().getPackageInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> info.versionCode;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　需要注意的是，每当版本号改变，缓存路径下存储的所有数据都会被清除掉，因为DiskLruCache认为当应用程序有版本更新的时候，所有的数据都应该从网上重新获取。<br>后面两个参数就没什么需要解释的了，第三个参数传1，第四个参数通常传入10M的大小就够了，这个可以根据自身的情况进行调节。</p>
<p>　　因此，一个非常标准的open()方法就可以这样写：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DiskLruCache mDiskLruCache = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File cacheDir = getDiskCacheDir(context, <span class="string">"bitmap"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!cacheDir.exists()) &#123;</span><br><span class="line">        cacheDir.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    mDiskLruCache = DiskLruCache.open(cacheDir, getAppVersion(context), <span class="number">1</span>, <span class="number">10</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　　首先调用getDiskCacheDir()方法获取到缓存地址的路径，然后判断一下该路径是否存在，如果不存在就创建一下。接着调用DiskLruCache的open()方法来创建实例，并把四个参数传入即可。<br>有了DiskLruCache的实例之后，我们就可以对缓存的数据进行操作了，操作类型主要包括写入、访问、移除等，我们一个个进行学习。</p>
<h3 id="写入缓存"><a href="#写入缓存" class="headerlink" title="写入缓存"></a>写入缓存</h3><p>　　先来看写入，比如说现在有一张图片，地址是<a href="http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg" target="_blank" rel="noopener">http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg</a> ，那么为了将这张图片下载下来，就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">downloadUrlToStream</span><span class="params">(String urlString, OutputStream outputStream)</span> </span>&#123;</span><br><span class="line">    HttpURLConnection urlConnection = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream out = <span class="keyword">null</span>;</span><br><span class="line">    BufferedInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> URL url = <span class="keyword">new</span> URL(urlString);</span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line">        in = <span class="keyword">new</span> BufferedInputStream(urlConnection.getInputStream(), <span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">        out = <span class="keyword">new</span> BufferedOutputStream(outputStream, <span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">        <span class="keyword">while</span> ((b = in.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (urlConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码相当基础，相信大家都看得懂，就是访问urlString中传入的网址，并通过outputStream写入到本地。有了这个方法之后，下面我们就可以使用DiskLruCache来进行写入了，写入的操作是借助DiskLruCache.Editor这个类完成的。类似地，这个类也是不能new的，需要调用DiskLruCache的edit()方法来获取实例，接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>　　可以看到，edit()方法接收一个参数key，这个key将会成为缓存文件的文件名，并且必须要和图片的URL是一一对应的。那么怎样才能让key和图片的URL能够一一对应呢？直接使用URL来作为key？不太合适，因为图片URL中可能包含一些特殊字符，这些字符有可能在命名文件时是不合法的。其实最简单的做法就是将图片的URL进行MD5编码，编码后的字符串肯定是唯一的，并且只会包含0-F这样的字符，完全符合文件的命名规则。<br>那么我们就写一个方法用来将字符串进行MD5编码，代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hashKeyForDisk</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    String cacheKey;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> MessageDigest mDigest = MessageDigest.getInstance(<span class="string">"MD5"</span>);</span><br><span class="line">        mDigest.update(key.getBytes());</span><br><span class="line">        cacheKey = bytesToHexString(mDigest.digest());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">        cacheKey = String.valueOf(key.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bytesToHexString</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        String hex = Integer.toHexString(<span class="number">0xFF</span> &amp; bytes[i]);</span><br><span class="line">        <span class="keyword">if</span> (hex.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(hex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　代码很简单，现在我们只需要调用一下hashKeyForDisk()方法，并把图片的URL传入到这个方法中，就可以得到对应的key了。<br>因此，现在就可以这样写来得到一个DiskLruCache.Editor的实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;</span><br><span class="line">String key = hashKeyForDisk(imageUrl);</span><br><span class="line">DiskLruCache.Editor editor = mDiskLruCache.edit(key);</span><br></pre></td></tr></table></figure>
<p>BitmapWorkerTask 还要把新加载的图片的键值对放到缓存中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 在后台加载图片。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">                getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　有了DiskLruCache.Editor的实例之后，我们可以调用它的newOutputStream()方法来创建一个输出流，然后把它传入到downloadUrlToStream()中就能实现下载并写入缓存的功能了。注意newOutputStream()方法接收一个index参数，由于前面在设置valueCount的时候指定的是1，所以这里index传0就可以了。在写入操作执行完之后，我们还需要调用一下commit()方法进行提交才能使写入生效，调用abort()方法的话则表示放弃此次写入。<br>因此，一次完整写入操作的代码如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;</span><br><span class="line">            String key = hashKeyForDisk(imageUrl);</span><br><span class="line">            DiskLruCache.Editor editor = mDiskLruCache.edit(key);</span><br><span class="line">            <span class="keyword">if</span> (editor != <span class="keyword">null</span>) &#123;</span><br><span class="line">                OutputStream outputStream = editor.newOutputStream(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (downloadUrlToStream(imageUrl, outputStream)) &#123;</span><br><span class="line">                    editor.commit();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    editor.abort();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mDiskLruCache.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><br>　　由于这里调用了downloadUrlToStream()方法来从网络上下载图片，所以一定要确保这段代码是在子线程当中执行的。注意在代码的最后我还调用了一下flush()方法，这个方法并不是每次写入都必须要调用的，但在这里却不可缺少，我会在后面说明它的作用。<br>现在的话缓存应该是已经成功写入了，我们进入到SD卡上的缓存目录里看一下，如下图所示：<br><img src="http://img.blog.csdn.net/20140803220637609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>可以看到，这里有一个文件名很长的文件，和一个journal文件，那个文件名很长的文件自然就是缓存的图片了，因为是使用了MD5编码来进行命名的。</p>
<h3 id="读取缓存"><a href="#读取缓存" class="headerlink" title="读取缓存"></a>读取缓存</h3><p>缓存已经写入成功之后，接下来我们就该学习一下如何读取了。读取的方法要比写入简单一些，主要是借助DiskLruCache的get()方法实现的，接口如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>很明显，get()方法要求传入一个key来获取到相应的缓存数据，而这个key毫无疑问就是将图片URL进行MD5编码后的值了，因此读取缓存数据的代码就可以这样写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;</span><br><span class="line">String key = hashKeyForDisk(imageUrl);</span><br><span class="line">DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);</span><br></pre></td></tr></table></figure>
<p>很奇怪的是，这里获取到的是一个DiskLruCache.Snapshot对象，这个对象我们该怎么利用呢？很简单，只需要调用它的getInputStream()方法就可以得到缓存文件的输入流了。同样地，getInputStream()方法也需要传一个index参数，这里传入0就好。有了文件的输入流之后，想要把缓存图片显示到界面上就轻而易举了。所以，一段完整的读取缓存，并将图片加载到界面上的代码如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;</span><br><span class="line">    String key = hashKeyForDisk(imageUrl);</span><br><span class="line">    DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (snapShot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputStream is = snapShot.getInputStream(<span class="number">0</span>);</span><br><span class="line">        Bitmap bitmap = BitmapFactory.decodeStream(is);</span><br><span class="line">        mImage.setImageBitmap(bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们使用了BitmapFactory的decodeStream()方法将文件流解析成Bitmap对象，然后把它设置到ImageView当中。如果运行一下程序，将会看到如下效果：<br><img src="http://img.blog.csdn.net/20140803235312515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>OK，图片已经成功显示出来了。注意这是我们从本地缓存中加载的，而不是从网络上加载的，因此即使在你手机没有联网的情况下，这张图片仍然可以显示出来。</p>
<h3 id="移除缓存"><a href="#移除缓存" class="headerlink" title="移除缓存"></a>移除缓存</h3><p>学习完了写入缓存和读取缓存的方法之后，最难的两个操作你就都已经掌握了，那么接下来要学习的移除缓存对你来说也一定非常轻松了。移除缓存主要是借助DiskLruCache的remove()方法实现的，接口如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><br>相信你已经相当熟悉了，remove()方法中要求传入一个key，然后会删除这个key对应的缓存图片，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    String imageUrl = <span class="string">"http://img.my.csdn.net/uploads/201309/01/1378037235_7476.jpg"</span>;  </span><br><span class="line">    String key = hashKeyForDisk(imageUrl);  </span><br><span class="line">    mDiskLruCache.remove(key);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用法虽然简单，但是你要知道，这个方法我们并不应该经常去调用它。因为你完全不需要担心缓存的数据过多从而占用SD卡太多空间的问题，DiskLruCache会根据我们在调用open()方法时设定的缓存最大值来自动删除多余的缓存。只有你确定某个key对应的缓存内容已经过期，需要从网络获取最新数据的时候才应该调用remove()方法来移除缓存。</p>
<h3 id="其它API"><a href="#其它API" class="headerlink" title="其它API"></a>其它API</h3><p>除了写入缓存、读取缓存、移除缓存之外，DiskLruCache还提供了另外一些比较常用的API，我们简单学习一下。</p>
<ol>
<li>size()</li>
</ol>
<p>这个方法会返回当前缓存路径下所有缓存数据的总字节数，以byte为单位，如果应用程序中需要在界面上显示当前缓存数据的总大小，就可以通过调用这个方法计算出来。比如网易新闻中就有这样一个功能，如下图所示：<br><img src="http://img.blog.csdn.net/20140804204157148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<p>2.flush()</p>
<p>这个方法用于将内存中的操作记录同步到日志文件（也就是journal文件）当中。这个方法非常重要，因为DiskLruCache能够正常工作的前提就是要依赖于journal文件中的内容。前面在讲解写入缓存操作的时候我有调用过一次这个方法，但其实并不是每次写入缓存都要调用一次flush()方法的，频繁地调用并不会带来任何好处，只会额外增加同步journal文件的时间。比较标准的做法就是在Activity的onPause()方法中去调用一次flush()方法就可以了。</p>
<p>3.close()</p>
<p>这个方法用于将DiskLruCache关闭掉，是和open()方法对应的一个方法。关闭掉了之后就不能再调用DiskLruCache中任何操作缓存数据的方法，通常只应该在Activity的onDestroy()方法中去调用close()方法。</p>
<p>4.delete()</p>
<p>这个方法用于将所有的缓存数据全部删除，比如说网易新闻中的那个手动清理缓存功能，其实只需要调用一下DiskLruCache的delete()方法就可以实现了。</p>
<h3 id="解读journal"><a href="#解读journal" class="headerlink" title="解读journal"></a>解读journal</h3><p>　　前面已经提到过，DiskLruCache能够正常工作的前提就是要依赖于journal文件中的内容，因此，能够读懂journal文件对于我们理解DiskLruCache的工作原理有着非常重要的作用。那么journal文件中的内容到底是什么样的呢？我们来打开瞧一瞧吧，如下图所示：<br><img src="http://img.blog.csdn.net/20140804233158296?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""><br>　　由于现在只缓存了一张图片，所以journal中并没有几行日志，我们一行行进行分析。第一行是个固定的字符串“libcore.io.DiskLruCache”，标志着我们使用的是DiskLruCache技术。第二行是DiskLruCache的版本号，这个值是恒为1的。第三行是应用程序的版本号，我们在open()方法里传入的版本号是什么这里就会显示什么。第四行是valueCount，这个值也是在open()方法中传入的，通常情况下都为1。第五行是一个空行。前五行也被称为journal文件的头，这部分内容还是比较好理解的，但是接下来的部分就要稍微动点脑筋了。</p>
<p>　　第六行是以一个DIRTY前缀开始的，后面紧跟着缓存图片的key。通常我们看到DIRTY这个字样都不代表着什么好事情，意味着这是一条脏数据。没错，每当我们调用一次DiskLruCache的edit()方法时，都会向journal文件中写入一条DIRTY记录，表示我们正准备写入一条缓存数据，但不知结果如何。然后调用commit()方法表示写入缓存成功，这时会向journal中写入一条CLEAN记录，意味着这条“脏”数据被“洗干净了”，调用abort()方法表示写入缓存失败，这时会向journal中写入一条REMOVE记录。也就是说，每一行DIRTY的key，后面都应该有一行对应的CLEAN或者REMOVE的记录，否则这条数据就是“脏”的，会被自动删除掉。</p>
<p>　　如果你足够细心的话应该还会注意到，第七行的那条记录，除了CLEAN前缀和key之外，后面还有一个152313，这是什么意思呢？其实，DiskLruCache会在每一行CLEAN记录的最后加上该条缓存数据的大小，以字节为单位。152313也就是我们缓存的那张图片的字节数了，换算出来大概是148.74K，和缓存图片刚刚好一样大，如下图所示：<br><img src="http://img.blog.csdn.net/20140805223723516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ3VvbGluX2Jsb2c=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""><br>前面我们所学的size()方法可以获取到当前缓存路径下所有缓存数据的总字节数，其实它的工作原理就是把journal文件中所有CLEAN记录的字节数相加，求出的总合再把它返回而已。</p>
<p>　　除了DIRTY、CLEAN、REMOVE之外，还有一种前缀是READ的记录，这个就非常简单了，每当我们调用get()方法去读取一条缓存数据时，就会向journal文件中写入一条READ记录。因此，像网易新闻这种图片和数据量都非常大的程序，journal文件中就可能会有大量的READ记录。</p>
<p>　　那么你可能会担心了，如果我不停频繁操作的话，就会不断地向journal文件中写入数据，那这样journal文件岂不是会越来越大？这倒不必担心，DiskLruCache中使用了一个redundantOpCount变量来记录用户操作的次数，每执行一次写入、读取或移除缓存的操作，这个变量值都会加1，当变量值达到2000的时候就会触发重构journal的事件，这时会自动把journal中一些多余的、不必要的记录全部清除掉，保证journal文件的大小始终保持在一个合理的范围内。</p>
<p>　　好了，这样的话我们就算是把DiskLruCache的用法以及简要的工作原理分析完了。至于DiskLruCache的源码还是比较简单的， 限于篇幅原因就不在这里展开了，感兴趣的朋友可以自己去摸索。下一篇文章中，我会带着大家通过一个项目实战的方式来更加深入地理解DiskLruCache的用法。</p>
<p>转自：<a href="http://blog.csdn.net/guolin_blog/article/details/28863651" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/28863651</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Android LayoutInflater理解</title>
    <url>/2016/10/20/android-LayoutInflater/</url>
    <content><![CDATA[<p>LayoutInflater，布局填充器，把XML布局文件实例化为相应的View。Android开发者对LayoutInflater都已经很熟悉了。但是究竟它是如何做到的呢？让我们来简单探究一下主要流程。</p>
<h3 id="LayoutInflater实例"><a href="#LayoutInflater实例" class="headerlink" title="LayoutInflater实例"></a>LayoutInflater实例</h3><p>先看一下LayoutInflater实例的创建<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater inflater = LayoutInflater.from(context);</span><br></pre></td></tr></table></figure></p>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure>
<p>其实这两种写法效果完全一样，只不过Android给我们简单封装一下。LayoutInflater.from()的源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtains the LayoutInflater from the given context.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LayoutInflater <span class="title">from</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    LayoutInflater LayoutInflater =</span><br><span class="line">            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (LayoutInflater == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"LayoutInflater not found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> LayoutInflater;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="inflate加载布局文件"><a href="#inflate加载布局文件" class="headerlink" title="inflate加载布局文件"></a>inflate加载布局文件</h3><p>得到了LayoutInflater的实例之后就可以调用它的inflate()方法来加载布局了，可以使用两个参数的方法，也可以用三个参数的 如下所示：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">View view = inflater.inflate(R.layout.button_layout, <span class="keyword">null</span>);</span><br><span class="line">View view = inflater.inflate(R.layout.button_layout, mainLayout, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><br>这两种又有什么区别呢？我们查看两个参数的方法可以看到：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> inflate(resource, root, root != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">    final Resources res &#x3D; getContext().getResources();</span><br><span class="line"></span><br><span class="line">    final XmlResourceParser parser &#x3D; res.getLayout(resource);</span><br><span class="line">    try &#123;</span><br><span class="line">        return inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用inflate(int resource, ViewGroup root)时，系统会根据你传入的root是否为空设置默认值。如果root为null则attachToRoot为false，root不为null时attachToRoot为true。在inflate中才调用了真正的inflate去解析XML填充为View。inflate源码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"inflate"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">        <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">        Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">        mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">        <span class="comment">// 先指定返回结果为root</span></span><br><span class="line">        View result = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Look for the root node.</span></span><br><span class="line">            <span class="keyword">int</span> type;</span><br><span class="line">            <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                    type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 type != 开始节点抛出错误</span></span><br><span class="line">            <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(parser.getPositionDescription()</span><br><span class="line">                        + <span class="string">": No start tag found!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前节点的名字，也就是当前layout的根节点的名字</span></span><br><span class="line">            <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 处理 merge 节点</span></span><br><span class="line">            <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                <span class="comment">// root必须非空且attachToRoot为true，否则抛异常结束</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                            + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Temp is the root view that was found in the xml</span></span><br><span class="line">                <span class="comment">// 根据节点的名字与属性创建View，createViewFromTag里会调用createView方法，然后利用反射实例化view对象</span></span><br><span class="line">                <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Create layout params that match root, if supplied</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 把布局文件中layout属性读取出来</span></span><br><span class="line">                    params = root.generateLayoutParams(attrs);</span><br><span class="line">                    <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">                        <span class="comment">// Set the layout params for temp if we are not</span></span><br><span class="line">                        <span class="comment">// attaching. (If we are, we use addView, below)</span></span><br><span class="line">                        <span class="comment">// attachToRoot为false 设置根视图的layout属性</span></span><br><span class="line">                        temp.setLayoutParams(params);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Inflate all children under temp against its context.</span></span><br><span class="line">                <span class="comment">// 递归查找这个视图下所有子视图</span></span><br><span class="line">                rInflateChildren(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// We are supposed to attach all the views we found (int temp)</span></span><br><span class="line">                <span class="comment">// to root. Do that now.</span></span><br><span class="line">                <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 把resource中根视图直接添加到root里，并设置根视图的layout属性</span></span><br><span class="line">                    root.addView(temp, params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Decide whether to return the root that was passed in or the</span></span><br><span class="line">                <span class="comment">// top view found in xml.</span></span><br><span class="line">                <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                    <span class="comment">// 如果root为null，或者attachToRoot为false，result的值改为根视图</span></span><br><span class="line">                    <span class="comment">// 注意开始result的值是root，result为inflate方法最终返回的值</span></span><br><span class="line">                    result = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">            InflateException ex = <span class="keyword">new</span> InflateException(e.getMessage());</span><br><span class="line">            ex.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            InflateException ex = <span class="keyword">new</span> InflateException(</span><br><span class="line">                    parser.getPositionDescription()</span><br><span class="line">                            + <span class="string">": "</span> + e.getMessage());</span><br><span class="line">            ex.initCause(e);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// Don't retain static reference on context.</span></span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            mConstructorArgs[<span class="number">1</span>] = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>总结：</p>
<ol>
<li>如果root为null，不会去读取布局文件中的layout属性，所以layout属性无效。attachToRoot将失去作用，设置任何值都没有意义。</li>
<li>如果root不为null，attachToRoot设为true，则会给加载的布局文件的指定一个父布局，即root。</li>
<li>如果root不为null，attachToRoot设为false，则会将布局文件最外层的所有layout属性进行设置，当该view被添加到父view当中时，这些layout属性会自动生效。</li>
<li>在不设置attachToRoot参数的情况下，如果root不为null，attachToRoot参数默认为true。</li>
</ol>
<p>转载请注明出处：<a href="https://blog.lovek.vip/2016/10/20/android-LayoutInflater/">https://blog.lovek.vip/2016/10/20/android-LayoutInflater</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Android高效加载大图、多图解决方案</title>
    <url>/2014/11/05/android-LruCache/</url>
    <content><![CDATA[<p>本篇文章主要内容来自于Android Doc，我翻译之后又做了些加工，英文好的朋友也可以直接去读原文。</p>
<p><a href="http://developer.android.com/training/displaying-bitmaps/index.html" target="_blank" rel="noopener">http://developer.android.com/training/displaying-bitmaps/index.html</a></p>
<h2 id="高效加载大图片"><a href="#高效加载大图片" class="headerlink" title="高效加载大图片"></a>高效加载大图片</h2><p>　　我们在编写Android程序的时候经常要用到许多图片，不同图片总是会有不同的形状、不同的大小，但在大多数情况下，这些图片都会大于我们程序所需要的大小。比如说系统图片库里展示的图片大都是用手机摄像头拍出来的，这些图片的分辨率会比我们手机屏幕的分辨率高得多。大家应该知道，我们编写的应用程序都是有一定内存限制的，程序占用了过高的内存就容易出现OOM(OutOfMemory)异常。我们可以通过下面的代码看出每个应用程序最高可用内存是多少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"Max memory is "</span> + maxMemory + <span class="string">"KB"</span>);</span><br></pre></td></tr></table></figure>
<p>　　因此在展示高分辨率图片的时候，最好先将图片进行压缩。压缩后的图片大小应该和用来展示它的控件大小相近，在一个很小的ImageView上显示一张超大的图片不会带来任何视觉上的好处，但却会占用我们相当多宝贵的内存，而且在性能上还可能会带来负面影响。下面我们就来看一看，如何对一张大图片进行适当的压缩，让它能够以最佳大小显示的同时，还能防止OOM的出现。<br>　　BitmapFactory这个类提供了多个解析方法(decodeByteArray, decodeFile, decodeResource等)用于创建Bitmap对象，我们应该根据图片的来源选择合适的方法。比如SD卡中的图片可以使用decodeFile方法，网络上的图片可以使用decodeStream方法，资源文件中的图片可以使用decodeResource方法。这些方法会尝试为已经构建的bitmap分配内存，这时就会很容易导致OOM出现。为此每一种解析方法都提供了一个可选的BitmapFactory.Options参数，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存，返回值也不再是一个Bitmap对象，而是null。虽然Bitmap是null了，但是BitmapFactory.Options的outWidth、outHeight和outMimeType属性都会被赋值。这个技巧让我们可以在加载图片之前就获取到图片的长宽值和MIME类型，从而根据情况对图片进行压缩。如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">BitmapFactory.decodeResource(getResources(), R.id.myimage, options);</span><br><span class="line"><span class="keyword">int</span> imageHeight = options.outHeight;</span><br><span class="line"><span class="keyword">int</span> imageWidth = options.outWidth;</span><br><span class="line">String imageType = options.outMimeType;</span><br></pre></td></tr></table></figure>
<p>　　为了避免OOM异常，最好在解析每张图片的时候都先检查一下图片的大小，除非你非常信任图片的来源，保证这些图片都不会超出你程序的可用内存。<br>　　现在图片的大小已经知道了，我们就可以决定是把整张图片加载到内存中还是加载一个压缩版的图片到内存中。以下几个因素是我们需要考虑的：</p>
<blockquote>
<ul>
<li>预估一下加载整张图片所需占用的内存。</li>
<li>为了加载这一张图片你所愿意提供多少内存。</li>
<li>用于展示这张图片的控件的实际大小。</li>
<li>当前设备的屏幕尺寸和分辨率。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"Max memory is "</span> + maxMemory + <span class="string">"KB"</span>);</span><br></pre></td></tr></table></figure>
<p>　　比如，你的ImageView只有128*96像素的大小，只是为了显示一张缩略图，这时候把一张1024*768像素的图片完全加载到内存中显然是不值得的。</p>
<p>　　那我们怎样才能对图片进行压缩呢？通过设置BitmapFactory.Options中inSampleSize的值就可以实现。比如我们有一张2048*1536像素的图片，将inSampleSize的值设置为4，就可以把这张图片压缩成512*384像素。原本加载这张图片需要占用13M的内存，压缩后就只需要占用0.75M了(假设图片是ARGB_8888类型，即每个像素点占用4个字节)。下面的方法可以根据传入的宽和高，计算出合适的inSampleSize值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateInSampleSize</span><span class="params">(BitmapFactory.Options options,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 源图片的高度和宽度</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> height = options.outHeight;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> width = options.outWidth;</span><br><span class="line">    <span class="keyword">int</span> inSampleSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">        <span class="comment">// 计算出实际宽高和目标宽高的比率</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> heightRatio = Math.round((<span class="keyword">float</span>) height / (<span class="keyword">float</span>) reqHeight);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> widthRatio = Math.round((<span class="keyword">float</span>) width / (<span class="keyword">float</span>) reqWidth);</span><br><span class="line">        <span class="comment">// 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span></span><br><span class="line">        <span class="comment">// 一定都会大于等于目标的宽和高。</span></span><br><span class="line">        inSampleSize = heightRatio &lt; widthRatio ? heightRatio : widthRatio;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inSampleSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　　使用这个方法，首先你要将BitmapFactory.Options的inJustDecodeBounds属性设置为true，解析一次图片。然后将BitmapFactory.Options连同期望的宽度和高度一起传递到到calculateInSampleSize方法中，就可以得到合适的inSampleSize值了。之后再解析一次图片，使用新获取到的inSampleSize值，并把inJustDecodeBounds设置为false，就可以得到压缩后的图片了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">decodeSampledBitmapFromResource</span><span class="params">(Resources res, <span class="keyword">int</span> resId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> reqWidth, <span class="keyword">int</span> reqHeight)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次解析将inJustDecodeBounds设置为true，来获取图片大小</span></span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">    <span class="comment">// 调用上面定义的方法计算inSampleSize值</span></span><br><span class="line">    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">    <span class="comment">// 使用获取到的inSampleSize值再次解析图片</span></span><br><span class="line">    options.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> BitmapFactory.decodeResource(res, resId, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的代码非常简单地将任意一张图片压缩成100*100的缩略图，并在ImageView上展示。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mImageView.setImageBitmap(</span><br><span class="line">    decodeSampledBitmapFromResource(getResources(), R.id.myimage, <span class="number">100</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure>
<h2 id="使用图片缓存技术"><a href="#使用图片缓存技术" class="headerlink" title="使用图片缓存技术"></a>使用图片缓存技术</h2><p>　　在你应用程序的UI界面加载一张图片是一件很简单的事情，但是当你需要在界面上加载一大堆图片的时候，情况就变得复杂起来。在很多情况下，（比如使用ListView, GridView 或者 ViewPager 这样的组件），屏幕上显示的图片可以通过滑动屏幕等事件不断地增加，最终导致OOM。<br>为了保证内存的使用始终维持在一个合理的范围，通常会把被移除屏幕的图片进行回收处理。此时垃圾回收器也会认为你不再持有这些图片的引用，从而对这些图片进行GC操作。用这种思路来解决问题是非常好的，可是为了能让程序快速运行，在界面上迅速地加载图片，你又必须要考虑到某些图片被回收之后，用户又将它重新滑入屏幕这种情况。这时重新去加载一遍刚刚加载过的图片无疑是性能的瓶颈，你需要想办法去避免这个情况的发生。</p>
<p>　　这个时候，使用内存缓存技术可以很好的解决这个问题，它可以让组件快速地重新加载和处理图片。下面我们就来看一看如何使用内存缓存技术来对图片进行缓存，从而让你的应用程序在加载很多图片的时候可以提高响应速度和流畅性。</p>
<p>　　内存缓存技术对那些大量占用应用程序宝贵内存的图片提供了快速访问的方法。其中最核心的类是LruCache (此类在android-support-v4的包中提供) 。这个类非常适合用来缓存图片，它的主要算法原理是把最近使用的对象用强引用存储在 LinkedHashMap 中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。</p>
<p>　　在过去，我们经常会使用一种非常流行的内存缓存技术的实现，即软引用或弱引用 (SoftReference or WeakReference)。但是现在已经不再推荐使用这种方式了，因为从 Android 2.3 (API Level 9)开始，垃圾回收器会更倾向于回收持有软引用或弱引用的对象，这让软引用和弱引用变得不再可靠。另外，Android 3.0 (API Level 11)中，图片的数据会存储在本地的内存当中，因而无法用一种可预见的方式将其释放，这就有潜在的风险造成应用程序的内存溢出并崩溃。</p>
<p>　　为了能够选择一个合适的缓存大小给LruCache,有以下多个因素应该放入考虑范围内，例如：</p>
<blockquote>
<ul>
<li>你的设备可以为每个应用程序分配多大的内存？</li>
<li>设备屏幕上一次最多能显示多少张图片？有多少图片需要进行预加载，因为有可能很快也会显示在屏幕上？</li>
<li>你的设备的屏幕大小和分辨率分别是多少？一个超高分辨率的设备（例如 Galaxy Nexus) 比起一个较低分辨率的设备（例如 Nexus S），在持有相同数量图片的时候，需要更大的缓存空间。</li>
<li>图片的尺寸和大小，还有每张图片会占据多少内存空间。</li>
<li>图片被访问的频率有多高？会不会有一些图片的访问频率比其它图片要高？如果有的话，你也许应该让一些图片常驻在内存当中，或者使用多个LruCache 对象来区分不同组的图片。</li>
<li>你能维持好数量和质量之间的平衡吗？有些时候，存储多个低像素的图片，而在后台去开线程加载高像素的图片会更加的有效。</li>
</ul>
</blockquote>
<p>　　并没有一个指定的缓存大小可以满足所有的应用程序，这是由你决定的。你应该去分析程序内存的使用情况，然后制定出一个合适的解决方案。一个太小的缓存空间，有可能造成图片频繁地被释放和重新加载，这并没有好处。而一个太大的缓存空间，则有可能还是会引起 java.lang.OutOfMemory 的异常。</p>
<p>下面是一个使用 LruCache 来缓存图片的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> LruCache&lt;String, Bitmap&gt; mMemoryCache;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取到可用内存的最大值，使用内存超出这个值会引起OutOfMemory异常。</span></span><br><span class="line">    <span class="comment">// LruCache通过构造函数传入缓存值，以KB为单位。</span></span><br><span class="line">    <span class="keyword">int</span> maxMemory = (<span class="keyword">int</span>) (Runtime.getRuntime().maxMemory() / <span class="number">1024</span>);</span><br><span class="line">    <span class="comment">// 使用最大可用内存值的1/8作为缓存的大小。</span></span><br><span class="line">    <span class="keyword">int</span> cacheSize = maxMemory / <span class="number">8</span>;</span><br><span class="line">    mMemoryCache = <span class="keyword">new</span> LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">sizeOf</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 重写此方法来衡量每张图片的大小，默认返回图片数量。</span></span><br><span class="line">            <span class="keyword">return</span> bitmap.getByteCount() / <span class="number">1024</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBitmapToMemoryCache</span><span class="params">(String key, Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBitmapFromMemCache(key) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mMemoryCache.put(key, bitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFromMemCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mMemoryCache.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　在这个例子当中，使用了系统分配给应用程序的八分之一内存来作为缓存大小。在中高配置的手机当中，这大概会有4兆(32/8)的缓存空间。一个全屏幕的 GridView 使用4张 800x480分辨率的图片来填充，则大概会占用1.5兆的空间(800<em>480</em>4)。因此，这个缓存大小可以存储2.5页的图片。<br>当向 ImageView 中加载一张图片时,首先会在 LruCache 的缓存中进行检查。如果找到了相应的键值，则会立刻更新ImageView ，否则开启一个后台线程来加载这张图片。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadBitmap</span><span class="params">(<span class="keyword">int</span> resId, ImageView imageView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String imageKey = String.valueOf(resId);</span><br><span class="line">    <span class="keyword">final</span> Bitmap bitmap = getBitmapFromMemCache(imageKey);</span><br><span class="line">    <span class="keyword">if</span> (bitmap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        imageView.setImageBitmap(bitmap);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        imageView.setImageResource(R.drawable.image_placeholder);</span><br><span class="line">        BitmapWorkerTask task = <span class="keyword">new</span> BitmapWorkerTask(imageView);</span><br><span class="line">        task.execute(resId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BitmapWorkerTask 还要把新加载的图片的键值对放到缓存中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitmapWorkerTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Integer</span>, <span class="title">Void</span>, <span class="title">Bitmap</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 在后台加载图片。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Bitmap <span class="title">doInBackground</span><span class="params">(Integer... params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Bitmap bitmap = decodeSampledBitmapFromResource(</span><br><span class="line">                getResources(), params[<span class="number">0</span>], <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">        addBitmapToMemoryCache(String.valueOf(params[<span class="number">0</span>]), bitmap);</span><br><span class="line">        <span class="keyword">return</span> bitmap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　掌握了以上两种方法，不管是要在程序中加载超大图片，还是要加载大量图片，都不用担心OOM的问题了!不过仅仅是理论地介绍不知道大家能不能完全理解，在后面的文章中我会演示如何在实际程序中灵活运用上述技巧来避免程序OOM，感兴趣的朋友请继续阅读<a href="../android-DisLrukCache">Android DiskLruCache完全解析，硬盘缓存的最佳方案</a></p>
<p>转自：<a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="noopener">http://blog.csdn.net/guolin_blog/article/details/9316683</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Android中常见的内存泄漏汇总</title>
    <url>/2018/04/21/android-memory-leak/</url>
    <content><![CDATA[<h3 id="为什么会产生内存泄漏？"><a href="#为什么会产生内存泄漏？" class="headerlink" title="为什么会产生内存泄漏？"></a>为什么会产生内存泄漏？</h3><p>当一个对象已经不需要再使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏。<br>Android中常见的内存泄漏汇总</p>
<h4 id="单例造成的内存泄漏"><a href="#单例造成的内存泄漏" class="headerlink" title="单例造成的内存泄漏"></a>单例造成的内存泄漏</h4><p>单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏，由于单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。</p>
<p>如下这个典例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context             context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要：</p>
<ol>
<li>传入的是Application的Context：这将没有任何问题，因为单例的生命周期和Application的一样长</li>
<li>传入的是Activity的Context：当这个Context所对应的Activity退出时，由于该Context和Activity的生命周期一样长（Activity间接继承于Context），所以当前Activity退出时它的内存并不会被回收，因为单例对象持有该Activity的引用。<br>所以正确的单例应该修改为下面这种方式：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AppManager instance;</span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AppManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context.getApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AppManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> AppManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样不管传入什么Context最终将使用Application的Context，而单例的生命周期和应用的一样长，这样就防止了内存泄漏<h3 id="非静态内部类创建静态实例造成的内存泄漏"><a href="#非静态内部类创建静态实例造成的内存泄漏" class="headerlink" title="非静态内部类创建静态实例造成的内存泄漏"></a>非静态内部类创建静态实例造成的内存泄漏</h3>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestResource mResource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">if</span>(mResource == <span class="keyword">null</span>)&#123;</span><br><span class="line">            mResource = <span class="keyword">new</span> TestResource();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TestResource</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而又使用了该非静态内部类创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为：<br>将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请使用ApplicationContext<h3 id="Handler造成的内存泄漏"><a href="#Handler造成的内存泄漏" class="headerlink" title="Handler造成的内存泄漏"></a>Handler造成的内存泄漏</h3>Handler的使用造成的内存泄漏问题应该说最为常见了，平时在处理网络任务或者封装一些请求回调等api都应该会借助Handler来处理，对于Handler的使用代码编写一不规范即有可能造成内存泄漏，如下示例：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这种创建Handler的方式会造成内存泄漏，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏，所以另外一种做法为：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">            activity.mTextView.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息，更准确的做法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">new</span> MyHandler(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> TextView mTextView ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Context&gt; reference;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        reference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            <span class="keyword">if</span>(activity != <span class="keyword">null</span>)&#123;</span><br><span class="line">            activity.mTextView.setText(<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...request</span></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用mHandler.removeCallbacksAndMessages(null);是移除消息队列中所有消息和所有的Runnable。当然也可以使用mHandler.removeCallbacks();或mHandler.removeMessages();来移除指定的Runnable和Message。<h3 id="线程造成的内存泄漏"><a href="#线程造成的内存泄漏" class="headerlink" title="线程造成的内存泄漏"></a>线程造成的内存泄漏</h3>对于线程造成的内存泄漏，也是平时比较常见的，异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，<br>那么将导致Activity的内存资源无法回收，造成内存泄漏。正确的做法还是使用静态内部类的方式，如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Context&gt; weakReference;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void aVoid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPostExecute(aVoid);</span><br><span class="line">        MainActivity activity = (MainActivity) weakReference.get();</span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SystemClock.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//——————</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line"><span class="keyword">new</span> MyAsyncTask(<span class="keyword">this</span>).execute();</span><br></pre></td></tr></table></figure>
这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。</li>
</ol>
<h3 id="资源未关闭造成的内存泄漏"><a href="#资源未关闭造成的内存泄漏" class="headerlink" title="资源未关闭造成的内存泄漏"></a>资源未关闭造成的内存泄漏</h3><p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。</p>
<p>一些建议</p>
<ol>
<li>对于生命周期比Activity长的对象如果需要应该使用ApplicationContext</li>
<li>对于需要在静态内部类中使用非静态外部成员变量（如：Context、View )，可以在静态内部类中使用弱引用来引用外部类的变量来避免内存泄漏</li>
<li>对于不再需要使用的对象，显示的将其赋值为null，比如使用完Bitmap后先调用recycle()，再赋为null</li>
<li>保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期</li>
<li><p>对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏：</p>
<ul>
<li>将内部类改为静态内部类</li>
<li>静态内部类中使用弱引用来引用外部类的成员变量</li>
</ul>
</li>
<li><p>在涉及到Context时先考虑ApplicationContext，当然它并不是万能的，对于有些地方则必须使用Activity的Context。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title>10 条提升 Android 性能的建议</title>
    <url>/2018/03/16/android-optimization/</url>
    <content><![CDATA[<p>每个人都知道一个 App 的成功，与这个 App 的性能体验有着很密切的关系。但是如何让你的 App 拥有极致性能体验呢？在 DroidCon NYC 2015 的这个分享里，Boris Farber 带来了他关于 Android Api 以及如何避免一些常见坑的经验。带你了解如何缩短启动时间，优化滑动效果，创建更加顺滑的用户体验。</p>
<p>Save the date for Droidcon SF in March — a conference with best-in-class presentations from leaders in all parts of the Android ecosystem.</p>
<h3 id="简介-0-00"><a href="#简介-0-00" class="headerlink" title="简介 (0:00)"></a>简介 (0:00)</h3><p>大家好，我是 Boris，现在是 Google 的一枚员工，目前专注于需要高性能的 App。这个分享是我长期以来从错误中，以及在给合作伙伴做咨询的时候攒下的最佳实践。如果你有一个小型的 App，读过之后，会在你的 App 成长阶段起到帮助。</p>
<p>我常常会见到那些启动时间很长，滑动不流畅，甚至出现没有反应的 App。我们通常要花很多时间去改善这些问题，毕竟我们都希望自己的 App 能够成功。</p>
<h3 id="Activity-泄漏-1-17"><a href="#Activity-泄漏-1-17" class="headerlink" title="Activity 泄漏 (1:17)"></a>Activity 泄漏 (1:17)</h3><p>我们第一个需要修复的问题就是 Activity 泄漏，我们先来看看内存泄漏是怎么发生的。 Activity 泄漏通常是内存泄漏的一种。为什么会泄漏呢？如果你持有一个未使用的 Activity 的引用，其实也就持有了 Activity 的布局，自然也就包含了所有的 View。最棘手的是持有静态引用。别忘了，Activity 和 Fragment 都有自己的生命周期。一旦我们持有了静态引用，Activity 和 Fragment 就不会被垃圾回收器清理掉了。这就是为什么静态引用很危险。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">m_staticActivity = staticFragment.getActivity()</span><br></pre></td></tr></table></figure><br>我看过太多次这样的代码了。</p>
<p>另外，泄漏 Listener 也是经常会发生的事情。比如说，我有下面的代码。LeakActivity继承自 Activity，我们有一个单例：NastyManager，当我们通过 addListener(this) 将 Activity 作为 Listener 和 NastyManager 绑定起来的时候，不好的事情就发生了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeakActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    NastyManager.getInstance().addListener(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>想要修复这样的 Bug，其实相当简单，就是在你的 Acitivity 被销毁的时候，将他和 NastyManager 取消掉绑定就好了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">  NastyManager.getInstance().removeListener(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>相对上面的解决方案，我们自然还有更好的。比如我们真的需要用到单例吗？通常，并不需要。不过某些时候可能真的很需要。我们得权衡和设计。不过无论如何，记住，<code>当 Activity 销毁的时候，在单例中移除掉对 Activity 的引用</code>。下面我们讨论下： 如果是内部类，会发生什么？比如说，我们有一个在 Activity 里有一个很简短的非静态 Handler。</p>
<p>尽管它看起来很短，但是只要它还存活着，那么包含它的 Activity 就会存活着。如果你不信我，在 VM 里试试看。这就是另一个内存泄漏的案例： <code>Activity 内部的 Handler</code>。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  Handler handler;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Handler 是个很常用也很有用的类，异步，线程安全等等。如果有下面这样的代码，会发生什么呢？handler.postDeslayed ，假设 delay 时间是几个小时… 这意味着什么？意味着只要 handler 的消息还没有被处理结束，它就一直存活着，包含它的 Activity 就跟着活着。我们来想办法修复它，修复的方案是WeakReference，也就是所谓的弱引用。垃圾回收器在回收的时候，是会忽视掉弱引用的，所以包含它的 Activity 会被正常清理掉。大概代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123; </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;MainActivity&gt; mActivity; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(MainActivity activity)</span> </span>&#123;</span><br><span class="line">    mActivity = <span class="keyword">new</span> WeakReference&lt;MainActivity&gt;(activity);</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>概括来说：我们有个内部类，就像 Handler，内部非静态类是不能脱离所属类而单独存活的，Android 里通常是 Activity。所以，看看你的代码里的内部类，确保他们没有出现内存泄漏。</p>
<p>相比非静态内部类，最好使用静态内部类。区别就是静态内部类不依赖所属类，他们拥有不同的生命周期。我经常见到类似的原因引起的内存泄露。</p>
<h3 id="如何避免-Activity-泄漏-8-37"><a href="#如何避免-Activity-泄漏-8-37" class="headerlink" title="如何避免 Activity 泄漏? (8:37)"></a>如何避免 Activity 泄漏? (8:37)</h3><ul>
<li>移除掉所有的静态引用。</li>
<li>考虑用 EventBus 来解耦 Listener。</li>
<li>记着在不需要的时候，解除 Listener 的绑定。</li>
<li>尽量用静态内部类。</li>
<li>做 Code Review。个人经验：Code Review 能很早的发现内存泄漏。</li>
<li>了解你程序的结构。</li>
<li>用类似 MAT，Eclipse Analyzer，LeakCanary 这样的工具分析内存。</li>
<li>在 Callback 里打印 Log。</li>
</ul>
<h3 id="滑动-10-05"><a href="#滑动-10-05" class="headerlink" title="滑动 (10:05)"></a>滑动 (10:05)</h3><p>实现流畅滑动的技巧：UI 线程只用作 UI 渲染。这一条真谛能够解决 99% 的滑动卡顿问题。不要在 UI 线程做下面的事情：</p>
<ul>
<li>载入图片</li>
<li>网络请求</li>
<li>解析 JSON</li>
<li>读取数据库</li>
</ul>
<p>做这些操作是很慢的，像图片，网络，JSON考虑用现成的库，有很多社区提供的解决方案，数据库考虑下用 Loader，支持批量更新和载入。</p>
<h3 id="图片-11-26"><a href="#图片-11-26" class="headerlink" title="图片 (11:26)"></a>图片 (11:26)</h3><p>图片相关的库有很多，比如 Glide, Picasso, Fresco。你可以自己去了解下他们之间的区别，以帮助自己在特定场景下做出取舍。</p>
<h3 id="内存-12-13"><a href="#内存-12-13" class="headerlink" title="内存(12:13)"></a>内存(12:13)</h3><p>Bitmap 操作是很需要技巧的，图片一般比较大，而且系统对最大内存又有限制和要求。在我面对 4.0 之前的系统的时候，我简直要崩溃了。内存管理也很需要技巧。有的时候需要放到文件里，有的时候需要放到内存里，别忘了，我们还有一个很有用的工具：LRUCache。</p>
<h3 id="网络-12-54"><a href="#网络-12-54" class="headerlink" title="网络(12:54)"></a>网络(12:54)</h3><p>首先，Java 的网络请求确实是 Android 的一个阻碍。很多 Java.net 的 API 都是阻断执行的，切记不可在 UI 线程执行网络请求。在线程里执行或者直接使用第三方库吧。</p>
<p>异步 HTTP 其实也挺麻烦的，4.4 起 OkHttp 就成了 Android 代码的一部分了，然而… 如果你需要最新版本的 OkHttp ，可以考虑自己引入。另外有个不错的库叫： Volley，也可以试试 Square 的 Retrofit。这些都能让你的网络请求变得更友好。</p>
<h3 id="大-JSON-14-35"><a href="#大-JSON-14-35" class="headerlink" title="大 JSON (14:35)"></a>大 JSON (14:35)</h3><p>在 UI 线程，也不做解析 Json 的事情，因为这是一个很耗时的事情。试着用 Google 的 GSON 来做反序列化的操作。</p>
<p>对于巨大的 JSON 解析，建议用更快的 Jackson 以及 ig-json-parser，这两个工具在 JSON 的解析上做的非常漂亮。从公司的反馈结果来看 ig-json-parser 的效率是最高的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Looper.myLooper() == Looper.getMainLooper()</span><br></pre></td></tr></table></figure><br>是可以帮助你确定你是否在主线程的代码。</p>
<h3 id="如何优化滑动速度-16-56"><a href="#如何优化滑动速度-16-56" class="headerlink" title="如何优化滑动速度? (16:56)"></a>如何优化滑动速度? (16:56)</h3><ul>
<li>UI 线程只做 UI 更新。</li>
<li>理解并发 API。</li>
<li>开始使用优秀的第三方库。</li>
<li>使用 Loader 加载数据库数据</li>
</ul>
<p>之所以要用第三方库，是因为你自己去完善一个复杂功能是需要花时间的。如果你打算专注在自己的功能性的 App 上，那么用库吧。</p>
<h3 id="并发-APIs-18-00"><a href="#并发-APIs-18-00" class="headerlink" title="并发 APIs (18:00)"></a>并发 APIs (18:00)</h3><p>如何让 App 快速响应请求是个很重要。开发者们，甚至包括我，经常忘记 Service 的方法是在 UI 线程执行的。请考虑使用 IntentService，AsyncTask，Executors，Handler 和 Loopers。</p>
<p>我们来盘点下这些的区别：</p>
<h3 id="IntentService-19-07"><a href="#IntentService-19-07" class="headerlink" title="IntentService (19:07)"></a>IntentService (19:07)</h3><p>我在之前的公司，我用 IntentService 来执行上传功能。IntentService 是一个单线程，一次一个任务的工作流。我们没有很复杂的任务系统。如果你有大型复杂的任务，而且这个任务不需要跟 UI 打交道，那么考虑用 IntentService 吧。</p>
<h3 id="AsyncTask-19-56"><a href="#AsyncTask-19-56" class="headerlink" title="AsyncTask (19:56)"></a>AsyncTask (19:56)</h3><p>如果你的任务需要更新 UI，那么考虑用 AsyncTask 吧，AsyncTask 虽然相对容易，但是有些坑得留意。当你旋转手机的时候，Activity 会被关闭，然后重启。不然可能造成内存泄露。</p>
<h3 id="Executor-Framework-21-11"><a href="#Executor-Framework-21-11" class="headerlink" title="Executor Framework (21:11)"></a>Executor Framework (21:11)</h3><p>这是 Java 6 自带的并发方案。默认是存在一个由系统管理的线程池，你可以通过 callback，future 来控制和管理。这根 MapRedues 发难有点像，面对复杂的任务，你希望能够把他们拆分交给多个线程来处理。Executor 的框架就很能胜任这种场景。</p>
<p>如何适应并发APIs? (22:07)</p>
<ul>
<li>学会和理解 API，懂得权衡</li>
<li>确保找到了问题的正确解决方案</li>
<li>了解问题真实所在</li>
<li>重构代码</li>
</ul>
<h3 id="Deprecation-22-42"><a href="#Deprecation-22-42" class="headerlink" title="Deprecation (22:42)"></a>Deprecation (22:42)</h3><p>我们肯定都知道，最好能够避免使用废弃的 API。比如以下的例子：</p>
<ul>
<li>不要通过反射来调用私有 API。</li>
<li>不要再 NDK 和 C 语言层调用私有 Native 方法。</li>
<li>不要轻易调用 Runtime.exec 指令完成进程通讯功能。</li>
<li>adb shell am 做进程通讯并不好。</li>
</ul>
<p>废弃的意思是这些 API 将会被移除，通常在正式版发布 1，2天左右，你的 App 就不会工作了。更糟糕的情况是，如果你的 App 依赖了一些库，而这些库哟改了废弃的 Api 或者工具。那可就惨了，如果一旦作者没有更新…你懂得。</p>
<p>不要用废弃 Api 的另一个原因是性能问题和安全问题。</p>
<p>如何避免废弃 Api：</p>
<ul>
<li>使用正确的 API。</li>
<li>重构依赖。</li>
<li>不要滥用系统。</li>
<li>更新依赖和工具。</li>
<li>越新的通常越好。</li>
</ul>
<p>用 Toolbar 而非 ActionBar，在需要动画的时候用 RecyclerView，因为它专门为动画做过优化。同时 Android M 里移除了 Apache Http Connection。请使用 HttpURLConnection，它拥有更简单的 API，更小的体积，默认的压缩功能，更好的 Response 缓存，等等其他很赞的功能。</p>
<h3 id="架构-27-03"><a href="#架构-27-03" class="headerlink" title="架构 (27:03)"></a>架构 (27:03)</h3><p>架构中的 Bug 总是最为烦人。想要避免这种问题，学习下 App 组件的生命周期。比如什么是 Activity 的 Flag？什么是 Fragment？什么事 stated fragment？什么是 task？读读文档，尝试下用回调的 log 搞清楚这些概念。</p>
<p>时常有人问我：“Picasso 和 Glide 哪个更好？我改用 Volley 还是 OkHttp？”，这种问题根本没有 100% 正确的答案。不过，当我在选择一个库的时候，我会用下面的 Checklist 来决策：</p>
<p>确保它能够解决你的问题。<br>确保它和当前所有的依赖能正常工作。<br>检查依赖<br>留意一下依赖的版本冲突<br>了解维护情况和成本<br>总的来说，提及架构和设计，最好的方法就是让你的程序最快响应。确保用户能够快速理解你的 App，并且拥有良好体验。</p>
<p><a href="https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/?w=1&amp;w=1" target="_blank" rel="noopener">转自：https://realm.io/cn/news/droidcon-farber-improving-android-app-performance/?w=1&amp;w=1</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>View绘制的measure过程</title>
    <url>/2018/11/05/android-view-measure/</url>
    <content><![CDATA[<p>在Activity中，所有的View都是DecorView的子View，然后DecorView又是被ViewRootImpl所控制，当Activity显示的时候，ViewRootImpl的performTranversals方法开始运行，这个方法很长，不过核心的三个流程就是依次调用performMeasure、performLayout、performDraw三个方法，从而完成DecorView的绘制。</p>
<p>其中，<code>ViewRootImpl#performMeasure</code>方法如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里直接调用了mView的measure方法，参数是两个经过设置的MeasureSpec，接下来我们分析一下MeasureSpec是如何设置的。</p>
<h3 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h3><p>测量规格（MeasureSpec） = 测量模式（mode） + 测量大小（size）<br>这个MeasureSpec不是实际测绘值，而是父View传递给子View的布局要求，MeasureSpec涵盖了对子View大小和模式的要求。其中，三种模式要求分别是：</p>
<p>UNSPECIFIED：对子View无任何要求，想要测绘多少由子View决定。<br>EXACTLY：父View已确定了自己确切的大小。子View将在这个边界内测绘自己的宽高。<br>AT_MOST：父View对子View没有要求，子View可以达到它想要的大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                      @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123;</span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MeasureSpec是个32位的int值，其中高两位代表的是模式，低30位代表父View的尺寸。</p>
<h3 id="measure过程"><a href="#measure过程" class="headerlink" title="measure过程"></a>measure过程</h3><p>计算完MeasureSpec，DecorView就该执行measure方法了。<br>measure方法是final的，所以不能重写，不过measure方法最主要的作用就是调用了onMeasure方法。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：measure（）</span></span><br><span class="line"><span class="comment">  * 定义：Measure过程的入口；属于View.java类 &amp; final类型，即子类不能重写此方法</span></span><br><span class="line"><span class="comment">  * 作用：基本测量逻辑的判断</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数说明：View的宽 / 高测量规格</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cacheIndex = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT ? -<span class="number">1</span> :</span><br><span class="line">                mMeasureCache.indexOfKey(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">            </span><br><span class="line">            onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">            <span class="comment">// 计算视图大小 -&gt;&gt;分析1</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：onMeasure（）</span></span><br><span class="line"><span class="comment">  * 作用：a. 根据View宽/高的测量规格计算View的宽/高值：getDefaultSize()</span></span><br><span class="line"><span class="comment">  *      b. 存储测量后的View宽 / 高：setMeasuredDimension()</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 参数说明：View的宽 / 高测量规格</span></span><br><span class="line"></span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),  </span><br><span class="line">                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));  </span><br><span class="line">    <span class="comment">// setMeasuredDimension() ：获得View宽/高的测量值 -&gt;&gt;分析2</span></span><br><span class="line">    <span class="comment">// 传入的参数通过getDefaultSize()获得 -&gt;&gt;分析3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：setMeasuredDimension()</span></span><br><span class="line"><span class="comment">  * 作用：存储测量后的View宽 / 高</span></span><br><span class="line"><span class="comment">  * 注：该方法即为我们重写onMeasure()所要实现的最终目的</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setMeasuredDimension</span><span class="params">(<span class="keyword">int</span> measuredWidth, <span class="keyword">int</span> measuredHeight)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数说明：测量后子View的宽 / 高值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将测量后子View的宽 / 高值进行传递</span></span><br><span class="line">            mMeasuredWidth = measuredWidth;  </span><br><span class="line">            mMeasuredHeight = measuredHeight;  </span><br><span class="line">          </span><br><span class="line">            mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;  </span><br><span class="line">        &#125; </span><br><span class="line">    <span class="comment">// 由于setMeasuredDimension（）的参数是从getDefaultSize()获得的</span></span><br><span class="line">    <span class="comment">// 下面我们继续看getDefaultSize()的介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：getDefaultSize()</span></span><br><span class="line"><span class="comment">  * 作用：根据View宽/高的测量规格计算View的宽/高值</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 参数说明：</span></span><br><span class="line">        <span class="comment">// size：提供的默认大小</span></span><br><span class="line">        <span class="comment">// measureSpec：宽/高的测量规格（含模式 &amp; 测量大小）</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置默认大小</span></span><br><span class="line">            <span class="keyword">int</span> result = size; </span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取宽/高测量规格的模式 &amp; 测量大小</span></span><br><span class="line">            <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);  </span><br><span class="line">            <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);  </span><br><span class="line">          </span><br><span class="line">            <span class="keyword">switch</span> (specMode) &#123;  </span><br><span class="line">                <span class="comment">// 模式为UNSPECIFIED时，使用提供的默认大小 = 参数Size</span></span><br><span class="line">                <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:  </span><br><span class="line">                    result = size;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 模式为AT_MOST,EXACTLY时，使用View测量后的宽/高值 = measureSpec中的Size</span></span><br><span class="line">                <span class="keyword">case</span> MeasureSpec.AT_MOST:  </span><br><span class="line">                <span class="keyword">case</span> MeasureSpec.EXACTLY:  </span><br><span class="line">                    result = specSize;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line"></span><br><span class="line">         <span class="comment">// 返回View的宽/高值</span></span><br><span class="line">            <span class="keyword">return</span> result;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ViewGroup的measure过程"><a href="#ViewGroup的measure过程" class="headerlink" title="ViewGroup的measure过程"></a>ViewGroup的measure过程</h3><ol>
<li>遍历 测量所有子View的尺寸</li>
<li>合并将所有子View的尺寸进行，最终得到ViewGroup父视图的测量值。即自上而下、一层层地传递下去，直到完成整个View树的measure（）过程。</li>
</ol>
<p><img src="https://upload-images.jianshu.io/upload_images/944365-7133935cb1e56190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/661/format/webp" alt=""><br>整个流程<br><img src="https://upload-images.jianshu.io/upload_images/944365-1438a7fbd93d0987.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/569/format/webp" alt=""></p>
<pre><code>1.即 单一View measure过程的onMeasure（）具有统一实现，而ViewGroup则没有
2.注：其实，在单一View measure过程中，getDefaultSize()只是简单的测量了宽高值，在实际使用时有时需更精细的测量。所以有时候也需重写onMeasure（）
</code></pre><p>在自定义ViewGroup中，关键在于：根据需求复写onMeasure()从而实现你的子View测量逻辑。复写onMeasure()的套路如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 根据自身的测量逻辑复写onMeasure（），分为3步</span></span><br><span class="line"><span class="comment">  * 1. 遍历所有子View &amp; 测量：measureChildren（）</span></span><br><span class="line"><span class="comment">  * 2. 合并所有子View的尺寸大小,最终得到ViewGroup父视图的测量值（自身实现）</span></span><br><span class="line"><span class="comment">  * 3. 存储测量后View宽/高的值：调用setMeasuredDimension()  </span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义存放测量后的View宽/高的变量</span></span><br><span class="line">        <span class="keyword">int</span> widthMeasure ;</span><br><span class="line">        <span class="keyword">int</span> heightMeasure ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 遍历所有子View &amp; 测量(measureChildren（）)</span></span><br><span class="line">        <span class="comment">// -&gt;&gt; 分析1</span></span><br><span class="line">        measureChildren(widthMeasureSpec, heightMeasureSpec)；</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 合并所有子View的尺寸大小，最终得到ViewGroup父视图的测量值</span></span><br><span class="line">         <span class="keyword">void</span> measureCarson&#123;</span><br><span class="line">             ... <span class="comment">// 自身实现</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 存储测量后View宽/高的值：调用setMeasuredDimension()  </span></span><br><span class="line">        <span class="comment">// 类似单一View的过程，此处不作过多描述</span></span><br><span class="line">        setMeasuredDimension(widthMeasure,  heightMeasure);  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 从上可看出：</span></span><br><span class="line">  <span class="comment">// 复写onMeasure（）有三步，其中2步直接调用系统方法</span></span><br><span class="line">  <span class="comment">// 需自身实现的功能实际仅为步骤2：合并所有子View的尺寸大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：measureChildren()</span></span><br><span class="line"><span class="comment">  * 作用：遍历子View &amp; 调用measureChild()进行下一步测量</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildren</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 参数说明：父视图的测量规格（MeasureSpec）</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> size = mChildrenCount;</span><br><span class="line">                <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有子view</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View child = children[i];</span><br><span class="line">                     <span class="comment">// 调用measureChild()进行下一步的测量 -&gt;&gt;分析1</span></span><br><span class="line">                    <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) &#123;</span><br><span class="line">                        measureChild(child, widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：measureChild()</span></span><br><span class="line"><span class="comment">  * 作用：a. 计算单个子View的MeasureSpec</span></span><br><span class="line"><span class="comment">  *      b. 测量每个子View最后的宽 / 高：调用子View的measure()</span></span><br><span class="line"><span class="comment">  **/</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChild</span><span class="params">(View child, <span class="keyword">int</span> parentWidthMeasureSpec,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> parentHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 获取子视图的布局参数</span></span><br><span class="line">        <span class="keyword">final</span> LayoutParams lp = child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 根据父视图的MeasureSpec &amp; 布局参数LayoutParams，计算单个子View的MeasureSpec</span></span><br><span class="line">        <span class="comment">// getChildMeasureSpec() 请看上面第2节储备知识处</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,<span class="comment">// 获取 ChildView 的 widthMeasureSpec</span></span><br><span class="line">                mPaddingLeft + mPaddingRight, lp.width);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,<span class="comment">// 获取 ChildView 的 heightMeasureSpec</span></span><br><span class="line">                mPaddingTop + mPaddingBottom, lp.height);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 将计算好的子View的MeasureSpec值传入measure()，进行最后的测量</span></span><br><span class="line">        <span class="comment">// 下面的流程即类似单一View的过程，此处不作过多描述</span></span><br><span class="line">        child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回到调用原处</span></span><br></pre></td></tr></table></figure><br>至此，ViewGroup的measure过程分析完毕。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>android studio常用快捷键</title>
    <url>/2014/10/12/android-studio-shortcutkey/</url>
    <content><![CDATA[<p>Eclipse中快捷键与Studio中的差别还是比较大，通过对比两者，让记忆更深刻。</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>显示快捷键列表：Ctrl+Shift+L (Eclipse)</p>
<table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">Eclipse</th>
<th style="text-align:right">Android studio</th>
</tr>
</thead>
<tbody>
<tr>
<td>打开资源</td>
<td style="text-align:center">Ctrl+Shift+R</td>
<td style="text-align:right">Ctrl+Shift+N</td>
</tr>
<tr>
<td>打开类型</td>
<td style="text-align:center">Ctrl+Shift+T</td>
<td style="text-align:right">Ctrl+N</td>
</tr>
<tr>
<td>导入包</td>
<td style="text-align:center">Ctrl+Shift+M</td>
<td style="text-align:right">Alt+回车</td>
</tr>
<tr>
<td>当前文件的结构</td>
<td style="text-align:center">Ctrl＋O</td>
<td style="text-align:right">Ctrl＋F12</td>
</tr>
<tr>
<td>格式化代码</td>
<td style="text-align:center">Ctrl+Shift+F</td>
<td style="text-align:right">Ctrl+Alt+L</td>
</tr>
<tr>
<td>组织导入</td>
<td style="text-align:center">Ctrl+Shift+O</td>
<td style="text-align:right">Ctrl+Alt+O</td>
</tr>
<tr>
<td>当前行往上或下移动</td>
<td style="text-align:center">Alt+方向键</td>
<td style="text-align:right">Ctrl+Shift+方向</td>
</tr>
<tr>
<td>生成getter setter方法</td>
<td style="text-align:center">Alt+Shift+s</td>
<td style="text-align:right">Alt＋Insert</td>
</tr>
<tr>
<td>重命名</td>
<td style="text-align:center">Alt+Shift+R</td>
<td style="text-align:right">Shift+F6</td>
</tr>
<tr>
<td>自动补全代码</td>
<td style="text-align:center">Alt+/</td>
<td style="text-align:right">Ctrl+Shift+Space(会与输入法切换有冲突)</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Ctrl+空格</td>
<td style="text-align:right">代码提示</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Ctrl+Alt+Space</td>
<td style="text-align:right">类名或接口提示</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Ctrl+P</td>
<td style="text-align:right">方法参数提示</td>
</tr>
<tr>
<td>行操作</td>
<td style="text-align:center">Ctrl+D 删除行</td>
<td style="text-align:right">Ctrl+X 删除行</td>
</tr>
<tr>
<td></td>
<td style="text-align:center"></td>
<td style="text-align:right">Ctrl+D 复制行</td>
</tr>
<tr>
<td>定位在某行</td>
<td style="text-align:center">Ctrl+L</td>
<td style="text-align:right"></td>
</tr>
<tr>
<td>返回上次位置</td>
<td style="text-align:center">Alt+ left/right</td>
<td style="text-align:right">Ctrl+Alt+ left/right</td>
</tr>
<tr>
<td>注释</td>
<td style="text-align:center">Ctrl+/</td>
<td style="text-align:right">Ctrl+/ 或 Ctrl+Shift+/</td>
</tr>
</tbody>
</table>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><table>
<thead>
<tr>
<th>功能</th>
<th style="text-align:center">Eclipse</th>
<th style="text-align:right">Android studio</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行程序</td>
<td style="text-align:center">Ctrl+F11</td>
<td style="text-align:right">Shift+F10运行当前，Alt+Shift+F10选择运行程序</td>
</tr>
<tr>
<td>单步跳入</td>
<td style="text-align:center">F5</td>
<td style="text-align:right">F7</td>
</tr>
<tr>
<td>单步执行</td>
<td style="text-align:center">F6</td>
<td style="text-align:right">F8</td>
</tr>
<tr>
<td>单步返回</td>
<td style="text-align:center">F7</td>
<td style="text-align:right">Shift+F8</td>
</tr>
<tr>
<td>继续</td>
<td style="text-align:center">F8</td>
<td style="text-align:right">F9</td>
</tr>
<tr>
<td>查看变量</td>
<td style="text-align:center">Shift+Ctrl+I</td>
<td style="text-align:right">Alt+F10</td>
</tr>
<tr>
<td>计算</td>
<td style="text-align:center"></td>
<td style="text-align:right">Alt+F8</td>
</tr>
</tbody>
</table>
<h2 id="Stuido特殊"><a href="#Stuido特殊" class="headerlink" title="Stuido特殊"></a>Stuido特殊</h2><p>Ctrl+Q 快速的查看的 类，函数的 文档问信息描述<br>Ctrl+P 方法参数提示<br>Alt+ left/right 切换代码视图<br>Alt+ Up/Down 在方法间快速移动定位<br>Alt+1 最大化当前的Edit或View (再按则反之)<br>Ctrl+E或者Alt+Shift+C 最近更改的代码</p>
<p>一些基本的快捷键，如果需要完整的快捷键，可以边学边深入。</p>
<p>转载请注明出处：<a href="https://blog.lovek.vip/2014/10/12/android-studio-shortcutkey/">https://blog.lovek.vip/2014/10/12/android-studio-shortcutkey/</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title>注解annotation</title>
    <url>/2020/08/30/annotation/</url>
    <content><![CDATA[<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>定义在类、方法、字段 、参数前的”注释“。注解（<code>annotation</code>）可以被编译器打包进class文件。</p>
<h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><p>有一些注解可以修饰其他注解，这些注解就称为元注解（<code>meta annotation</code>）。常用 元注解有@Retention、@ Target、@ Inherited、@ Documented</p>
<h6 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h6><p>RetentionPolicy的枚举，表示注解在何时生效：</p>
<ul>
<li>SOURCE 类型的注解在编译期就被丢掉了；如@Override。</li>
<li>CLASS 类型的注解仅保存在class文件中，它们不会被加载进JVM；如@Nullable。</li>
<li>RUNTIME  类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>如果@Retention不存在，则该Annotation默认为CLASS。因为如果我们自定义的Annotation都是RUNTIME，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解。</p>
<h6 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h6><p>标明了注解的适用范围，对应ElementType枚举。</p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code></li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<h6 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h6><p>注解所作用的类，在继承时默认无法继承父类的注解。除非注解声明了 @Inherited。同时Inherited声明出来的注，只对类有效，对方法／属性无效。并且仅针对<code>class</code>的继承，对<code>interface</code>的继承无效。</p>
<h6 id="Document"><a href="#Document" class="headerlink" title="@Document"></a>@Document</h6><p>注解标记的元素，Javadoc工具会将此注解标记元素的注解信息包含在javadoc中。默认，注解信息不会包含在Javadoc中。</p>
<h5 id="定义注解"><a href="#定义注解" class="headerlink" title="定义注解"></a>定义注解</h5><ol>
<li>public @interface 注解名 {方法参数}</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>添加参数、默认值：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadMode <span class="title">threadMode</span><span class="params">()</span> <span class="keyword">default</span> ThreadMode.POSTING</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>元注解配置注解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br></pre></td></tr></table></figure>
<h5 id="注解-in-kotlin"><a href="#注解-in-kotlin" class="headerlink" title="注解 in kotlin"></a>注解 in kotlin</h5><ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html" target="_blank" rel="noopener"><code>@Target</code></a> 指定可以用该注解标注的元素的可能的类型（类、函数、属性、表达式等）；</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-retention/index.html" target="_blank" rel="noopener"><code>@Retention</code></a> 指定该注解是否存储在编译后的 class 文件中，以及它在运行时能否通过反射可见 （默认都是 true）；</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/index.html" target="_blank" rel="noopener"><code>@Repeatable</code></a> 允许在单个元素上多次使用相同的该注解；</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-must-be-documented/index.html" target="_blank" rel="noopener"><code>@MustBeDocumented</code></a> 指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscribe</span></span>(<span class="keyword">val</span> threadMode: ThreadMode = ThreadMode.POSTING)</span><br></pre></td></tr></table></figure>
<h5 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h5><p>运行时注解<code>@Retention(RetentionPolicy.RUNTIME)</code>，大多数时候是在运行时使用反射来实现所需效果。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>X.isAnnotationPresent(Class)</code></li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>X.getAnnotation(Class)</code><br>例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> methods = clazz.javaClass.declaredMethods</span><br><span class="line"><span class="keyword">for</span> (method <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// 获取注解</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">annotation</span> = method.getAnnotation(Subscribe::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">annotation</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        invoke(<span class="keyword">annotation</span>, method, clazz, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h5><p>注解处理器（<code>annotation processor</code>）是javac的一个工具，它用来在编译时扫描和处理注解。你可以对自定义注解，并注册相应的注解处理器，用于处理你的注解逻辑。</p>
<p>创建<code>java or kotlin Library</code>， 实现一个自定义注解处理器(<code>AbstractProcessor</code>)，至少重写四个方法，并且注册你的自定义Processor。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(processingEnv: <span class="type">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(processingEnv)</span><br><span class="line">    <span class="comment">//element代表程序的元素，例如包、类、方法。</span></span><br><span class="line">    elementUtils = processingEnv.elementUtils</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> types = LinkedHashSet&lt;String&gt;()</span><br><span class="line">    types.add(Subscribe::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">canonicalName</span>)</span></span><br><span class="line">    <span class="keyword">return</span> types</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedSourceVersion</span><span class="params">()</span></span>: SourceVersion &#123;</span><br><span class="line">    <span class="keyword">return</span> SourceVersion.latestSupported()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    annotations: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    roundEnv: <span class="type">RoundEnvironment</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	<span class="comment">// 处理注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="注册Processor"><a href="#注册Processor" class="headerlink" title="注册Processor"></a>注册Processor</h6><p>AbstractProcessor实现之后不能直接使用，需要注册之后才能运行，有两种方式：</p>
<ol>
<li>手动注册</li>
</ol>
<p>在实现AbstractProcessor的项目中添加<code>resources/META-INF</code>文件夹，并在META-INF下添加一个名称为<code>javax.annotation.processing.Processor</code>的文本文件，在里面写入实现AbstractProcessor类的全名<em>vip.lovek.processor.EventBusProcessor</em></p>
<ol start="2">
<li>自动注册</li>
</ol>
<p>使用google提供的AutoService主动注册。在AbstractProcessor实现类上加上注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">// 导入依赖库</span></span><br><span class="line">annotationProcessor 'com.google.auto.service:auto-service:1.0-rc7'</span><br><span class="line">kapt <span class="string">'com.google.auto.service:auto-service:1.0-rc7'</span>  <span class="comment">// kotlin</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动注册方式在kotlin中有bug，如果不能自动生成，推荐手动注册。</p>
</blockquote>
<h6 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h6><p>AbstractProcessor中提供了生成代码的辅助类：Filer。 在ProcessingEnvironment中，生成代码就是一个创建文件写入文本内容的过程。生成java源码有很名的<a href="https://github.com/square/javapoet" target="_blank" rel="noopener">javapoet</a>框架，在kotlin中运行Processor时kapt来替代annotationProcessor， 也有<a href="https://github.com/square/kotlinpoet" target="_blank" rel="noopener">kotlinpoet</a>框架来代替javapoet。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> typeSpec = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">        .addFunction(</span><br><span class="line">            FunSpec.builder(<span class="string">"hello"</span>).addStatement(<span class="string">"println(%P)"</span>, <span class="string">"hello world"</span>).build()</span><br><span class="line">        )</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> mainFunction = FunSpec.builder(<span class="string">"main"</span>)</span><br><span class="line">        .addCode(</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">    |var total = 0</span></span><br><span class="line"><span class="string">    |for (i in 0 until 10) &#123;</span></span><br><span class="line"><span class="string">    |    total += i</span></span><br><span class="line"><span class="string">    |&#125;</span></span><br><span class="line"><span class="string">    |"""</span>.trimMargin()</span><br><span class="line">        )</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> file = FileSpec.builder(<span class="string">"vip.lovek.sharingan"</span>, <span class="string">"HelloWorld"</span>)</span><br><span class="line">        .addType(typeSpec)</span><br><span class="line">        .addFunction(mainFunction)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.writeTo(processingEnv.filer)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成代码内容为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> vip.lovek.sharingan</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"""hello world"""</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span>) &#123;</span><br><span class="line">      total += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title>注解 in kotlin</title>
    <url>/2020/09/01/annotation-kt/</url>
    <content><![CDATA[<h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p>定义在类、方法、字段 、参数前的”注释“。注解（<code>annotation</code>）可以被编译器打包进class文件。</p>
<h5 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h5><p>有一些注解可以修饰其他注解，这些注解就称为元注解（<code>meta annotation</code>）。常用 元注解有@Retention、@ Target、@ Repeatable、@ MustBeDocumented</p>
<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/index.html" target="_blank" rel="noopener"><code>@Target</code></a> 指定可以用该注解标注的元素的可能的类型（类、函数、属性、表达式等）；</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-retention/index.html" target="_blank" rel="noopener"><code>@Retention</code></a> 指定该注解是否存储在编译后的 class 文件中，以及它在运行时能否通过反射可见 （默认都是 true）；</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-repeatable/index.html" target="_blank" rel="noopener"><code>@Repeatable</code></a> 允许在单个元素上多次使用相同的该注解；</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-must-be-documented/index.html" target="_blank" rel="noopener"><code>@MustBeDocumented</code></a> 指定该注解是公有 API 的一部分，并且应该包含在生成的 API 文档中显示的类或方法的签名中。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(AnnotationRetention.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(AnnotationTarget.FUNCTION)</span></span><br><span class="line"><span class="keyword">annotation</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscribe</span></span>(<span class="keyword">val</span> threadMode: ThreadMode = ThreadMode.POSTING)</span><br></pre></td></tr></table></figure>
<h5 id="运行时注解"><a href="#运行时注解" class="headerlink" title="运行时注解"></a>运行时注解</h5><p>运行时注解<code>@Retention(AnnotationRetention.RUNTIME)</code>，大多数时候是在运行时使用反射来实现所需效果。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>X.isAnnotationPresent(Class)</code></li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>X.getAnnotation(Class)</code><br>例如：</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> methods = clazz.javaClass.declaredMethods</span><br><span class="line"><span class="keyword">for</span> (method <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    <span class="comment">// 获取注解</span></span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">annotation</span> = method.getAnnotation(Subscribe::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">annotation</span> != <span class="literal">null</span>) &#123;</span><br><span class="line">        invoke(<span class="keyword">annotation</span>, method, clazz, msg)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="编译时注解"><a href="#编译时注解" class="headerlink" title="编译时注解"></a>编译时注解</h5><p>注解处理器（<code>annotation processor</code>）是javac的一个工具，它用来在编译时扫描和处理注解。你可以对自定义注解，并注册相应的注解处理器，用于处理你的注解逻辑。</p>
<p>创建<code>java or kotlin Library</code>， 实现一个自定义注解处理器(<code>AbstractProcessor</code>)，至少重写四个方法，并且注册你的自定义Processor。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">init</span><span class="params">(processingEnv: <span class="type">ProcessingEnvironment</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(processingEnv)</span><br><span class="line">    <span class="comment">//element代表程序的元素，例如包、类、方法。</span></span><br><span class="line">    elementUtils = processingEnv.elementUtils</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span></span>: MutableSet&lt;String&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> types = LinkedHashSet&lt;String&gt;()</span><br><span class="line">    types.add(Subscribe::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">canonicalName</span>)</span></span><br><span class="line">    <span class="keyword">return</span> types</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getSupportedSourceVersion</span><span class="params">()</span></span>: SourceVersion &#123;</span><br><span class="line">    <span class="keyword">return</span> SourceVersion.latestSupported()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">process</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    annotations: <span class="type">MutableSet</span>&lt;<span class="type">out</span> <span class="type">TypeElement</span>&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">    roundEnv: <span class="type">RoundEnvironment</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">	<span class="comment">// 处理注解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="注册Processor"><a href="#注册Processor" class="headerlink" title="注册Processor"></a>注册Processor</h6><p>AbstractProcessor实现之后不能直接使用，需要注册之后才能运行，有两种方式：</p>
<ol>
<li>手动注册</li>
</ol>
<p>在实现AbstractProcessor的项目中添加<code>resources/META-INF</code>文件夹，并在META-INF下添加一个名称为<code>javax.annotation.processing.Processor</code>的文本文件，在里面写入实现AbstractProcessor类的全名<em>vip.lovek.processor.EventBusProcessor</em></p>
<ol start="2">
<li>自动注册</li>
</ol>
<p>使用google提供的AutoService主动注册。在AbstractProcessor实现类上加上注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">class EventBusProcessor : AbstractProcessor() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入依赖库</span></span><br><span class="line">kapt <span class="string">'com.google.auto.service:auto-service:1.0-rc7'</span>  <span class="comment">// kotlin</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>自动注册方式在kotlin中有bug，如果不能自动生成，推荐手动注册。</p>
</blockquote>
<h6 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h6><p>AbstractProcessor中提供了生成代码的辅助类：Filer。 在ProcessingEnvironment中，生成代码就是一个创建文件写入文本内容的过程。生成kotlin源码有很名的<a href="https://github.com/square/kotlinpoet" target="_blank" rel="noopener">kotlinpoet</a>框架。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> typeSpec = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">        .addFunction(</span><br><span class="line">            FunSpec.builder(<span class="string">"hello"</span>).addStatement(<span class="string">"println(%P)"</span>, <span class="string">"hello world"</span>).build()</span><br><span class="line">        )</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> mainFunction = FunSpec.builder(<span class="string">"main"</span>)</span><br><span class="line">        .addCode(</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">    |var total = 0</span></span><br><span class="line"><span class="string">    |for (i in 0 until 10) &#123;</span></span><br><span class="line"><span class="string">    |    total += i</span></span><br><span class="line"><span class="string">    |&#125;</span></span><br><span class="line"><span class="string">    |"""</span>.trimMargin()</span><br><span class="line">        )</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">val</span> file = FileSpec.builder(<span class="string">"vip.lovek.sharingan"</span>, <span class="string">"HelloWorld"</span>)</span><br><span class="line">        .addType(typeSpec)</span><br><span class="line">        .addFunction(mainFunction)</span><br><span class="line">        .build()</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        file.writeTo(processingEnv.filer)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成代码内容为：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> vip.lovek.sharingan</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">hello</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">"""hello world"""</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until <span class="number">10</span>) &#123;</span><br><span class="line">      total += i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>annotation kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>ButterKnife中注解</title>
    <url>/2020/09/07/annotation-bindview/</url>
    <content><![CDATA[<p><a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="noopener">ButterKnife</a> 是一款知名老牌 Android 开发框架，通过注解绑定视图，避免了 findViewById() 的操作，广受好评！由于它是在编译时对注解进行解析完成相关代码的生成，所以在项目编译时会略耗时，但不会影响运行时的性能。</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>在Activity中通过注解<code>@BindView</code>绑定视图，<code>@onClick</code>绑定事件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@BindView</span>(R.id.tv_title)</span><br><span class="line">    TextView title;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnClick</span>(R.id.bt)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        title.setText(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ButterKnife.bind(<span class="keyword">this</span>); <span class="comment">// 绑定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>ButterKnife和Activity是从<code>ButterKnife.bind(this)</code>建立绑定关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">   View sourceView = target.getWindow().getDecorView();</span><br><span class="line">   <span class="keyword">return</span> bind(target, sourceView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>根据 Class 得到一个继承了<code>Unbinder</code>的<code>Constructor</code>，最后通过反射<code>constructor.newInstance(target, source)</code>得到<code>Unbinder</code>子类的一个实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span> || BINDINGS.containsKey(cls)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in binding map."</span>);</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">"_ViewBinding"</span>);</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先检查<code>BINDINGS</code>是否存在 Class 对应的 Constructor，如果存在则直接返回，否则去构造对应的 Constructor。其中<code>BINDINGS</code>是一个<code>LinkedHashMap</code>： <code>Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;()</code>，缓存了对应的 Class 和 Constructor 以提高效率！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">"_ViewBinding"</span>);</span><br></pre></td></tr></table></figure>
<p>最终<code>bind()</code>方法返回的是<code>MainActivity_ViewBinding</code>类的实例。</p>
<p>MainActivity_ViewBinding类是在编译期由<strong>annotationProcessor</strong>生成的。文件内容如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_ViewBinding</span> <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MainActivity target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view213213213;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(MainActivity target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(target, target.getWindow().getDecorView());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> MainActivity target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    target.title = Utils.findRequiredViewAsType(source, R.id.tv_title, <span class="string">"field 'title'"</span>, TextView.class);</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.bt, <span class="string">"method 'onClick'"</span>);</span><br><span class="line">    view213213213 = view;</span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.onClick();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="meta">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MainActivity target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    target.title = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    view213213213.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view213213213 = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心还是利用<code>findViewById()</code>转成指定类型的 View，并完成事件绑定。</p>
<h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><p>注解处理器参考<a href="http://blog.lovek.vip/2020/09/01/annotation-kt/">注解annotation</a> 和 <a href="http://blog.lovek.vip/2020/09/01/annotation-kt/">注解 in kotlin。</a>在ButterKnife中使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RUNTIME) <span class="meta">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="meta">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#ButterKnifeProcessor 注解器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="meta">@IncrementalAnnotationProcessor</span>(IncrementalAnnotationProcessorType.DYNAMIC)</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"NullAway"</span>) <span class="comment">// TODO fix all these...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ButterKnifeProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO remove when http://b.android.com/187527 is released.</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPTION_SDK_INT = <span class="string">"butterknife.minSdk"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String OPTION_DEBUGGABLE = <span class="string">"butterknife.debuggable"</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> Id NO_ID = <span class="keyword">new</span> Id(NO_RES_ID);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String VIEW_TYPE = <span class="string">"android.view.View"</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVITY_TYPE = <span class="string">"android.app.Activity"</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> String DIALOG_TYPE = <span class="string">"android.app.Dialog"</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">      TypeElement typeElement = entry.getKey();</span><br><span class="line">      BindingSet binding = entry.getValue();</span><br><span class="line"></span><br><span class="line">      JavaFile javaFile = binding.brewJava(sdk, debuggable);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        javaFile.writeTo(filer);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>anotation</tag>
      </tags>
  </entry>
  <entry>
    <title>Retrofit初探</title>
    <url>/2016/04/20/retrofit-intro/</url>
    <content><![CDATA[<h3 id="Retrofit简介"><a href="#Retrofit简介" class="headerlink" title="Retrofit简介"></a>Retrofit简介</h3><p><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit</a>是一个类型安全的REST网络请求库(A type-safe HTTP client for Android and Java)。作者是大名鼎鼎的Square，已开源到<a href="https://github.com/square/retrofit" target="_blank" rel="noopener">github</a>。这个库为网络认证、API请求以及用OkHttp发送网络请求提供了强大的框架 。Retrofit直接支持RxJava，使得这个库被更多人去尝试。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h5 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h5><p>首先下载jar或者添加Gradle:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">compile 'com.squareup.retrofit2:retrofit:2.0.2'</span><br></pre></td></tr></table></figure></p>
<h5 id="初始化-Retrofit-类型"><a href="#初始化-Retrofit-类型" class="headerlink" title="初始化 - Retrofit 类型"></a>初始化 - Retrofit 类型</h5><p>现在，让我们来看一下Retrofit的类型是如何替代REST adapter类型的，以及如何初始化。下面是一个请求GitHub Api的例子：<br>1.创建Retrofit对象<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p>
<p>原来的方法叫做endpoint, 现在是baseUrl, baseUrl就是你所请求的Server的URL。  </p>
<p>2.声明请求接口<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  Call&lt;List&lt;Contributor&gt;&gt; repoContributors(</span><br><span class="line">      <span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</span><br><span class="line">      <span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</span><br><span class="line">&#125;</span><br><span class="line">GitHubService gitHubService = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure></p>
<p>当我们调用repoContributors这个方法的时候，Retrofit会创建这个URL。如果我们传入Square和Retrofit字符串，分别作为owner和repo参数。我们就会得到这个URL：<a href="https://api.github.com/repos/square/retrofit/contributors" target="_blank" rel="noopener">https://api.github.com/repos/square/retrofit/contributors</a>  </p>
<p>3.发送请求<br>Retrofit也支持同步和异步请求。分别调用execute()和enqueue()即可。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Call&lt;Repo&gt; call = service.loadRepo();</span><br><span class="line">Repo repo = call.execute();</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;Repo&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Response&lt;Repo&gt; response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Get result Repo from response.body()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable t)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由于现在Retrofit开始依赖 OkHttp，并没有Http Client层的抽象。现在是可以传递一个配置好的OkHttp实例的。比如：配置interceptors, 或者一个SSL socket工厂类，或者timeouts的具体数值。（OkHttp有默认的超时机制，如果你不需要自定义，实际上不必进行任何设置，但是如果你想要去设置它们，下面是一个例子告诉你来怎么操作。）<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">client.interceptors().add(..);</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .client(client)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p>
<p>如果你要指明特定的 converter 或者 execute 机制，也是在这个时候加的。比如这会儿：我们可以给 GSON 设置一个或者多个 converter。也可以给 protocol buffer 设置一个 converter。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(ProtoConverterFactory.create())</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p>
<p>如果你想要使用 RxJava 来代替 call, 你需要一个 Call Adapter Factory:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(ProtoConverterFactory.create())</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure></p>
<p>不要忘了添加依赖:<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">compile 'com.squareup.retrofit2:adapter-rxjava:2.0.0-beta3'</span><br><span class="line">compile 'com.squareup.retrofit2:converter-gson:2.0.0-beta3'</span><br></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">Retrofit官网</a></p>
<p><a href="https://realm.io/cn/news/droidcon-jake-wharton-simple-http-retrofit-2/" target="_blank" rel="noopener">用 Retrofit 2 简化 HTTP 请求</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>View绘制的layout过程</title>
    <url>/2018/12/16/android-view-layout/</url>
    <content><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>计算视图（View）的位置</p>
<pre><code>即计算View的四个顶点位置：Left、Top、Right 和 Bottom
</code></pre><h3 id="layout过程详解"><a href="#layout过程详解" class="headerlink" title="layout过程详解"></a>layout过程详解</h3><p>类似measure过程，layout过程根据View的类型分为2种情况：<br><img src="http://upload-images.jianshu.io/upload_images/944365-6e978f448667eb52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/590/format/webp" alt=""></p>
<p>layout过程的入口 = layout（），具体如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：layout（）</span></span><br><span class="line"><span class="comment">  * 作用：确定View本身的位置，即设置View本身的四个顶点位置</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前视图的四个顶点</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;  </span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;  </span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;  </span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 1. 确定View的位置：setFrame（） / setOpticalFrame（）</span></span><br><span class="line">    <span class="comment">// 即初始化四个顶点的值、判断当前View大小和位置是否发生了变化 &amp; 返回 </span></span><br><span class="line">    <span class="comment">// -&gt;&gt;分析1、分析2</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 若视图的大小 &amp; 位置发生变化</span></span><br><span class="line">    <span class="comment">// 会重新确定该View所有的子View在父容器的位置：onLayout（）</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;  </span><br><span class="line"></span><br><span class="line">        onLayout(changed, l, t, r, b);  </span><br><span class="line">        <span class="comment">// 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现-&gt;&gt;分析3</span></span><br><span class="line">        <span class="comment">// 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现（后面会详细说）</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：setFrame（）</span></span><br><span class="line"><span class="comment">  * 作用：根据传入的4个位置值，设置View本身的四个顶点位置</span></span><br><span class="line"><span class="comment">  * 即：最终确定View本身的位置</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// 通过以下赋值语句记录下了视图的位置信息，即确定View的四个顶点</span></span><br><span class="line">    <span class="comment">// 从而确定了视图的位置</span></span><br><span class="line">    mLeft = left;</span><br><span class="line">    mTop = top;</span><br><span class="line">    mRight = right;</span><br><span class="line">    mBottom = bottom;</span><br><span class="line"></span><br><span class="line">    mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：setOpticalFrame（）</span></span><br><span class="line"><span class="comment">  * 作用：根据传入的4个位置值，设置View本身的四个顶点位置</span></span><br><span class="line"><span class="comment">  * 即：最终确定View本身的位置</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">                ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line"></span><br><span class="line">        Insets childInsets = getOpticalInsets();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部实际上是调用setFrame（）</span></span><br><span class="line">        <span class="keyword">return</span> setFrame(</span><br><span class="line">                left   + parentInsets.left - childInsets.left,</span><br><span class="line">                top    + parentInsets.top  - childInsets.top,</span><br><span class="line">                right  + parentInsets.left + childInsets.right,</span><br><span class="line">                bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回到调用原处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：onLayout（）</span></span><br><span class="line"><span class="comment">  * 注：对于单一View的laytou过程</span></span><br><span class="line"><span class="comment">  *    a. 由于单一View是没有子View的，故onLayout（）是一个空实现</span></span><br><span class="line"><span class="comment">  *    b. 由于在layout（）中已经对自身View进行了位置计算，所以单一View的layout过程在layout（）</span></span><br><span class="line"><span class="comment">  *    后就已完成了</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 参数说明</span></span><br><span class="line">   <span class="comment">// changed 当前View的大小和位置改变了 </span></span><br><span class="line">   <span class="comment">// left 左部位置</span></span><br><span class="line">   <span class="comment">// top 顶部位置</span></span><br><span class="line">   <span class="comment">// right 右部位置</span></span><br><span class="line">   <span class="comment">// bottom 底部位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ViewGroup的layout过程"><a href="#ViewGroup的layout过程" class="headerlink" title="ViewGroup的layout过程"></a>ViewGroup的layout过程</h3><p>步骤：</p>
<pre><code>1. 计算自身ViewGroup的位置：layout（）
2. 遍历子View &amp; 确定自身子View在ViewGroup的位置（调用子View 的 layout（））：onLayout（）
</code></pre><h3 id="ViewGroup-layout"><a href="#ViewGroup-layout" class="headerlink" title="ViewGroup#layout"></a>ViewGroup#layout</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 源码分析：layout（）</span></span><br><span class="line"><span class="comment">  * 作用：确定View本身的位置，即设置View本身的四个顶点位置</span></span><br><span class="line"><span class="comment">  * 注：与单一View的layout（）源码一致</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前视图的四个顶点</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;  </span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;  </span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;  </span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 1. 确定View的位置：setFrame（） / setOpticalFrame（）</span></span><br><span class="line">    <span class="comment">// 即初始化四个顶点的值、判断当前View大小和位置是否发生了变化 &amp; 返回 </span></span><br><span class="line">    <span class="comment">// -&gt;&gt;分析1、分析2</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 若视图的大小 &amp; 位置发生变化</span></span><br><span class="line">    <span class="comment">// 会重新确定该View所有的子View在父容器的位置：onLayout（）</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;  </span><br><span class="line"></span><br><span class="line">        onLayout(changed, l, t, r, b);  </span><br><span class="line">        <span class="comment">// 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout（）是一个空实现（上面已分析完毕）</span></span><br><span class="line">        <span class="comment">// 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout（）在ViewGroup为1个抽象方法，需重写实现 -&gt;&gt;分析3</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析1：setFrame（）</span></span><br><span class="line"><span class="comment">  * 作用：确定View本身的位置，即设置View本身的四个顶点位置</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="comment">// 通过以下赋值语句记录下了视图的位置信息，即确定View的四个顶点</span></span><br><span class="line">    <span class="comment">// 从而确定了视图的位置</span></span><br><span class="line">    mLeft = left;</span><br><span class="line">    mTop = top;</span><br><span class="line">    mRight = right;</span><br><span class="line">    mBottom = bottom;</span><br><span class="line"></span><br><span class="line">    mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析2：setOpticalFrame（）</span></span><br><span class="line"><span class="comment">  * 作用：确定View本身的位置，即设置View本身的四个顶点位置</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">                ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line"></span><br><span class="line">        Insets childInsets = getOpticalInsets();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 内部实际上是调用setFrame（）</span></span><br><span class="line">        <span class="keyword">return</span> setFrame(</span><br><span class="line">                left   + parentInsets.left - childInsets.left,</span><br><span class="line">                top    + parentInsets.top  - childInsets.top,</span><br><span class="line">                right  + parentInsets.left + childInsets.right,</span><br><span class="line">                bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回到调用原处</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 分析3：onLayout（）</span></span><br><span class="line"><span class="comment">  * 作用：计算该ViewGroup包含所有的子View在父容器的位置（）</span></span><br><span class="line"><span class="comment">  * 注： </span></span><br><span class="line"><span class="comment">  *      a. 定义为抽象方法，需重写，因：子View的确定位置与具体布局有关，所以onLayout（）在ViewGroup没有实现</span></span><br><span class="line"><span class="comment">  *      b. 在自定义ViewGroup时必须复写onLayout（）！！！！！</span></span><br><span class="line"><span class="comment">  *      c. 复写原理：遍历子View 、计算当前子View的四个位置值 &amp; 确定自身子View的位置（调用子View layout（））</span></span><br><span class="line"><span class="comment">  */</span> </span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 参数说明</span></span><br><span class="line">     <span class="comment">// changed 当前View的大小和位置改变了 </span></span><br><span class="line">     <span class="comment">// left 左部位置</span></span><br><span class="line">     <span class="comment">// top 顶部位置</span></span><br><span class="line">     <span class="comment">// right 右部位置</span></span><br><span class="line">     <span class="comment">// bottom 底部位置</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 1. 遍历子View：循环所有子View</span></span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;getChildCount(); i++) &#123;</span><br><span class="line">              View child = getChildAt(i);   </span><br><span class="line"></span><br><span class="line">              <span class="comment">// 2. 计算当前子View的四个位置值</span></span><br><span class="line">                <span class="comment">// 2.1 位置的计算逻辑</span></span><br><span class="line">                ...<span class="comment">// 需自己实现，也是自定义View的关键</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2.2 对计算后的位置值进行赋值</span></span><br><span class="line">                <span class="keyword">int</span> mLeft  = Left</span><br><span class="line">                <span class="keyword">int</span> mTop  = Top</span><br><span class="line">                <span class="keyword">int</span> mRight = Right</span><br><span class="line">                <span class="keyword">int</span> mBottom = Bottom</span><br><span class="line"></span><br><span class="line">              <span class="comment">// 3. 根据上述4个位置的计算值，设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数</span></span><br><span class="line">              <span class="comment">// 即确定了子View在父容器的位置</span></span><br><span class="line">              child.layout(mLeft, mTop, mRight, mBottom);</span><br><span class="line">              <span class="comment">// 该过程类似于单一View的layout过程中的layout（）和onLayout（），此处不作过多描述</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>此处需注意：<br>ViewGroup 和 View 同样拥有layout（）和onLayout()，但二者不同的：</p>
<pre><code>一开始计算ViewGroup位置时，调用的是ViewGroup的layout（）和onLayout()；
当开始遍历子View &amp; 计算子View位置时，调用的是子View的layout（）和onLayout()
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/944365-6baebb31c56040dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/970/format/webp" alt=""></p>
<h4 id="细节问题：getWidth-（-getHeight-）与-getMeasuredWidth-（getMeasuredHeight-）获取的宽-（高）有什么区别？"><a href="#细节问题：getWidth-（-getHeight-）与-getMeasuredWidth-（getMeasuredHeight-）获取的宽-（高）有什么区别？" class="headerlink" title="细节问题：getWidth() （ getHeight()）与 getMeasuredWidth() （getMeasuredHeight()）获取的宽 （高）有什么区别？"></a>细节问题：getWidth() （ getHeight()）与 getMeasuredWidth() （getMeasuredHeight()）获取的宽 （高）有什么区别？</h4><p>首先明确定义：</p>
<pre><code>getWidth() / getHeight()：获得View最终的宽 / 高
getMeasuredWidth() / getMeasuredHeight()：获得 View测量的宽 / 高
</code></pre><p>先看下各自的源码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得View测量的宽 / 高</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredWidth</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> mMeasuredWidth &amp; MEASURED_SIZE_MASK;  </span><br><span class="line">      <span class="comment">// measure过程中返回的mMeasuredWidth</span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getMeasuredHeight</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> mMeasuredHeight &amp; MEASURED_SIZE_MASK;  </span><br><span class="line">      <span class="comment">// measure过程中返回的mMeasuredHeight</span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得View最终的宽 / 高</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> mRight - mLeft;  </span><br><span class="line">      <span class="comment">// View最终的宽 = 子View的右边界 - 子view的左边界。</span></span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHeight</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">      <span class="keyword">return</span> mBottom - mTop;  </span><br><span class="line">     <span class="comment">// View最终的高 = 子View的下边界 - 子view的上边界。</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>一般情况下，<code>二者获取的宽 / 高是相等的</code>。那么，“非一般”情况是什么？</p>
<p>答：人为设置：通过重写View的 layout（）强行设置<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">( <span class="keyword">int</span> l , <span class="keyword">int</span> t, <span class="keyword">int</span> r , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 改变传入的顶点位置参数</span></span><br><span class="line">   <span class="keyword">super</span>.layout(l，t，r+<span class="number">100</span>，b+<span class="number">100</span>)；</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如此一来，在任何情况下，getWidth() / getHeight()获得的宽/高 总比 getMeasuredWidth() / getMeasuredHeight()获取的宽/高大100px</span></span><br><span class="line">   <span class="comment">// 即：View的最终宽/高 总比 测量宽/高 大100px</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在非人为设置的情况下，View的最终宽/高（getWidth() / getHeight()）<br>与 View的测量宽/高 （getMeasuredWidth() /  getMeasuredHeight()）永远是相等</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Retrofit分析</title>
    <url>/2016/05/03/retrofit-intro2/</url>
    <content><![CDATA[<p>上篇<a href="https://blog.lovek.vip/2016/04/20/retrofit-intro/">Retrofit初探</a>中已初步使用了Retrofit，简单介绍了Retrofit的使用步骤。本篇继续深入分析一下Retrofit流程。</p>
<h3 id="Retrofit创建"><a href="#Retrofit创建" class="headerlink" title="Retrofit创建"></a>Retrofit创建</h3><p>先看一下Retrofit的创建<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(URL)</span><br><span class="line">    <span class="comment">//手动指定Fastjson解析方式,可指定不同Convert来使用如Gson，Jackson，XML等解析方式</span></span><br><span class="line">    .addConverterFactory(FastjsonConverterFactory.create())</span><br><span class="line">    <span class="comment">//返回数据为RxJava形式</span></span><br><span class="line">    .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><br>可以看出Retrofit对象是通过Builder来创建，构建器很方便我们设置Retrofit需要的属性。通过build()方法就创建了一个Retrofit对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line">  <span class="comment">// Make a defensive copy of the converters.</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">      callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果我们没有指定一个client或者callFactory，Retrofit2中默认生成一个OkHttpClient。然后通过platform.defaultCallbackExecutor()实例化一个Executor的对象callbackExecutor。Converter是数据转换器，该接口将Http请求返回的数据解析成Java对象，<br>addConverterFactory(FastjsonConverterFactory.create())添加一个FastjsonConverter来使用Fastjson来将我们的结果转化成Model类。CallAdapter是Call的适配器，负责将Call对象转化成另一个对象，同样在创建Retrofit实例时调用addCallAdapterFactory(Factory)来添加。<br>这样一个Retrofit的实例就创建完成了。其中platform是Builder进行初始化的时候调用了Platform.get()<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"><span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PLATFORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...省略部分代码...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用了单例的PLATFORM，通过findPlatform()初始化实例，如果是Android平台就实例化一个Android对象。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">Platform</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Executor <span class="title">defaultCallbackExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MainThreadExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span> </span><br><span class="line">  CallAdapter.<span class="function">Factory <span class="title">defaultCallAdapterFactory</span><span class="params">(Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallAdapterFactory(callbackExecutor);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MainThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">      <span class="meta">@Override</span> </span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">          handler.post(r);  <span class="comment">//提交到主线程,起到切换线程的作用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在Android平台中defaultCallbackExecutor()方法返回的是一个线程池，在execute()中执行绑定MainLooper的Handler提交Runnable到主线程。</p>
<h3 id="Retrofit请求的创建"><a href="#Retrofit请求的创建" class="headerlink" title="Retrofit请求的创建"></a>Retrofit请求的创建</h3><p>在Volley中描述一个HTTP请求是需要创建一个Request对象，然后把这个请求对象放到一个队列中，让网络线程去处理。那Retrofit是怎么做的呢？<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Api</span> </span>&#123;</span><br><span class="line">  <span class="meta">@GET</span>(<span class="string">"/repos/&#123;owner&#125;/&#123;repo&#125;/contributors"</span>)</span><br><span class="line">  Call&lt;List&lt;Contributor&gt;&gt; repoContributors(</span><br><span class="line">      <span class="meta">@Path</span>(<span class="string">"owner"</span>) String owner,</span><br><span class="line">      <span class="meta">@Path</span>(<span class="string">"repo"</span>) String repo);</span><br><span class="line">&#125;</span><br><span class="line">Api api = retrofit.create(Api.class);</span><br></pre></td></tr></table></figure><br>声明一个Api的接口，给Retrofit对象传了一个Api接口的Class对象，怎么又返回一个Api对象呢？进入create方法看一下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//对java8的兼容</span></span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>create(final Class<T> service)方法使用了 动态代理 来生成接口实现类。通过该函数，我们可以拿到一个前面自定义的Api的一个代理类，其功能就相当于一个Api对象，<br>即我们可以通它调用Api里的各个成员函数。其中最重要的三行代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>
<p>第一行 loadServiceMethod(method)：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    ServiceMethod result;</span><br><span class="line">    <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line">      result = serviceMethodCache.get(method);</span><br><span class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</span><br><span class="line">        serviceMethodCache.put(method, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>该方法会根据接口请求方法method来建造一个ServiceMethod，ServiceMethod是将一个接口方法适配成一个Http call。Retrofit会维护一个serviceMethodCache缓存，如果已经构建的ServiceMethod直接从缓存里取到并返回。<br>否则构建一个新的ServiceMethod对象，并放入缓存中。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    callAdapter = createCallAdapter();  <span class="comment">//这个CallAdapter就是 retrofit.callAdapter()</span></span><br><span class="line">    responseType = callAdapter.responseType();</span><br><span class="line">    <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">          + Utils.getRawType(responseType).getName()</span><br><span class="line">          + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    responseConverter = createResponseConverter();  <span class="comment">//retrofit.responseBodyConverter()</span></span><br><span class="line">    <span class="comment">//解析@GET @POST等注解</span></span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">      parseMethodAnnotation(annotation);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在构建ServiceMethod时，会调用createCallAdapter()来为ServiceMethod添加一个CallAdapter，此实例中这里的CallAdapter是默认的ExecutorCallAdapterFactory。<br>再回到invoke()最后一行，Retrofit默认实现是OkHttpCall。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure><br>通过CallAdapter适配后，动态代理返回的是ExecutorCallbackCall，一个真正实现了Call接口的实例。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ExecutorCallAdapterFactory.get()</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> CallAdapter&lt;Call&lt;?&gt;&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> responseType;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span> <span class="keyword">public</span> &lt;R&gt; <span class="function">Call&lt;R&gt; <span class="title">adapt</span><span class="params">(Call&lt;R&gt; call)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorCallbackCall</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Call</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Executor callbackExecutor;</span><br><span class="line">    <span class="keyword">final</span> Call&lt;T&gt; delegate;</span><br><span class="line"></span><br><span class="line">    ExecutorCallbackCall(Executor callbackExecutor, Call&lt;T&gt; delegate) &#123;</span><br><span class="line">      <span class="keyword">this</span>.callbackExecutor = callbackExecutor;</span><br><span class="line">      <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">final</span> Callback&lt;T&gt; callback)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (callback == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"callback == null"</span>);</span><br><span class="line"></span><br><span class="line">      delegate.enqueue(<span class="keyword">new</span> Callback&lt;T&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Response&lt;T&gt; response)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">if</span> (delegate.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// Emulate OkHttp's behavior of throwing/delivering an IOException on cancellation.</span></span><br><span class="line">                callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                callback.onResponse(ExecutorCallbackCall.<span class="keyword">this</span>, response);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;T&gt; call, <span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">          callbackExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              callback.onFailure(ExecutorCallbackCall.<span class="keyword">this</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>至此，就把一个接口方法转换成ExecutorCallbackCall对象，ExecutorCallbackCall中execute()和enqueue()分别是同步和异步请求。在异步请求中通过callbackExecutor实现了线程切换，把请求结果发送到主线程。</p>
<p>本篇通过一个请求实例，浅显的了解了Retrofit中一步步代码执行顺序，尽管没有对Retrofit各个类和方法深入探究，但通过此次分析，相信对Retrofit基本步骤已经有了更深刻的了解。文中如有错误希望大家指出～下面一张福利是Stay大神画的Retrofit流程图：<br><img src="/images/2016050301.png" alt="Retrofit流程图"></p>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-proxy1/" target="_blank" rel="noopener">Java 动态代理机制分析及扩展</a><br><a href="http://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="noopener">Retrofit分析-漂亮的解耦套路</a></p>
<p>转载请注明出处：<a href="https://blog.lovek.vip/2016/05/03/retrofit-intro2/">https://blog.lovek.vip/2016/05/03/retrofit-intro2</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>android神器Stetho调试Volley</title>
    <url>/2015/05/19/volley-stetho/</url>
    <content><![CDATA[<h3 id="Stetho简介"><a href="#Stetho简介" class="headerlink" title="Stetho简介"></a>Stetho简介</h3><p>Stetho 是 Facebook 开源的一个 Android 调试工具。是一个 Chrome Developer Tools 的扩展，可用来检测应用的网络、数据库、WebKit 等方面的功能。开发者也可通过它的 dumpapp 工具提供强大的命令行接口来访问应用内部。无需root查看sqlite文件、sharedpreference文件等等。更多详细介绍可以进入<a href="http://facebook.github.io/stetho/" target="_blank" rel="noopener">Stetho官网</a>。</p>
<h3 id="Stetho结合OkHttp使用"><a href="#Stetho结合OkHttp使用" class="headerlink" title="Stetho结合OkHttp使用"></a>Stetho结合OkHttp使用</h3><h5 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// Gradle dependency on Stetho </span><br><span class="line">  dependencies &#123; </span><br><span class="line">    compile 'com.facebook.stetho:stetho:1.1.1' </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-Stetho初始化配置"><a href="#2-Stetho初始化配置" class="headerlink" title="2.Stetho初始化配置"></a>2.Stetho初始化配置</h5><p>在App的Application中完成初始化。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    Stetho.initialize(</span><br><span class="line">      Stetho.newInitializerBuilder(<span class="keyword">this</span>)</span><br><span class="line">        .enableDumpapp(</span><br><span class="line">            Stetho.defaultDumperPluginsProvider(<span class="keyword">this</span>))</span><br><span class="line">        .enableWebKitInspector(</span><br><span class="line">            Stetho.defaultInspectorModulesProvider(<span class="keyword">this</span>))</span><br><span class="line">        .build());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>官网中使用OkHttp为实例，使用如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">client.networkInterceptors().add(<span class="keyword">new</span> StethoInterceptor());</span><br></pre></td></tr></table></figure><br>然后就可以运行App进行调试，基本上可以满足调试需求了。</p>
<h3 id="Stetho结合Volley使用"><a href="#Stetho结合Volley使用" class="headerlink" title="Stetho结合Volley使用"></a>Stetho结合Volley使用</h3><p>官网中Stetho是结合OkHttp的使用，如果项目中使用Volley做为网络请求框架，可以做如下修改。还是使用OkHttp做为Volley中HttpStack的实现，我们知道，Volley中网络请求在Android2.3及以上基于HttpURLConnection，2.3以下基于HttpClient实现，通过增加HttpStack的具体实现即可。这里使用<a href="https://gist.github.com/bryanstern/4e8f1cb5a8e14c202750" target="_blank" rel="noopener">Bryan Stern分享的代码</a>。（网页可能被墙，可以通过VPN访问。需要VPN的可以<a href="http://reftizi.com/?r=bf31aecac9700bac" target="_blank" rel="noopener">点击这里</a>）</p>
<h5 id="1-添加依赖-1"><a href="#1-添加依赖-1" class="headerlink" title="1.添加依赖"></a>1.添加依赖</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">compile 'com.facebook.stetho:stetho:1.1.1'</span><br><span class="line">compile 'com.facebook.stetho:stetho-okhttp:1.1.1'</span><br><span class="line">compile 'com.squareup.okhttp:okhttp:2.3.0'</span><br></pre></td></tr></table></figure>
<h5 id="2-Stetho初始化配置-1"><a href="#2-Stetho初始化配置-1" class="headerlink" title="2.Stetho初始化配置"></a>2.Stetho初始化配置</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">client.networkInterceptors().add(<span class="keyword">new</span> StethoInterceptor());</span><br><span class="line">mRequestQueue = Volley.newRequestQueue(getApplicationContext(), <span class="keyword">new</span> OkHttpStack(client));</span><br></pre></td></tr></table></figure>
<p>好了，基本上这样就能使用Stetho神器调试你的App了，感觉到强大了么~。</p>
<h3 id="补充：使用中遇到的坑"><a href="#补充：使用中遇到的坑" class="headerlink" title="补充：使用中遇到的坑"></a>补充：使用中遇到的坑</h3><ul>
<li><p>Stetho inspect窗口空白 </p>
<p>如果出现调试窗口空白，先升级下Chrome吧。升级最新版后再试一下（我被这个坑了）。</p>
</li>
<li><p>Stetho inspect窗口还是空白 </p>
<p>如果Chrome是最新版，无论如何刷新都是空白，那么恭喜你你可能被墙了~用VPN试试吧 <a href="!http://reftizi.com/?r=bf31aecac9700bac">可以戳这里哦</a></p>
</li>
</ul>
<h3 id="我的测试代码和效果图如下："><a href="#我的测试代码和效果图如下：" class="headerlink" title="我的测试代码和效果图如下："></a>我的测试代码和效果图如下：</h3><p>自定义Application类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppliation</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>.onCreate();</span><br><span class="line">		context = getApplicationContext();</span><br><span class="line">		instance = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		Stetho.initialize(</span><br><span class="line">				Stetho.newInitializerBuilder(<span class="keyword">this</span>)</span><br><span class="line">						.enableDumpapp(Stetho.defaultDumperPluginsProvider(<span class="keyword">this</span>))</span><br><span class="line">						.enableWebKitInspector(Stetho.defaultInspectorModulesProvider(<span class="keyword">this</span>))</span><br><span class="line">						.build());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The Volley Request queue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RequestQueue <span class="title">getRequestQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// lazy initialize the request queue, the queue instance will be</span></span><br><span class="line">		<span class="comment">// created when it is accessed for the first time</span></span><br><span class="line">		<span class="keyword">synchronized</span> (App.class) &#123;</span><br><span class="line">			<span class="keyword">if</span> (mRequestQueue == <span class="keyword">null</span>) &#123;</span><br><span class="line">				OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">				client.networkInterceptors().add(<span class="keyword">new</span> StethoInterceptor());</span><br><span class="line">				mRequestQueue = Volley.newRequestQueue(getApplicationContext(), <span class="keyword">new</span> OkHttpStack(client));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> mRequestQueue;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Activity类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.layout_main);</span><br><span class="line">        tv = (TextView)findViewById(R.id.tv);</span><br><span class="line"></span><br><span class="line">        RequestQueue queue = App.getInstance().getRequestQueue();</span><br><span class="line">        String url = <span class="string">"https://publicobject.com/helloworld.txt"</span>;</span><br><span class="line">        StringRequest request = <span class="keyword">new</span> StringRequest(Request.Method.GET, url, <span class="keyword">new</span> Response.Listener&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                LogUtil.d(s);</span><br><span class="line">                tv.setText(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> com.android.volley.Response.ErrorListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">                LogUtil.e(volleyError.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        queue.add(request);</span><br><span class="line"></span><br><span class="line">        SharedPrfUtil.setInt(<span class="string">"uid"</span>,<span class="number">669</span>);</span><br><span class="line">        SharedPrfUtil.setString(<span class="string">"username"</span>,<span class="string">"dongye"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现效果如下图：</p>
<p><img src="http://dongyeforever.qiniudn.com/stetho-all.png" alt="Stetho调试效果图"></p>
<p><img src="http://dongyeforever.qiniudn.com/stetho-inspect.png" alt="调试程序列表"></p>
<p><img src="http://dongyeforever.qiniudn.com/inspect-network.png" alt="调试网络请求"></p>
<p><img src="http://dongyeforever.qiniudn.com/inspect-sharedpreference.png" alt="读取数据存储"></p>
<p>转载请注明出处：<a href="https://blog.lovek.vip/2015/05/19/volley-stetho/">https://blog.lovek.vip/2015/05/19/volley-stetho</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>stetho</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio查看源码</title>
    <url>/2016/10/11/android-source/</url>
    <content><![CDATA[<p>使用Ubuntu(最近换了deepin，本地化做的很好)+Android studio开发Android一年多了，看源码的时候，一直怀念Windows下的source insight。后来发现原来Android提供了eclipse和idea等工具进行阅读的方法。<br>只需要执行如下命令：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">./development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure>
<p>这行命令的意思是在根目录生成对应的android.ipr、android.iml的工程配置文件。</p>
<p>可能会出现如下错误<br><img src="/images/2016101201.png" alt=""><br>解决办法是，下载idegen.jar复制到指定目录。重新执行命令即可。成功结果如下：<br><img src="/images/2016101202.png" alt=""></p>
<p>在android studio选择打开android.ipr，稍等一会就可查看源码了。<br><img src="/images/2016101203.png" alt=""><br>大功告成！看下效果<br><img src="/images/2016101204.png" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title>android studio添加.so文件</title>
    <url>/2014/10/12/android-studio-so/</url>
    <content><![CDATA[<p>设置build.gradle文件：</p>
<p>在配置的android节点下加入下面的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceSets &#123;  </span><br><span class="line">    main &#123;  </span><br><span class="line">        jniLibs.srcDirs = [<span class="string">'libs'</span>]  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者在源码main子目录下建jniLibs目录，把libs下的so库按目录结构丢进去，如下图:</p>
<p><img src="/images/2014101201.png" alt=""></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>Dart入门二</title>
    <url>/2019/12/08/dart/dart-learn02/</url>
    <content><![CDATA[<h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1.函数"></a>1.函数</h3><p>Dart 是一门真正面向对象的语言， 甚至其中的函数也是对象，并且有它的类型 <code>Function</code> 。 这也意味着函数可以被赋值给变量或者作为参数传递给其他函数。 也可以把 Dart 类的实例当做方法来调用。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> sum(<span class="built_in">num</span> num1, <span class="built_in">num</span> num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果函数中只有一句表达式，可以使用简写语法：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">sum(num1, num2) =&gt; num1 + num2;</span><br></pre></td></tr></table></figure><br><code>=&gt; expr</code> 语法是 <code>{ return expr; }</code> 的简写。 =&gt; 符号 有时也被称为 箭头 语法。</p>
<blockquote>
<p>提示： 在箭头 (=&gt;) 和分号 (;) 之间只能使用一个 表达式 ，不能是 语句 。 例如：不能使用 if 语句 ，但是可以是用 条件表达式.</p>
</blockquote>
<p>函数有两种参数类型: required 和 optional。 required 类型参数在参数最前面， 随后是 optional 类型参数。 命名的可选参数也可以标记为 “@ required”。</p>
<h5 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h5><p>可选参数可以是命名参数或者位置参数，但一个参数只能选择其中一种方式修饰。可选参数可以分为 <code>命名可选参数</code> 和 <code>位置可选参数</code><br>定义方式:<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">命名可选参数: &#123;param1, param2, ...&#125;</span><br><span class="line">位置可选参数: [param1, param2, ...]</span><br></pre></td></tr></table></figure></p>
<h6 id="命名可选参数"><a href="#命名可选参数" class="headerlink" title="命名可选参数"></a>命名可选参数</h6><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名可选参数</span></span><br><span class="line">printInfo(<span class="built_in">String</span> name, &#123;<span class="built_in">int</span> age, <span class="built_in">double</span> height&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'name=<span class="subst">$name</span> age=<span class="subst">$age</span> height=<span class="subst">$height</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数时，可以使用指定命名参数 paramName: value</span></span><br><span class="line">printInfo(<span class="string">'Bob'</span>); <span class="comment">// name=Bob age=null height=null</span></span><br><span class="line">printInfo(<span class="string">'Bob'</span>, age: <span class="number">18</span>); <span class="comment">// name=Bob age=18 height=null</span></span><br><span class="line">printInfo(<span class="string">'Bob'</span>, age: <span class="number">18</span>, height: <span class="number">1.88</span>); <span class="comment">// name=Bob age=18 height=1.88</span></span><br><span class="line">printInfo(<span class="string">'Bob'</span>, height: <span class="number">1.88</span>); <span class="comment">// name=Bob age=null height=1.88</span></span><br></pre></td></tr></table></figure>
<p><code>Flutter</code> 创建实例的表达式可能很复杂， 因此窗口小部件构造函数仅使用命名参数。 这样创建实例的表达式更易于阅读。<br>使用 <code>@required</code> 注释表示参数是 required 性质的命名参数， 该方式可以在任何 Dart 代码中使用（不仅仅是Flutter）。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Scrollbar(&#123;Key key, <span class="meta">@required</span> Widget child&#125;)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>Required 被定义在 meta package。 无论是直接引入（import） package:meta/meta.dart ，或者引入了其他 package，而这个 package 输出（export）了 meta，比如 Flutter 的 package:flutter/material.dart。</p>
</blockquote>
<h5 id="位置可选参数"><a href="#位置可选参数" class="headerlink" title="位置可选参数"></a>位置可选参数</h5><p>将参数放到 [] 中来标记参数是可选的：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h5><p>在定义方法的时候，可以使用 = 来定义可选参数的默认值。 默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。</p>
<p>下面是设置可选参数默认值示例：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置 [bold] 和 [hidden] 标志 ...</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold 值为 true; hidden 值为 false.</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><br>list 或 map 可以作为默认值传递。 下面的示例定义了一个方法 doStuff()， 并分别指定参数 list 和 gifts 的默认值。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> doStuff(</span><br><span class="line">    &#123;<span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">    <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt; gifts = <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="string">'first'</span>: <span class="string">'paper'</span>,</span><br><span class="line">      <span class="string">'second'</span>: <span class="string">'cotton'</span>,</span><br><span class="line">      <span class="string">'third'</span>: <span class="string">'leather'</span></span><br><span class="line">    &#125;&#125;) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'list:  <span class="subst">$list</span>'</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'gifts: <span class="subst">$gifts</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="函数是一等对象"><a href="#函数是一等对象" class="headerlink" title="函数是一等对象"></a>函数是一等对象</h5><p>一个函数可以作为另一个函数的参数。同样可以将一个函数赋值给一个变量。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> printElement(<span class="built_in">int</span> element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// 将 printElement 函数作为参数传递。</span></span><br><span class="line">list.forEach(printElement);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">'!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!'</span>;</span><br><span class="line"><span class="keyword">assert</span>(loudify(<span class="string">'hello'</span>) == <span class="string">'!!! HELLO !!!'</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h5><p>多数函数是有名字的， 比如 main() 和 printElement()。 也可以创建没有名字的函数，这种函数被称为 匿名函数， 有时候也被称为 lambda 或者 closure 。 匿名函数可以赋值到一个变量中， 举个例子，在一个集合中可以添加或者删除一个匿名函数。<br>匿名函数和命名函数看起来类似— 在括号之间可以定义一些参数或可选参数，参数使用逗号分割。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">([[<span class="built_in">Type</span>] param1[, …]]) &#123;</span><br><span class="line">  codeBlock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>下面例子中定义了一个包含一个无类型参数 item 的匿名函数。 list 中的每个元素都会调用这个函数，打印元素位置和值的字符串。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'apples'</span>, <span class="string">'bananas'</span>, <span class="string">'oranges'</span>];</span><br><span class="line">list.forEach((item) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>如果函数只有一条语句， 可以使用箭头简写。粘贴下面代码到 DartPad 中 并点击运行按钮，验证两个函数是等价性。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">list.forEach(</span><br><span class="line">    (item) =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;list.indexOf(item)&#125;</span>: <span class="subst">$item</span>'</span>));</span><br></pre></td></tr></table></figure></p>
<h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>闭包 即一个函数对象，即使函数对象的调用在它原始作用域之外， 依然能够访问在它词法作用域内的变量。</p>
<p>函数可以封闭定义到它作用域内的变量。 接下来的示例中， makeAdder() 捕获了变量 addBy。 无论在什么时候执行返回函数，函数都会使用捕获的 addBy 变量。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/// 返回一个函数，返回的函数参数与 [addBy] 相加。</span></span></span><br><span class="line"><span class="built_in">Function</span> makeAdder(<span class="built_in">num</span> addBy) &#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">num</span> i) =&gt; addBy + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="comment">// 创建一个加 2 的函数。</span></span><br><span class="line">  <span class="keyword">var</span> add2 = makeAdder(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个加 4 的函数。</span></span><br><span class="line">  <span class="keyword">var</span> add4 = makeAdder(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">assert</span>(add2(<span class="number">3</span>) == <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">assert</span>(add4(<span class="number">3</span>) == <span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>闭包在 Dart 的 for 循环中会捕获循环的 index 索引值， 来避免 JavaScript 中常见的陷阱。 请思考示例代码：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">  callbacks.add(() =&gt; <span class="built_in">print</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">callbacks.forEach((c) =&gt; c());</span><br></pre></td></tr></table></figure><br>和期望一样，输出的是 0 和 1。 但是示例中的代码在 JavaScript 中会连续输出两个 2 。</p>
<h3 id="2-switch和case"><a href="#2-switch和case" class="headerlink" title="2.switch和case"></a>2.switch和case</h3><p>在 Dart 中 switch 语句使用 == 比较整数，字符串，或者编译时常量。 比较的对象必须都是同一个类的实例（并且不可以是子类）， 类必须没有对 == 重写。 枚举类型 可以用于 switch 语句。<br>在 case 语句中，每个非空的 case 语句结尾需要跟一个 break 语句。 除 break 以外，还有可以使用 continue, throw，者 return。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'OPEN'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'OPEN'</span>:</span><br><span class="line">    executeOpen();</span><br><span class="line">    <span class="comment">// ERROR: 丢失 break</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>:</span><br><span class="line">    executeClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>case 程序示例中缺省了 break 语句，导致错误。<br>但是， Dart 支持空 case 语句， 允许程序以 fall-through 的形式执行。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> command = <span class="string">'CLOSED'</span>;</span><br><span class="line"><span class="keyword">switch</span> (command) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'CLOSED'</span>: <span class="comment">// Empty case falls through.</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'NOW_CLOSED'</span>:</span><br><span class="line">    <span class="comment">// Runs for both CLOSED and NOW_CLOSED.</span></span><br><span class="line">    executeNowClosed();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-异常"><a href="#3-异常" class="headerlink" title="3.异常"></a>3.异常</h3><p>Dart 代码可以抛出和捕获异常。 异常表示一些未知的错误情况。 如果异常没有被捕获， 则异常会抛出， 导致抛出异常的代码终止执行。</p>
<p>和 Java 有所不同， Dart 中的所有异常是非检查异常。 方法不会声明它们抛出的异常， 也不要求捕获任何异常。<br>Dart 提供了 <code>Exception</code> 和 <code>Error</code> 类型， 以及一些子类型。 当然也可以定义自己的异常类型。 但是，此外 Dart 程序可以抛出任何非 null 对象， 不仅限 Exception 和 Error 对象。</p>
<h5 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h5><p>下面是关于抛出或者 引发 异常的示例：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> FormatException(<span class="string">'Expected at least 1 section'</span>);</span><br></pre></td></tr></table></figure><br>也可以抛出任意的对象：(不建议)<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="string">'Out of llamas!'</span>;</span><br></pre></td></tr></table></figure></p>
<h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5><p>捕获异常可以避免异常继续传递（除非重新抛出（ rethrow ）异常）。 可以通过捕获异常的机会来处理该异常：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  breedMoreLlamas();</span><br><span class="line">&#125; on OutOfLlamasException &#123;</span><br><span class="line">  <span class="comment">// 一个特殊的异常</span></span><br><span class="line">  buyMoreLlamas();</span><br><span class="line">&#125; on Exception <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 其他任何异常</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Unknown exception: <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// 没有指定的类型，处理所有异常</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Something really unknown: <span class="subst">$e</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>捕获语句中可以同时使用 <code>on</code> 和 <code>catch</code> ，也可以单独分开使用。 使用 on 来指定异常类型， 使用 catch 来 捕获异常对象。<br>如果仅需要部分处理异常， 那么可以使用关键字 <code>rethrow</code> 将异常重新抛出。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> misbehave() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">dynamic</span> foo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="built_in">print</span>(foo++); <span class="comment">// Runtime error</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'misbehave() partially handled <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">    <span class="keyword">rethrow</span>; <span class="comment">// Allow callers to see the exception.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    misbehave();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'main() finished handling <span class="subst">$&#123;e.runtimeType&#125;</span>.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>搬瓦工shadowsocks安装配置</title>
    <url>/2017/01/02/server/bandwagonhost/</url>
    <content><![CDATA[<h3 id="一键安装："><a href="#一键安装：" class="headerlink" title="一键安装："></a>一键安装：</h3><p>虽然最新搬瓦工控制面板里去掉了一键安装选项，但是可以通过以下链接一键安装：<br><a href="https://kiwivm.64clouds.com/main-exec.php?mode=extras_shadowsocks" target="_blank" rel="noopener">shadowsocks</a><br><a href="https://kiwivm.64clouds.com/main-exec.php?mode=extras_shadowsocksr" target="_blank" rel="noopener">shadowsocksr</a></p>
<h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><h4 id="1-登录服务器"><a href="#1-登录服务器" class="headerlink" title="1.登录服务器"></a>1.登录服务器</h4><p>ssh -p 21 <a href="mailto:root@104.224.132.44">root@104.224.132.44</a></p>
<h4 id="2-安装shadowsocks"><a href="#2-安装shadowsocks" class="headerlink" title="2.安装shadowsocks"></a>2.安装shadowsocks</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update</span><br><span class="line">yum install gcc</span><br><span class="line">yum install wget</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;python.org&#x2F;ftp&#x2F;python&#x2F;2.7.3&#x2F;Python-2.7.3.tar.bz2</span><br><span class="line">tar -jxvf Python-2.7.3.tar.bz2 </span><br><span class="line">cd Python-2.7.3</span><br><span class="line">.&#x2F;configure</span><br><span class="line">make all</span><br><span class="line">make install</span><br><span class="line">mv &#x2F;usr&#x2F;bin&#x2F;python &#x2F;usr&#x2F;bin&#x2F;python2.6.6</span><br><span class="line">ln -s &#x2F;usr&#x2F;local&#x2F;bin&#x2F;python2.7 &#x2F;usr&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure>
<p>yum不支持Python 2.7，所以，按下面的操作，指定yum的python版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;usr&#x2F;bin&#x2F;yum</span><br></pre></td></tr></table></figure><br>将文件头部的<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python</span><br></pre></td></tr></table></figure><br>改成<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;python2.6.6</span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;pypi.python.org&#x2F;packages&#x2F;source&#x2F;p&#x2F;pip&#x2F;pip-6.0.8.tar.gz#md5&#x3D;2332e6f97e75ded3bddde0ced01dbda3  --no-check-certificate</span><br><span class="line">easy_install pip-6.0.8.tar.gz</span><br></pre></td></tr></table></figure></p>
<h4 id="3-配置shadowsocks"><a href="#3-配置shadowsocks" class="headerlink" title="3.配置shadowsocks"></a>3.配置shadowsocks</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">&#123; </span><br><span class="line">&quot;server&quot;:&quot;104.224.132.44&quot;, </span><br><span class="line">&quot;server_port&quot;:110, </span><br><span class="line">&quot;local_address&quot;: &quot;127.0.0.1&quot;, </span><br><span class="line">&quot;local_port&quot;:1080, </span><br><span class="line">&quot;password&quot;:&quot;password&quot;, </span><br><span class="line">&quot;timeout&quot;:600, </span><br><span class="line">&quot;method&quot;:&quot;rc4-md5&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="配置开机自动启动"><a href="#配置开机自动启动" class="headerlink" title="配置开机自动启动"></a>配置开机自动启动</h4><p>打开rc.local文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi &#x2F;etc&#x2F;rc.local</span><br></pre></td></tr></table></figure><br>输入下面的代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start</span><br><span class="line">shadowsocks服务相关命令</span><br><span class="line">启动shadowsocks服务</span><br><span class="line"></span><br><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d start</span><br><span class="line">关闭shadowsocks服务</span><br><span class="line"></span><br><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d stop</span><br><span class="line">重启shadowsocks服务</span><br><span class="line"></span><br><span class="line">ssserver -c &#x2F;etc&#x2F;shadowsocks.json -d restart</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>git 知识点</title>
    <url>/2021/02/22/server/git%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h4 id="git-基础"><a href="#git-基础" class="headerlink" title="git 基础"></a>git 基础</h4><h5 id="中央仓库"><a href="#中央仓库" class="headerlink" title="中央仓库"></a>中央仓库</h5><p><img src="https://user-gold-cdn.xitu.io/2017/11/30/1600a9978ea4bec3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="中央仓库"></p>
<h5 id="分布式VCS"><a href="#分布式VCS" class="headerlink" title="分布式VCS"></a>分布式VCS</h5><p>分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每一个成员的机器上都有一份本地仓库。<br><a id="more"></a><br><img src="https://user-gold-cdn.xitu.io/2017/11/30/1600a9a4a20c2e6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h5 id="git-简单命令"><a href="#git-简单命令" class="headerlink" title="git 简单命令"></a>git 简单命令</h5><p>git 练手仓库：<a href="https://github.com/dongyeforever/ihappy.git" target="_blank" rel="noopener">github 仓库</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git 简单指令汇总</span><br><span class="line">git clone</span><br><span class="line">git log</span><br><span class="line">git status</span><br><span class="line">git diff</span><br><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>
<ul>
<li>把远程仓库取到本地</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/dongyeforever/ihappy.git</span><br></pre></td></tr></table></figure>
<p>查看本地目录，这个 <code>.git</code> 目录，就是你的<strong>本地仓库（Local Repository）</strong>，你的所有版本信息都会存在这里。而 <code>.git</code> 所在的这个根目录，称为 Git 的<strong>工作目录（Working Directory）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  ihappy git:(main) l</span><br><span class="line">total 40</span><br><span class="line">drwxr-xr-x   6 yu  staff   192B  2 19 17:45 .</span><br><span class="line">drwxr-xr-x   5 yu  staff   160B  2 19 17:45 ..</span><br><span class="line">drwxr-xr-x  12 yu  staff   384B  2 19 17:45 .git</span><br><span class="line">-rw-r--r--   1 yu  staff   278B  2 19 17:45 .gitignore</span><br><span class="line">-rw-r--r--   1 yu  staff    11K  2 19 17:45 LICENSE</span><br><span class="line">-rw-r--r--   1 yu  staff    26B  2 19 17:45 README.md</span><br></pre></td></tr></table></figure>
<ul>
<li>查看提交记录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">commit 03dcf7490765baf0394d518a3c6b642e9c5f88b2 (HEAD -&gt; main, origin/main, origin/HEAD)</span><br><span class="line">Author: dongyeforever</span><br><span class="line">Date:   Fri Feb 19 17:40:10 2021 +0800</span><br><span class="line"></span><br><span class="line">    Initial commit</span><br><span class="line">(END)</span><br></pre></td></tr></table></figure>
<ul>
<li>查看工作目录当前状态</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加到本地仓库</p>
<p>文件添加前红色，添加后变成绿色。文件的状态从 “untracked”（未跟踪）变成了 “staged”（已暂存）。所谓的 staging area，是 <code>.git</code> 目录下一个叫做 <code>index</code> 的文件。你通过 <code>add</code> 指令暂存的内容，都会被写进这个文件里。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure>
<ul>
<li><p>提交到本地仓库</p>
<p>将暂存区里的改动给提交到本地的版本库。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit</span><br><span class="line">git commit -m "修改内容"</span><br></pre></td></tr></table></figure>
<ul>
<li><p>提交远程仓库</p>
<p>多人并行开发时 git push 发生冲突，中央仓库已经被其他同事先一步 <code>push</code> 了的情况。先用 git pull  把远端仓库上的新内容取回到本地和本地合并，然后再把合并后的本地仓库向远端仓库推送。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<h5 id="gitignore-文件"><a href="#gitignore-文件" class="headerlink" title=".gitignore 文件"></a>.gitignore 文件</h5><p>忽略不想被管理的文件或目录。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">*.<span class="keyword">class</span></span><br><span class="line">bin<span class="regexp">/</span></span><br><span class="line"><span class="regexp">build/</span></span><br><span class="line">local.properties</span><br></pre></td></tr></table></figure>
<p>如果没有添加到 .gitignore 文件已经被添加到暂存区了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm --cached filename</span><br></pre></td></tr></table></figure>
<h5 id="git-配置"><a href="#git-配置" class="headerlink" title="git 配置"></a>git 配置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list  // 查看配置</span><br><span class="line">// 用户信息</span><br><span class="line">git config --global user.name "name"</span><br><span class="line">git config --global user.email mail@example.com</span><br><span class="line">//远程仓库</span><br><span class="line">git remote -v</span><br><span class="line">git remote add upstream https://github.com/dongyeforever/ihappy.git // 增加remote</span><br><span class="line">git remote remove upstream // 删除 remote</span><br><span class="line">git branch --set-upstream-to=origin/feature  feature // 关联远程分支</span><br></pre></td></tr></table></figure>
<h4 id="git-进阶"><a href="#git-进阶" class="headerlink" title="git 进阶"></a>git 进阶</h4><ul>
<li>引用</li>
</ul>
<p>第一行的 <code>commit</code> 后面括号里的 <code>HEAD -&gt; master, origin/master, origin/HEAD</code> ，是几个指向这个 <code>commit</code> 的引用。每一个 <code>commit</code> 都有一个它唯一的指定方式——它的 SHA-1 校验和（03dcf7490765baf0394d518a3c6b642e9c5f88b2），你可以使用<code>03dcf74</code>代替这个commit。</p>
<ul>
<li>HEAD</li>
</ul>
<p>当前 <code>commit</code> 在哪里，<code>HEAD</code> 就在哪里，这是一个永远自动指向当前 <code>commit</code> 的引用，所以你永远可以用 <code>HEAD</code> 来操作当前 <code>commit</code>。</p>
<ul>
<li>branch</li>
</ul>
<p><img src="http://user-gold-cdn.xitu.io/2017/11/20/15fd779f983c81e7?w=568&amp;h=306&amp;f=gif&amp;s=144193" alt="分支"></p>
<h5 id="branch-创建、切换和删除"><a href="#branch-创建、切换和删除" class="headerlink" title="branch 创建、切换和删除"></a>branch 创建、切换和删除</h5><p>1.创建一个叫做 “feature” 的 <code>branch</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch feature</span><br></pre></td></tr></table></figure>
<p>2.切换到 “feature”分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br></pre></td></tr></table></figure>
<p>除此之外，你还可以用 <code>git checkout -b 名称</code> 来把上面两步操作合并执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b feature</span><br></pre></td></tr></table></figure>
<p>3.删除分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -d feature  // 出于安全考虑，没有被合并到 master 过的 branch 在删除时会失败</span><br><span class="line">git branch -D feature  // 直接删除</span><br></pre></td></tr></table></figure>
<h5 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h5><p><img src="http://user-gold-cdn.xitu.io/2017/11/29/160071880ab72f00?w=567&amp;h=825&amp;f=jpeg&amp;s=47425" alt="push"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 提交 main 分支 commits</span><br><span class="line">git push</span><br><span class="line">// 切换到 feature 分支</span><br><span class="line">git checkout feature</span><br><span class="line">// 提交 feature 分支到远程仓库</span><br><span class="line">git push [-u] origin feature</span><br></pre></td></tr></table></figure>
<h5 id="merge-合并-commits"><a href="#merge-合并-commits" class="headerlink" title="merge 合并 commits"></a>merge 合并 commits</h5><p><code>merge</code> 的意思是「合并」，它做的事也是合并：指定一个 <code>commit</code>，把它合并到当前的 <code>commit</code> 来。具体来讲，<code>merge</code> 做的事是：</p>
<p><strong>从目标 <code>commit</code> 和当前 <code>commit</code> （即 <code>HEAD</code> 所指向的 <code>commit</code>）分叉的位置起，把目标 <code>commit</code> 的路径上的所有 <code>commit</code> 的内容一并应用到当前 <code>commit</code>，然后自动生成一个新的 <code>commit</code>。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
<p><img src="http://user-gold-cdn.xitu.io/2017/11/21/15fddc2aad5a0279?w=640&amp;h=454&amp;f=gif&amp;s=175263" alt="merge"></p>
<blockquote>
<p>git pull  等价于 git fetch + git merge</p>
</blockquote>
<p>合并冲突</p>
<p>如果两个分支修改了同一部分内容，<code>merge</code> 的自动算法就搞不定了。这种情况 Git 称之为：冲突（Conflict）。</p>
<ul>
<li>解决冲突</li>
<li>手动提交</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add xxx</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p> 取消 merge</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git merge --abort</span><br></pre></td></tr></table></figure>
<h5 id="Pull-Request-工作流"><a href="#Pull-Request-工作流" class="headerlink" title="Pull Request 工作流"></a>Pull Request 工作流</h5><p>这一节介绍了 Feature Branching 这种工作流。它的概念很简单：</p>
<ol>
<li>每个新功能都新建一个 <code>branch</code> 来写；</li>
<li>写完以后，把代码分享给同事看；写的过程中，也可以分享给同事讨论。另外，借助 GitHub 等服务提供方的 Pull Request 功能，可以让代码分享变得更加方便；</li>
<li>分支确定可以合并后，把分支合并到 <code>master</code> ，并删除分支。</li>
</ol>
<p>这种工作流由于功能强大，而且概念和使用方式都很简单，所以很受欢迎。再加上 GitHub 等平台提供了 Pull Request 的支持，目前这种工作流是商业项目开发中最为流行的工作流。</p>
<h5 id="git-查看修改记录"><a href="#git-查看修改记录" class="headerlink" title="git 查看修改记录"></a>git 查看修改记录</h5><ul>
<li>git log 查看历史记录</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log --stat // 查看大致改动</span><br><span class="line">git log --graph</span><br></pre></td></tr></table></figure>
<ul>
<li>git show [commit-id] 查看任意一个 commit 修改</li>
<li>git diff 查看未提交内容</li>
</ul>
<h5 id="不喜欢-merge-的分叉？用-rebase-吧"><a href="#不喜欢-merge-的分叉？用-rebase-吧" class="headerlink" title="不喜欢 merge 的分叉？用 rebase 吧"></a>不喜欢 merge 的分叉？用 rebase 吧</h5><p><code>rebase</code> 指令，它可以改变 <code>commit</code> 序列的基础点。</p>
<p><img src="http://user-gold-cdn.xitu.io/2017/11/21/15fdea7b6646a1f3?w=640&amp;h=454&amp;f=gif&amp;s=175263" alt="merge"></p>
<p><img src="http://user-gold-cdn.xitu.io/2017/11/30/1600abd620a8e28c?w=698&amp;h=518&amp;f=gif&amp;s=337134" alt="rebase"></p>
<p>可能会出问题的 rebase：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase feature // 在master上直接rebase</span><br></pre></td></tr></table></figure>
<p><img src="http://user-gold-cdn.xitu.io/2017/12/2/16014bc64d4337f8?w=643&amp;h=640&amp;f=jpeg&amp;s=58468" alt="rebase"></p>
<p>不会出问题的 rebase 方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase main // 5、6 的分支基点从 2 换成了 4</span><br><span class="line">git checkout main</span><br><span class="line">git merge feature // 合并过来 feature 分支</span><br></pre></td></tr></table></figure>
<blockquote>
<p>所以，为了避免和远端仓库发生冲突，一般不要从 <code>master</code> 向其他 <code>branch</code> 执行 <code>rebase</code> 操作。而如果是 <code>master</code> 以外的 <code>branch</code> 之间的 <code>rebase</code>（比如 <code>branch1</code> 和 <code>branch2</code> 之间），就不必这么多费一步，直接 <code>rebase</code> 就好。</p>
</blockquote>
<h5 id="刚刚提交的代码，发现写错了怎么办？"><a href="#刚刚提交的代码，发现写错了怎么办？" class="headerlink" title="刚刚提交的代码，发现写错了怎么办？"></a>刚刚提交的代码，发现写错了怎么办？</h5><p>“amend” 是「修正」的意思。在提交时，如果加上 <code>--amend</code> 参数，Git 不会在当前 <code>commit</code> 上增加 <code>commit</code>，而是会把当前 <code>commit</code> 里的内容和暂存区（stageing area）里的内容合并起来后创建一个新的 <code>commit</code>，<strong>用这个新的 <code>commit</code> 把当前 <code>commit</code> 替换掉</strong>。所以 <code>commit --amend</code> 做的事就是它的字面意思：对最新一条 <code>commit</code> 进行修正。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add test.txt</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>
<h5 id="丢弃刚写的提交-最新"><a href="#丢弃刚写的提交-最新" class="headerlink" title="丢弃刚写的提交(最新)"></a>丢弃刚写的提交(最新)</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard commit-id</span><br><span class="line"></span><br><span class="line">// 撤销某个提交</span><br><span class="line">git rebase -i HEAD^^</span><br></pre></td></tr></table></figure>
<h5 id="push-后发现写错了"><a href="#push-后发现写错了" class="headerlink" title="push 后发现写错了"></a>push 后发现写错了</h5><p>1.在自己 <code>branch</code> 上，把错误的 commit 修改或者删除，然后 <code>push -f</code>强制提交上去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin feature -f</span><br></pre></td></tr></table></figure>
<p>2.出错的内容已经合并到 master 上</p>
<p>在 <code>revert</code> 完成之后，把新的 <code>commit</code> 再 <code>push</code> 上去。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git revert HEAD^</span><br></pre></td></tr></table></figure>
<h5 id="紧急情况，需要紧急打包"><a href="#紧急情况，需要紧急打包" class="headerlink" title="紧急情况，需要紧急打包"></a>紧急情况，需要紧急打包</h5><p>当你手头有一件临时工作要做，需要把工作目录暂时清理干净，那么你可以：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash</span><br></pre></td></tr></table></figure>
<p>工作目录的改动就被清空了，所有改动都被存了起来。</p>
<p>打包完后，切回你的分支，然后：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash pop</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：没有被 track 的文件（即从来没有被 add 过的文件不会被 stash 起来，因为 Git 会忽略它们。如果想把这些文件也一起 stash，可以加上 <code>-u</code> 参数，它是 <code>--include-untracked</code> 的简写。就像这样：</p>
<p>git stash -u</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git stash list</span><br></pre></td></tr></table></figure>
<h5 id="Branch-删除了还想用，reflog"><a href="#Branch-删除了还想用，reflog" class="headerlink" title="Branch 删除了还想用，reflog"></a>Branch 删除了还想用，reflog</h5><p>引用的 log，使用它可以查看 Git 仓库中的引用的移动记录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">212b0ed (HEAD -&gt; main) HEAD@&#123;0&#125;: checkout: moving from feature to main</span><br><span class="line">34c6314 (origin/main, origin/HEAD, feature) HEAD@&#123;1&#125;: checkout: moving from 34c6314f89e11aa96632390f5209647bd894233a to feature</span><br><span class="line">34c6314 (origin/main, origin/HEAD, feature) HEAD@&#123;2&#125;: checkout: moving from main to 34c6314</span><br><span class="line">212b0ed (HEAD -&gt; main) HEAD@&#123;3&#125;: commit: 增加文件</span><br></pre></td></tr></table></figure>
<p>从图中可以看出，HEAD 的最后一次移动行为是「从 feature 移动到 main」。而在这之后，feature 就被删除了。所以它之前的那个 commit 就是 feature 被删除之前的位置了，也就是第二行的 34c6314。</p>
<p>所以现在就可以切换回 34c6314，然后重新创建 feature ：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout 34c6314</span><br><span class="line">git checkout -b feature</span><br></pre></td></tr></table></figure></p>
<p>这样，你刚删除的<code>feature</code> 就找回来了。</p>
<h5 id="tag"><a href="#tag" class="headerlink" title="tag"></a>tag</h5><p>上线发版打 tag</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure>
<h5 id="cherry-pick-挑选-commit-合并进来"><a href="#cherry-pick-挑选-commit-合并进来" class="headerlink" title="cherry-pick 挑选 commit 合并进来"></a>cherry-pick 挑选 commit 合并进来</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cherry-pick commit-id</span><br><span class="line"></span><br><span class="line">//如果遇到冲突</span><br><span class="line">git cherry-pick --continue</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart入门一</title>
    <url>/2019/12/01/dart/dart-learn01/</url>
    <content><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><p>可以通过显式声明指定类型的方式，创建一个变量并进行初始化。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> name = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><br>dart中变量支持类型推导，用var创建一个变量并进行初始化:<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><br>name 变量的类型被推断为 String。 var的错误用法：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob'</span>;</span><br><span class="line">name = <span class="number">18</span>; <span class="comment">// error 不可以将int赋值给一个String类型</span></span><br></pre></td></tr></table></figure><br>如果对象不限定为单个类型，可以指定为 <code>对象类型</code> 或 <code>动态类型</code>。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> name = <span class="string">'Bob'</span>;</span><br><span class="line"><span class="built_in">print</span>(name.runtimeType); <span class="comment">// String</span></span><br><span class="line">name = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">print</span>(name.runtimeType); <span class="comment">// int</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 本页局部变量遵守 <code>风格建议指南</code> 使用 var。 没有使用指定类型的方式。</p>
</blockquote>
<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>未初始化的变量默认值是 <code>null</code>。即使变量是数字 类型默认值也是 null，因为在 Dart 中一切都是对象，数字类型 也不例外。</p>
<h5 id="Final-和-Const"><a href="#Final-和-Const" class="headerlink" title="Final 和 Const"></a>Final 和 Const</h5><p>使用过程中从来不会被修改的变量， 可以使用 final 或 const, 而不是 var 或者其他类型， Final 变量的值只能被设置一次； const 变量在编译时就已经固定或类变量在第一次使用时被初始化。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// Without a type annotation</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br><span class="line">name = <span class="string">'Alice'</span>; <span class="comment">// error: 一个 final 变量只能被设置一次。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位 (dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准气压</span></span><br><span class="line"><span class="keyword">const</span> baz = [];</span><br><span class="line">baz[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// error: Cannot modify an unmodifiable list</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>const在赋值时，赋值的内容必须是在编译期间就确定下来的。<code>const是不可以赋值为DateTime.now()</code></li>
<li>final在赋值时，可以动态获取，比如赋值一个函数。<code>final一旦被赋值后就有确定的结果，不会再次赋值.</code></li>
</ul>
<h3 id="2-内建类型"><a href="#2-内建类型" class="headerlink" title="2.内建类型"></a>2.内建类型</h3><p>Dart 语言支持以下内建类型：</p>
<p>Number<br>String<br>Boolean<br>List (也被称为 Array)<br>Map<br>Set<br>Rune (用于在字符串中表示 Unicode 字符)<br>Symbol</p>
<h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><p><code>int</code><br>整数值不大于64位， 具体取决于平台。 在 Dart VM 上， 值的范围从 -2^63 到 2^63 - 1. Dart 被编译为 JavaScript 时，使用 JavaScript numbers, 值的范围从 -2^53 到 2^53 - 1.</p>
<p><code>double</code><br>64位（双精度）浮点数，依据 IEEE 754 标准。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> hex = <span class="number">0xDEADBEEF</span>; <span class="comment">// 支持16进制格式</span></span><br></pre></td></tr></table></figure><br><code>String</code><br>Dart 字符串是一组 UTF-16 单元序列。 字符串通过单引号或者双引号创建。</p>
<blockquote>
<p>提示： == 运算符用来测试两个对象是否相等。可以使用 + 运算符来把多个字符串连接为一个。</p>
</blockquote>
<p>类似 <code>python</code> 中使用连续三个单引号或者三个双引号实现多行字符串对象的创建，使用 <code>r</code> 前缀，可以创建 “原始 raw” 字符串：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">'''</span></span><br><span class="line"><span class="string">You can create</span></span><br><span class="line"><span class="string">multi-line strings like this one.</span></span><br><span class="line"><span class="string">'''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="string">"""This is also a</span></span><br><span class="line"><span class="string">multi-line string."""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">r"In a raw string, even \n isn't special."</span>;</span><br></pre></td></tr></table></figure></p>
<p><code>Boolean</code><br>Dart 使用 <code>bool</code> 类型表示布尔值。 Dart 只有字面量 <code>true</code> and <code>false</code> 是布尔类型， 这两个对象都是编译时常量。</p>
<p>Dart 的类型安全意味着不能使用 if (nonbooleanValue) 或者 assert (nonbooleanValue)。 而是应该像下面这样，明确的进行值检查：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查空字符串。</span></span><br><span class="line"><span class="keyword">var</span> fullName = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">assert</span>(fullName.isEmpty);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 0 值。</span></span><br><span class="line"><span class="keyword">var</span> hitPoints = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(hitPoints &lt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 null 值。</span></span><br><span class="line"><span class="keyword">var</span> unicorn;</span><br><span class="line"><span class="keyword">assert</span>(unicorn == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 NaN 。</span></span><br><span class="line"><span class="keyword">var</span> iMeantToDoThis = <span class="number">0</span> / <span class="number">0</span>;</span><br><span class="line"><span class="keyword">assert</span>(iMeantToDoThis.isNaN);</span><br></pre></td></tr></table></figure></p>
<p><code>List</code><br>Dart 中的 List 字面量非常像 JavaScript 中的 array 字面量。 下面是一个 Dart List 的示例：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示：Dart 推断 list 的类型为 List<int> 。 如果尝试将非整数对象添加到此 List 中， 则分析器或运行时会引发错误。</p>
</blockquote>
<p>在 List 字面量之前添加 const 关键字，可以定义 List 类型的编译时常量：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> constantList = <span class="keyword">const</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="comment">// constantList[1] = 1; // 取消注释会引起错误。</span></span><br></pre></td></tr></table></figure><br><code>Set</code><br>下面是通过字面量创建 Set 的一个简单示例：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> halogens = &#123;<span class="string">'fluorine'</span>, <span class="string">'chlorine'</span>, <span class="string">'bromine'</span>, <span class="string">'iodine'</span>, <span class="string">'astatine'</span>&#125;;</span><br></pre></td></tr></table></figure><br>要创建一个空集，使用前面带有类型参数的 {} ，或者将 {} 赋值给 Set 类型的变量：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;&#123;&#125;;</span><br><span class="line"><span class="comment">// Set&lt;String&gt; names = &#123;&#125;; // 这样也是可以的。</span></span><br><span class="line"><span class="comment">// var names = &#123;&#125;; // 这样会创建一个 Map ，而不是 Set 。</span></span><br></pre></td></tr></table></figure></p>
<p><code>Map</code><br>通常来说， Map 是用来关联 keys 和 values 的对象。 keys 和 values 可以是任何类型的对象。在一个 Map 对象中一个 key 只能出现一次。 但是 value 可以出现多次。Map 对象也可以使用 Map 构造函数创建：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;</span><br><span class="line">  <span class="comment">// Key:    Value</span></span><br><span class="line">  <span class="string">'first'</span>: <span class="string">'partridge'</span>,</span><br><span class="line">  <span class="string">'second'</span>: <span class="string">'turtledoves'</span>,</span><br><span class="line">  <span class="string">'fifth'</span>: <span class="string">'golden rings'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gifts = <span class="built_in">Map</span>();</span><br><span class="line">gifts[<span class="string">'first'</span>] = <span class="string">'partridge'</span>;</span><br><span class="line">gifts[<span class="string">'second'</span>] = <span class="string">'turtledoves'</span>;</span><br><span class="line">gifts[<span class="string">'fifth'</span>] = <span class="string">'golden rings'</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示: 这里为什么只有 Map() ，而不是使用 new Map()。 因为在 Dart 2 中，new 关键字是可选的。</p>
</blockquote>
<p>类似 JavaScript ，添加 key-value 对到已有的 Map 中：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line">gifts[<span class="string">'fourth'</span>] = <span class="string">'calling birds'</span>; <span class="comment">// Add a key-value pair</span></span><br></pre></td></tr></table></figure><br>类似 JavaScript ，从一个 Map 中获取一个 value：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> gifts = &#123;<span class="string">'first'</span>: <span class="string">'partridge'</span>&#125;;</span><br><span class="line"><span class="keyword">assert</span>(gifts[<span class="string">'first'</span>] == <span class="string">'partridge'</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="集合的常见操作："><a href="#集合的常见操作：" class="headerlink" title="集合的常见操作："></a>集合的常见操作：</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取集合的长度</span></span><br><span class="line"><span class="built_in">print</span>(list.length);</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">set</span>.length);</span><br><span class="line"><span class="built_in">print</span>(map.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加/删除/包含元素</span></span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">set</span>.add(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$list</span> <span class="subst">$set</span>'</span>);</span><br><span class="line"></span><br><span class="line">list.remove(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">set</span>.remove(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$list</span> <span class="subst">$set</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list.contains(<span class="number">2</span>));</span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">set</span>.contains(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// List根据index删除元素</span></span><br><span class="line">list.removeAt(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$list</span>'</span>);</span><br></pre></td></tr></table></figure>
<h5 id="Map的常见操作"><a href="#Map的常见操作" class="headerlink" title="Map的常见操作"></a>Map的常见操作</h5><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Map的操作</span></span><br><span class="line"><span class="comment">// 1.根据key获取value</span></span><br><span class="line"><span class="built_in">print</span>(map[<span class="string">'name'</span>]); <span class="comment">// Bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取所有的entries</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;map.entries&#125;</span> <span class="subst">$&#123;map.entries.runtimeType&#125;</span>'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取所有的keys</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;map.keys&#125;</span> <span class="subst">$&#123;map.keys.runtimeType&#125;</span>'</span>); <span class="comment">// (name, age) _CompactIterable&lt;String&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取所有的values</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;map.values&#125;</span> <span class="subst">$&#123;map.values.runtimeType&#125;</span>'</span>); <span class="comment">// (Bob, 18) _CompactIterable&lt;Object&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.判断是否包含某个key或者value</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;map.containsKey(<span class="string">'age'</span>)&#125;</span> <span class="subst">$&#123;map.containsValue(<span class="number">18</span>)&#125;</span>'</span>); <span class="comment">// true true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.根据key删除元素</span></span><br><span class="line">map.remove(<span class="string">'age'</span>);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'<span class="subst">$&#123;map&#125;</span>'</span>); <span class="comment">// &#123;name: Bob&#125;</span></span><br></pre></td></tr></table></figure>
<p>实现了 Iterable 的类（比如， List 和 Set）同样也支持使用 for-in 进行迭代操作 iteration ：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> collection = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> x in collection) &#123;</span><br><span class="line">  print(x); <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart入门三</title>
    <url>/2019/12/13/dart/dart-learn03/</url>
    <content><![CDATA[<h3 id="1-类"><a href="#1-类" class="headerlink" title="1.类"></a>1.类</h3><p>Dart 是一种基于类和 mixin 继承机制的面向对象的语言。 每个对象都是一个类的实例，所有的类都继承于 <code>Object</code> 。 基于 <em> Mixin 继承</em> 意味着每个类（除 Object 外） 都只有一个超类， 一个类中的代码可以在其他多个继承类中重复使用。类的定义和Java、TypeScript类似，定义类用<code>class关键字</code>。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() &#123;</span><br><span class="line">  <span class="keyword">var</span> point = Point(); <span class="comment">// Dart中省略 new 关键字</span></span><br><span class="line">  point.x = <span class="number">4</span>; <span class="comment">// Use the setter method for x.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>当通过类创建一个对象时，会调用这个类的构造方法。通过创建一个与其类同名的函数来声明构造函数。</p>
<blockquote>
<p>在没有声明构造函数的情况下， Dart 会提供一个默认的构造函数。 默认构造函数没有参数并会调用父类的无参构造函数。</p>
</blockquote>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="built_in">num</span> x, <span class="built_in">num</span> y) &#123;</span><br><span class="line">    <span class="comment">// 还有更好的方式来实现下面代码</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dart提供了一种更加简洁的<code>语法糖形式</code>。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在构造函数体执行前，</span></span><br><span class="line">  <span class="comment">// 语法糖已经设置了变量 x 和 y。</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 近当存在命名冲突时，使用 this 关键字。 否则，按照 Dart 风格应该省略 this 。</p>
</blockquote>
<h4 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h4><p>由于Dart本身<code>不支持函数的重载</code>，如果我们希望实现更多的构造方法，使用命名构造函数。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 命名构造函数</span></span><br><span class="line">  Point.origin() &#123;</span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>切记，构造函数不能够被继承， 这意味着父类的命名构造函数不会被子类继承。 如果希望使用父类中定义的命名构造函数创建子类， 就必须在子类中实现该构造函数。</p>
<p>默认情况下，子类的构造函数会自动调用父类的默认构造函数（匿名，无参数）。 父类的构造函数在子类构造函数体开始执行的位置被调用。如果提供了一个 initializer list （初始化参数列表）， 则初始化参数列表在父类构造函数执行之前执行。 总之，执行顺序如下：<br>1 initializer list （初始化参数列表）<br>2 superclass’s no-arg constructor （父类的无名构造函数）<br>3 main class’s no-arg constructor （主类的无名构造函数）<br>如果父类中没有匿名无参的构造函数， 则需要手工调用父类的其他构造函数。 在当前构造函数冒号 (<code>:</code>) 之后，函数体之前，声明调用父类构造函数。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">  <span class="comment">// you must call super.fromJson(data).</span></span><br><span class="line">  Employee.fromJson(<span class="built_in">Map</span> data) : <span class="keyword">super</span>.fromJson(data) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'in Employee'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>由于父类的构造函数参数在构造函数执行之前执行， 所以参数可以是一个表达式或者一个方法调用：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  Employee() : <span class="keyword">super</span>.fromJson(getDefaultData());</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>警告： 调用父类构造函数的参数无法访问 this 。 例如，参数可以为静态函数但是不能是实例函数。</p>
</blockquote>
<h4 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h4><p>除了调用超类构造函数之外， 还可以在构造函数体执行之前初始化实例变量。 各参数的初始化用逗号分隔。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在构造函数体执行之前，</span></span><br><span class="line"><span class="comment">// 通过初始列表设置实例变量。</span></span><br><span class="line">Point.fromJson(<span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="built_in">num</span>&gt; json)</span><br><span class="line">    : x = json[<span class="string">'x'</span>],</span><br><span class="line">      y = json[<span class="string">'y'</span>] &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'In Point.fromJson(): (<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h4><p>有时构造函数的唯一目的是重定向到同一个类中的另一个构造函数。 重定向构造函数的函数体为空， 构造函数的调用在冒号 (:) 之后。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类的主构造函数。（注意：是在冒号后面使用this调用）</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指向主构造函数</span></span><br><span class="line">  Point.alongXAxis(<span class="built_in">num</span> x) : <span class="keyword">this</span>(x, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h4><p>在某些情况下，传入相同值时，我们希望返回同一个对象。 为此，需要定义一个 const 构造函数， 并且声明所有实例变量为 final。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImmutablePoint</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> ImmutablePoint origin =</span><br><span class="line">      <span class="keyword">const</span> ImmutablePoint(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">num</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ImmutablePoint(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="工厂构造函数"><a href="#工厂构造函数" class="headerlink" title="工厂构造函数"></a>工厂构造函数</h4><p>当执行构造函数并不总是创建这个类的一个新实例时，则使用 <code>factory</code> 关键字。 例如，一个工厂构造函数可能会返回一个 cache 中的实例， 或者可能返回一个子类的实例。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从命名的 _ 可以知，</span></span><br><span class="line">  <span class="comment">// _cache 是私有属性。</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache = &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) <span class="built_in">print</span>(msg);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示： 工厂构造函数无法访问 this。工厂构造方法需要返回类的实例对象。</p>
</blockquote>
<h3 id="2-类的继承"><a href="#2-类的继承" class="headerlink" title="2.类的继承"></a>2.类的继承</h3><p>和Java一样 Dart 中的继承使用<code>extends</code>关键字，子类中使用<code>super</code>来访问父类。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> brand;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Television turnOn"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn(); <span class="comment">//super来访问父类</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"<span class="subst">$brand</span> SmartTelevision turn on"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="keyword">var</span> tv = SmartTelevision();</span><br><span class="line">  tv.brand = <span class="string">"huawei"</span>;</span><br><span class="line">  tv.turnOn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-抽象类"><a href="#3-抽象类" class="headerlink" title="3.抽象类"></a>3.抽象类</h3><p>使用 <code>abstract</code> 修饰符来定义 <em>抽象类</em> — 抽象类不能实例化。抽象类通常用来定义接口，以及部分实现。如果希望抽象类能够被实例化，那么可以通过定义一个 <code>工厂构造函数</code> 来实现。<br>抽象类通常具有 <code>抽象方法</code>。 下面是一个声明具有抽象方法的抽象类示例：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类被定义为抽象类 所以不能被实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractContainer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义构造行数，字段，方法...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> updateChildren(); <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>提示：抽象方法，必须存在于抽象类中。与<code>Java</code>不同的是定义抽象方法不需要<em>abstract</em>关键字</p>
</blockquote>
<h3 id="4-隐式接口"><a href="#4-隐式接口" class="headerlink" title="4.隐式接口"></a>4.隐式接口</h3><p>Dart中的接口比较特殊， 没有一个专门的关键字来声明接口。<br>默认情况下，每个类都隐式的定义了一个接口。如果要创建一个A类，A要支持B类的 API ，但是不需要继承B的实现， 那么可以通过A实现B的接口(因为Dart不支持多继承)。<br>一个类可以通过 <code>implements</code> 关键字来实现一个或者多个接口， 并实现每个接口要求的 API。 例如：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// person 类。 隐式接口里面包含了 greet() 方法声明。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 包含在接口里，但只在当前库中可见。</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不包含在接口里，因为这是一个构造函数。</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 包含在接口里。</span></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 接口的实现。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Impostor</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> _name =&gt; <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(<span class="built_in">String</span> who) =&gt; <span class="string">'Hi <span class="subst">$who</span>. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span> greetBob(Person person) =&gt; person.greet(<span class="string">'Bob'</span>);</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Person(<span class="string">'Kathy'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(Impostor()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面示例演示一个类如何实现多个接口。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">implements</span> <span class="title">Comparable</span>, <span class="title">Location</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在开发中，我们通常将用于给别人实现的类声明为抽象类</p>
</blockquote>
<h3 id="5-为类添加功能：Mixin"><a href="#5-为类添加功能：Mixin" class="headerlink" title="5.为类添加功能：Mixin"></a>5.为类添加功能：Mixin</h3><p>Mixin 是复用类代码的一种途径，和<code>vuejs</code>中组件的可复用功能类似，复用的类可以在不同层级，之间可以不存在继承关系。<br>Dart通过 <code>with</code> 后面跟一个或多个混入的名称，来 使用 Mixin ，下面的示例演示了两个使用 Mixin 的类：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Musician</span> <span class="keyword">extends</span> <span class="title">Performer</span> <span class="title">with</span> <span class="title">Musical</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Maestro</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="title">with</span> <span class="title">Musical</span>, <span class="title">Aggressive</span>, <span class="title">Demented</span> </span>&#123;</span><br><span class="line">  Maestro(<span class="built_in">String</span> maestroName) &#123;</span><br><span class="line">    name = maestroName;</span><br><span class="line">    canConduct = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 <code>mixin</code> 替换 <code>class</code> 。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">mixin Musical &#123;</span><br><span class="line">  <span class="built_in">bool</span> canPlayPiano = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canCompose = <span class="keyword">false</span>;</span><br><span class="line">  <span class="built_in">bool</span> canConduct = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> entertainMe() &#123;</span><br><span class="line">    <span class="keyword">if</span> (canPlayPiano) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Playing piano'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (canConduct) &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Waving hands'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">'Humming to self'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Mixin 使用 on 来指定可以使用 Mixin 的父类类型：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">mixin MusicalPerformer on Musician &#123;</span><br><span class="line">  <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Dart入门四</title>
    <url>/2019/12/17/dart/dart-learn04/</url>
    <content><![CDATA[<h3 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1.泛型"></a>1.泛型</h3><p>Dart中泛型 (或 参数化) 类型使用<code>&lt;…&gt;</code> 符号表示。通常情况下，使用一个字母来代表类型参数， 例如 E, T, S, K, 和 V 等。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用集合字面量</span></span><br><span class="line"><span class="keyword">var</span> names = &lt;<span class="built_in">String</span>&gt;[<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueNames = &lt;<span class="built_in">String</span>&gt;&#123;<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> pages = &lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;&#123;</span><br><span class="line">  <span class="string">'index.html'</span>: <span class="string">'Homepage'</span>,</span><br><span class="line">  <span class="string">'robots.txt'</span>: <span class="string">'Hints for web robots'</span>,</span><br><span class="line">  <span class="string">'humans.txt'</span>: <span class="string">'We are people, not machines'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时中的泛型集合</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">names.addAll([<span class="string">'Seth'</span>, <span class="string">'Kathy'</span>, <span class="string">'Lars'</span>]);</span><br><span class="line"><span class="built_in">print</span>(names <span class="keyword">is</span> <span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> views = <span class="built_in">Map</span>&lt;<span class="built_in">int</span>, View&gt;(); <span class="comment">// _InternalLinkedHashMap&lt;int, View&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">T first&lt;T&gt;(<span class="built_in">List</span>&lt;T&gt; ts) &#123;</span><br><span class="line">  <span class="comment">// Do some initial work or error checking, then...</span></span><br><span class="line">  T tmp = ts[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// Do some additional checking or processing...</span></span><br><span class="line">  <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类的泛型"><a href="#类的泛型" class="headerlink" title="类的泛型"></a>类的泛型</h4><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  T x;</span><br><span class="line">  T y;</span><br><span class="line"></span><br><span class="line">  Location(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用泛型类型的时候， 可以使用 <code>extends</code> 实现参数类型的限制。如果我们希望类型只能是num类型：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Location</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">num</span>&gt; </span>&#123;</span><br><span class="line">  T x;</span><br><span class="line">  T y;</span><br><span class="line"></span><br><span class="line">  Location(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-库"><a href="#2-库" class="headerlink" title="2.库"></a>2.库</h3><p><code>import</code> 和 <code>library</code> 指令可以用来创建一个模块化的，可共享的代码库。 库不仅提供了 API ，而且对代码起到了封装的作用： 以下划线 (_) 开头的标识符仅在库内可见。<br>库可以通过包来分发。有关 pub（集成在SDK中的包管理器）的信息，请参考 <a href="https://www.dartcn.com/tools/pub/" target="_blank" rel="noopener">Pub Package 和 Asset Manager</a>。</p>
<blockquote>
<p>每个 Dart 应用程序都是一个库 ，虽然没有使用 library 指令。</p>
</blockquote>
<h4 id="库的导入"><a href="#库的导入" class="headerlink" title="库的导入"></a>库的导入</h4><p>通过 <code>import</code> 指定一个库命名空间中的内如如何在另一个库中使用。对于内置库，URI 拥有自己特殊的<code>dart:</code>前缀 。 对于其他的库，用系统文件路径或者<code>package:</code>前缀指定由包管理器（如 pub 工具）提供的库。例如，Dart Web应用程序通常使用 dart:html 库，它们可以像这样导入：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:html'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="指定库前缀"><a href="#指定库前缀" class="headerlink" title="指定库前缀"></a>指定库前缀</h4><p>如果导入两个存在冲突标识符的库， 则可以为这两个库，或者其中一个指定前缀。 例如，如果 library1 和 library2 都有一个 Element 类， 那么可以通过下面的方式处理：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> <span class="keyword">as</span> lib2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lib1 中的 Element。</span></span><br><span class="line"><span class="built_in">Element</span> element1 = <span class="built_in">Element</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 lib2 中的 Element。</span></span><br><span class="line">lib2.<span class="built_in">Element</span> element2 = lib2.<span class="built_in">Element</span>();</span><br></pre></td></tr></table></figure></p>
<h4 id="导入库的一部分"><a href="#导入库的一部分" class="headerlink" title="导入库的一部分"></a>导入库的一部分</h4><p>如果你只使用库的一部分功能，则可以选择需要导入的 内容。例如：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Import only foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib1/lib1.dart'</span> show foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Import all names EXCEPT foo.</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'package:lib2/lib2.dart'</span> hide foo;</span><br></pre></td></tr></table></figure></p>
<h4 id="延迟加载库"><a href="#延迟加载库" class="headerlink" title="延迟加载库"></a>延迟加载库</h4><p>Deferred loading (也称之为 lazy loading) 可以让应用在需要的时候再加载库。 下面是一些使用延迟加载库的场景：</p>
<ul>
<li>减少 APP 的启动时间。</li>
<li>执行 A/B 测试，例如 尝试各种算法的 不同实现。</li>
<li>加载很少使用的功能，例如可选的屏幕和对话框。</li>
</ul>
<p>要延迟加载一个库，需要先使用 <code>deferred as</code> 来导入：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:greetings/hello.dart'</span> deferred <span class="keyword">as</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要使用的时候，使用库标识符调用 loadLibrary() 函数来加载库</span></span><br><span class="line">Future greet() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">await</span> hello.loadLibrary();</span><br><span class="line">  hello.printGreeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>在一个库上你可以多次调用 <code>loadLibrary()</code> 函数。但是该库只是载入一次。<br>Dart 隐含的把 loadLibrary() 函数导入到使用 deferred as 的命名空间 中。 loadLibrary() 方法返回一个 Future。</p>
</blockquote>
<h4 id="实现库"><a href="#实现库" class="headerlink" title="实现库"></a>实现库</h4><p>组织库的源文件y有<code>export</code> 命令和<code>part</code> 命令两种方式，官方不推荐使用<code>part关键字</code>。<br><code>export关键字</code><br>将每一个dart文件作为库文件，使用export关键字在某个库文件中单独导入。</p>
<p><code>mathUtils.dart</code>文件<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> sum(<span class="built_in">int</span> num1, <span class="built_in">int</span> num2) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>dateUtils.dart</code>文件<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">String</span> dateFormat(<span class="built_in">DateTime</span> date) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"2019-12-17"</span>;</span><br><span class="line">&#125;</span><br><span class="line">`utils.dart`文件</span><br><span class="line">```dart</span><br><span class="line"><span class="keyword">library</span> utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="string">"mathUtils.dart"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="string">"dateUtils.dart"</span>;</span><br></pre></td></tr></table></figure><br><code>test_libary.dart</code>文件<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"lib/utils.dart"</span>;</span><br><span class="line"></span><br><span class="line">main(<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; args) &#123;</span><br><span class="line">  <span class="built_in">print</span>(sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">  <span class="built_in">print</span>(dateFormat(<span class="built_in">DateTime</span>.now()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Dart异步模型"><a href="#Dart异步模型" class="headerlink" title="Dart异步模型"></a>Dart异步模型</h3><p>Dart是单线程的，在开发中，我们经常会遇到一些耗时的操作需要完成，比如网络请求、文件读取等等。处理耗时操作一般有两种方式：</p>
<ul>
<li>处理方式一： 多线程，比如Java、我们普遍的做法是开启一个新的线程（Thread），在新的线程中完成这些异步的操作，再通过线程间通信的方式，将拿到的数据传递给主线程。</li>
<li>处理方式二： 单线程+事件循环，比如JavaScript、Dart都是基于单线程加事件循环来完成耗时操作的处理。</li>
</ul>
<p>不过单线程如何能进行耗时的操作呢？<br>单线程模型中主要就是在维护着一个事件循环（Event Loop）。</p>
<ul>
<li>事实上事件循环并不复杂，它就是将需要处理的一系列事件（包括点击事件、IO事件、网络事件）放在一个事件队列（Event Queue）中。</li>
<li>不断的从事件队列（Event Queue）中取出事件，并执行其对应需要执行的代码块，直到事件队列清空位置。</li>
</ul>
<p>Dart 库中包含许多返回 <code>Future</code> 或 <code>Stream</code> 对象的函数。这些函数在设置完耗时任务（例如 I/O 曹组）后， 就立即返回了，不会等待耗任务完成。 使用 <code>async</code> 和 <code>await</code> 关键字实现异步编程。 可以让你像编写同步代码一样实现异步操作。</p>
<h4 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h4><blockquote>
<p>可以将 Future 理解成 ES6 中的 <code>Promise</code>。</p>
</blockquote>
<p>在 Dart 库中随处可见 Future 对象，通常异步函数返回的对象就是一个 Future。 当一个 future <em>完成执行后</em>，future 中的值就已经可以使用了。当 future 执行完成后，then() 中的代码会被执行。例如， HttpRequest.getString() 返回一个 future 对象，因为 HTTP 请求可能需要一段时间。 当 Future 完成并且保证字符串值有效后，使用 then() 来执行你需要的代码：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">HttpRequest.getString(url).then((<span class="built_in">String</span> result) &#123;</span><br><span class="line">            <span class="built_in">print</span>(result);</span><br><span class="line">  &#125;).catchError((e) &#123;</span><br><span class="line">  <span class="comment">// Handle or ignore the error.</span></span><br><span class="line">  <span class="built_in">print</span>(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>使用 <code>catchError()</code> 来处理一些 Future 对象可能抛出的错误或者异常。<code>then().catchError()</code> 组合是 <code>try-catch</code> 的异步版本。</p>
<blockquote>
<p>重要： 确保调用 catchError() 方式在 then() 的结果上，而不是在原来的 Future 对象上调用。 否则的话，catchError() 就只能处理原来 Future 对象抛出的异常， 而无法处理 then() 代码里面的异常。</p>
</blockquote>
<p><code>等待多个 Future</code><br>有时代码逻辑需要调用多个异步函数， 并等待它们全部完成后再继续执行。 使用 <code>Future.wait()</code> 静态方法管理多个 Future 以及等待它们完成：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future deleteLotsOfFiles() <span class="keyword">async</span> =&gt;  ...</span><br><span class="line">Future copyLotsOfFiles() <span class="keyword">async</span> =&gt;  ...</span><br><span class="line">Future checksumLotsOfOtherFiles() <span class="keyword">async</span> =&gt;  ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> Future.wait([</span><br><span class="line">  deleteLotsOfFiles(),</span><br><span class="line">  copyLotsOfFiles(),</span><br><span class="line">  checksumLotsOfOtherFiles(),</span><br><span class="line">]);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Done with all the long steps!'</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="async、await"><a href="#async、await" class="headerlink" title="async、await"></a>async、await</h4><blockquote>
<p>可以将 async、await 理解成 ES6 中的  async、await<br>使用 <code>async、await</code> 关键字的代码是异步的，虽然看起来有点像同步代码。</p>
</blockquote>
<p><code>async</code><br>函数体被 <code>async</code> 标示符标记的函数，即是一个<em>异步函数</em>。 将 async 关键字添加到函数使其返回Future。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步函数，它返回一个 String</span></span><br><span class="line"><span class="built_in">String</span> lookUpVersion() =&gt; <span class="string">'1.0.0'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例如，将来的实现将非常耗时，将其更改为异步函数，返回值是 Future 。</span></span><br><span class="line">Future&lt;<span class="built_in">String</span>&gt; lookUpVersion() <span class="keyword">async</span> =&gt; <span class="string">'1.0.0'</span>;</span><br></pre></td></tr></table></figure><br><code>await</code><br>使用 <code>await 表达式</code> 会阻塞代码的执行，直到需要的对象返回为止。在 <code>await 表达式</code> 中， 表达式 的值通常是一个 Future 对象； 如果不是，这是表达式的值会被自动包装成一个 Future 对象。 Future 对象指明返回一个对象的承诺（promise）。 <code>await 表达式</code> 执行的结果为这个返回的对象。 要使用 <code>await</code> ， 代码必须在 异步函数（使用 <code>async</code> 标记的函数）中：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future checkVersion() <span class="keyword">async</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> version = <span class="keyword">await</span> lookUpVersion();</span><br><span class="line">  <span class="comment">// Do something with version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意，函数体不需要使用Future API。 如有必要， Dart 会创建 Future 对象。<br>如果函数没有返回有效值， 需要设置其返回类型为 <code>Future&lt;void&gt;</code> 。</p>
<p>在一个异步函数中可以多次使用 await 。 例如，下面代码中等待了三次函数结果：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> entrypoint = <span class="keyword">await</span> findEntrypoint();</span><br><span class="line"><span class="keyword">var</span> exitCode = <span class="keyword">await</span> runExecutable(entrypoint, args);</span><br><span class="line"><span class="keyword">await</span> flushThenExit(exitCode);</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>try</code>， <code>catch</code>， 和 <code>finally</code> 来处理代码中使用 <code>await</code> 导致的错误。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  version = <span class="keyword">await</span> deleteLotsOfFiles();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// React to inability to look up the version</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="Feture和async、awiit区别"><a href="#Feture和async、awiit区别" class="headerlink" title="Feture和async、awiit区别"></a>Feture和async、awiit区别</h5><p>在直接使用 <code>Future API</code> 前，首先应该考虑 <code>await</code> 来替代。 代码中使用 <code>await</code> 表达式会比直接使用 Future API 更容易理解。<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">Future result = costlyQuery(url);</span><br><span class="line">result</span><br><span class="line">    .then((value) =&gt; expensiveWork(value))</span><br><span class="line">    .then((_) =&gt; lengthyComputation())</span><br><span class="line">    .then((_) =&gt; <span class="built_in">print</span>(<span class="string">'Done!'</span>))</span><br><span class="line">    .catchError((exception) &#123;</span><br><span class="line">  <span class="comment">/* Handle exception... */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><br>在上面的示例中，方法按下面顺序执行：</p>
<ol>
<li>costlyQuery()</li>
<li>expensiveWork()</li>
<li>lengthyComputation()</li>
</ol>
<p>下面是使用 await 编写的等效代码：<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">final</span> value = <span class="keyword">await</span> costlyQuery(url);</span><br><span class="line">  <span class="keyword">await</span> expensiveWork(value);</span><br><span class="line">  <span class="keyword">await</span> lengthyComputation();</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'Done!'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">/* Handle exception... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用async、awiit的方式，可以用类似同步代码的写法实现异步操作，推荐使用 <code>async</code> 和 <code>await</code> 关键字实现异步编程。</p>
]]></content>
      <categories>
        <category>Dart</category>
      </categories>
      <tags>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title>Gunicorn部署flask项目</title>
    <url>/2018/10/10/server/python-flask-deploy/</url>
    <content><![CDATA[<h3 id="Gunicorn"><a href="#Gunicorn" class="headerlink" title="Gunicorn"></a>Gunicorn</h3><p>Gunicorn ‘Green Unicorn’ 是一个给 UNIX 用的 WSGI HTTP 服务器。这是一个从 Ruby 的 Unicorn 项目移植的 pre-fork worker 模式。它既支持 eventlet ，也支持 greenlet 。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install gunicorn</span><br></pre></td></tr></table></figure>
<p>在这个服务器上运行 Flask 应用是相当简单的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn myproject:app</span><br></pre></td></tr></table></figure><br>Gunicorn 提供了许多命令行选项 —— 见 gunicorn -h 。 例如，用四个 worker 进程（ gunicorn -h ）来运行一个 Flask 应用，绑定到 localhost 的4000 端口（ -b127.0.0.1:4000 ）:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -w 4 -b 127.0.0.1:4000 myproject:app</span><br></pre></td></tr></table></figure><br>配置文件方式启动<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gunicorn -c gunicorn.conf.py app:app</span><br></pre></td></tr></table></figure><br>配置内容为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">import multiprocessing</span><br><span class="line"></span><br><span class="line">bind &#x3D; &quot;127.0.0.1:8000&quot;   #绑定的ip与端口</span><br><span class="line">workers &#x3D; 4               #核心数</span><br><span class="line">errorlog &#x3D; &#39;&#x2F;home&#x2F;yu&#x2F;project&#x2F;log&#x2F;bus&#x2F;gunicorn.error.log&#39; #发生错误时log的路径</span><br><span class="line">accesslog &#x3D; &#39;&#x2F;home&#x2F;yu&#x2F;project&#x2F;log&#x2F;bus&#x2F;gunicorn.access.log&#39; #正常时的log路径</span><br><span class="line">#loglevel &#x3D; &#39;debug&#39;   #日志等级</span><br><span class="line">proc_name &#x3D; &#39;project_bus&#39;   #进程名</span><br></pre></td></tr></table></figure></p>
<h3 id="nginx-https配置"><a href="#nginx-https配置" class="headerlink" title="nginx https配置"></a>nginx https配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              80;</span><br><span class="line">    listen              443 ssl;</span><br><span class="line">    server_name api.lovek.vip; #填写绑定证书的域名</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ssl&#x2F;api_lovek_vip.crt;</span><br><span class="line">    ssl_certificate_key ssl&#x2F;api_lovek_vip.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8000;</span><br><span class="line">        proxy_pass_header       Authorization;</span><br><span class="line">        proxy_pass_header       WWW-Authenticate;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F;static&#x2F; &#123;</span><br><span class="line">        root home&#x2F;yu&#x2F;project&#x2F;python&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重启ngixn服务"><a href="#重启ngixn服务" class="headerlink" title="重启ngixn服务"></a>重启ngixn服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br><span class="line">centos7     sudo systemctl start nginx.service</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim常用操作</title>
    <url>/2016/12/26/server/vim/</url>
    <content><![CDATA[<h3 id="vim模式："><a href="#vim模式：" class="headerlink" title="vim模式："></a>vim模式：</h3><p>编辑模式（命令模式）<br>输入模式<br>末行模式</p>
<p>模式转换：<br>编辑–&gt;输入：<br>i：在当前光标所在字符的前面，转为输入模式<br>a：在当前光标所在字符的后面，转为输入模式<br>o：在当前光标所在行的下方，新建一行，转为输入模式<br>I：在当前光标所在行的行首，转为输入模式<br>A：在当前光标所在行的行尾，转为输入模式<br>O：在当前光标所在行的上方，新建一行，转为输入模式</p>
<p>输入–&gt;编辑：<br>ESC</p>
<p>输入–&gt;末行：<br>:</p>
<p>末行–&gt;编辑：<br>ESC，ESC</p>
<h3 id="一、打开文件"><a href="#一、打开文件" class="headerlink" title="一、打开文件"></a>一、打开文件</h3><p>vim FILE<br>vim +#：打开文件直接定位到第#行<br>vim +：打开文件，定位至最后一行<br>vim +/PATTEN：打开文件，定位至第一次被PATTEN匹配到的行首</p>
<p>默认处于编辑模式</p>
<h3 id="二、关闭文件"><a href="#二、关闭文件" class="headerlink" title="二、关闭文件"></a>二、关闭文件</h3><p>1、末行模式下关闭文件<br>:q 退出<br>:wq 保存并退出<br>:q! 不保存退出<br>:w 保存<br>:w! 强行保存<br>:wq –&gt; :x<br>2、编辑模式下退出<br>ZZ：保存并退出</p>
<p>###三、移动光标<br>1、逐字符移动<br>h：左<br>l：右<br>j：下<br>k：上</p>
<pre><code>#h：移动#个字符
</code></pre><p>2、逐单词移动<br>w：移至下一个单词词首<br>e：跳至当前或下一个单词词尾<br>b：跳至当前或前一个单词词首<br>3、行内跳转<br>0：绝对行首<br>^：行首的第一个非空白字符<br>$：绝对行尾<br>4、行间跳转</p>
<pre><code>#G：跳转至第#行
</code></pre><p>G：最后一行<br>末行模式下，直接给出行号即可</p>
<h3 id="四、翻屏"><a href="#四、翻屏" class="headerlink" title="四、翻屏"></a>四、翻屏</h3><p>Ctrl+f：向下翻<br>Ctrl+b：向上翻</p>
<p>Ctrl+d：向下翻半屏<br>Ctrl+u：向上翻半屏</p>
<h3 id="五、编辑"><a href="#五、编辑" class="headerlink" title="五、编辑"></a>五、编辑</h3><p>x：删除光标所在的单个字符</p>
<pre><code>#x：删除光标所在及其向后共#个字符
</code></pre><h3 id="六、删除命令：d"><a href="#六、删除命令：d" class="headerlink" title="六、删除命令：d"></a>六、删除命令：d</h3><p>d$、 d0、#dw、#de、#db<br>dd：删除当前光标所在行</p>
<pre><code>#dd：删除包括当前所在行在内的#行
</code></pre><p>末行模式下：<br>StartADD,EndADD d：删除从start到end行<br>.：表示当前行<br>$：最后一行<br>+#：向下的#行</p>
<h3 id="七、粘贴命令-p"><a href="#七、粘贴命令-p" class="headerlink" title="七、粘贴命令 p"></a>七、粘贴命令 p</h3><p>p：如果删除或复制的为整行，则粘贴至光标所在行的下方，如果复制 或删除的内容为非整行，则粘贴至光标所在字符的后面<br>P：如果删除或复制的为整行，则粘贴至光标所在行的上方，如果复制 或删除的内容为非整行，则粘贴至光标所在字符的前面</p>
<h3 id="八、复制-y（yank）"><a href="#八、复制-y（yank）" class="headerlink" title="八、复制 y（yank）"></a>八、复制 y（yank）</h3><p>用法同d命令</p>
<h3 id="九、修改：先删除内容再转换为输入模式"><a href="#九、修改：先删除内容再转换为输入模式" class="headerlink" title="九、修改：先删除内容再转换为输入模式"></a>九、修改：先删除内容再转换为输入模式</h3><p>c：用法同d</p>
<h3 id="十、替换："><a href="#十、替换：" class="headerlink" title="十、替换："></a>十、替换：</h3><p>r：替换单个字符<br>R：替换模式</p>
<h3 id="十一：撤销编辑"><a href="#十一：撤销编辑" class="headerlink" title="十一：撤销编辑"></a>十一：撤销编辑</h3><p>u：（undo）撤销前一次操作，可多次使用</p>
<pre><code>#u：直接撤销#次编辑操作
</code></pre><p>撤销最近一次撤销：Ctrl+r</p>
<h3 id="十二、重复前一次编辑操作"><a href="#十二、重复前一次编辑操作" class="headerlink" title="十二、重复前一次编辑操作"></a>十二、重复前一次编辑操作</h3><pre><code>.
</code></pre><h3 id="十三、可视化模式"><a href="#十三、可视化模式" class="headerlink" title="十三、可视化模式"></a>十三、可视化模式</h3><p>v：按字符选取<br>V：按矩形块选取</p>
<h3 id="十四、查找"><a href="#十四、查找" class="headerlink" title="十四、查找"></a>十四、查找</h3><p>/PATTERN<br>n：下一个<br>N：上一个<br>?PATTERN：倒着找</p>
<h3 id="十五、查找并替换"><a href="#十五、查找并替换" class="headerlink" title="十五、查找并替换"></a>十五、查找并替换</h3><p>在末行模式下使用s命令<br>ADDR1,ADDR2@PATTERN@string@gi：<br>g：全局替换<br>i：忽略大小写<br>例如 :.,$s/aa/AA/g：表示从当前行，到末行把aa替换为AA，全局替换<br>%：表示全文 :%s/aa/AA/g</p>
<h3 id="十六、使用vim编辑多个文件"><a href="#十六、使用vim编辑多个文件" class="headerlink" title="十六、使用vim编辑多个文件"></a>十六、使用vim编辑多个文件</h3><p>vim FILE1 FILE2 FILE3<br>:next：切换至下一个文件<br>:prev<br>:last<br>:first</p>
<p>退出<br>:qa 全部退出</p>
<h3 id="十七、分屏显示一个文件"><a href="#十七、分屏显示一个文件" class="headerlink" title="十七、分屏显示一个文件"></a>十七、分屏显示一个文件</h3><p>Ctrl+w, s：水平拆分窗口<br>Ctrl+w,v：垂直拆分</p>
<p>在窗口间切换光标：<br>Ctrl+w，↑↓←→</p>
<h3 id="十八、分窗口显示多个文件"><a href="#十八、分窗口显示多个文件" class="headerlink" title="十八、分窗口显示多个文件"></a>十八、分窗口显示多个文件</h3><p>vim -o：水平分割 显示<br>vim -O：垂直分割显示</p>
<h3 id="十九、将当前文中部分内容另存为另外-一个文件"><a href="#十九、将当前文中部分内容另存为另外-一个文件" class="headerlink" title="十九、将当前文中部分内容另存为另外 一个文件"></a>十九、将当前文中部分内容另存为另外 一个文件</h3><p>末行模式下使用w命令<br>:w<br>:w /path</p>
<h3 id="二十、将另一个文件的内容填充到当前文件"><a href="#二十、将另一个文件的内容填充到当前文件" class="headerlink" title="二十、将另一个文件的内容填充到当前文件"></a>二十、将另一个文件的内容填充到当前文件</h3><p>:r</p>
<h3 id="二十一、和shell交互"><a href="#二十一、和shell交互" class="headerlink" title="二十一、和shell交互"></a>二十一、和shell交互</h3><p>:! COMMAND</p>
<h3 id="二十二、高级话题"><a href="#二十二、高级话题" class="headerlink" title="二十二、高级话题"></a>二十二、高级话题</h3><p>1.显示行号<br>:set nu：number 行号</p>
<p>:set nonu</p>
<p>2.显示忽略大小写<br>:set ic（ignorecase）</p>
<p>:set noic（noignorecase）</p>
<p>3.设定自动缩进<br>:set autoindent<br>:set ai</p>
<p>:set noai</p>
<p>4.查找到的文本高亮显示或取消<br>:set hlsearch<br>:set nohlsearch</p>
<p>5.语法高亮<br>:syntax on<br>:syntax off</p>
<h3 id="二十三、配置文件"><a href="#二十三、配置文件" class="headerlink" title="二十三、配置文件"></a>二十三、配置文件</h3><p>/etc/vimrc<br>/home/user/.vimrc</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome扩展开发</title>
    <url>/2019/11/23/web/chrome-extension/</url>
    <content><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>chrome扩展程序（常称插件）是一个用Web技术开发、用来增强浏览器功能的软件，chrome浏览器扩展开发算是相当简单的，基本只要掌握HTML+CSS+Javascript，即可快速开发一个属于你的chrome插件！它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包。</p>
<p>chrome插件提供了很多实用API供我们使用，包括但不限于：</p>
<p>书签控制；<br>下载控制；<br>窗口控制；<br>标签控制；<br>网络请求控制，<br>各类事件监听；<br>自定义原生菜单；<br>完善的通信机制；</p>
<h3 id="2-文件目录"><a href="#2-文件目录" class="headerlink" title="2. 文件目录"></a>2. 文件目录</h3><p><img src="/images/2019121002.png" alt=""></p>
<h3 id="3-插件组成"><a href="#3-插件组成" class="headerlink" title="3. 插件组成"></a>3. 插件组成</h3><p><img src="/images/2019121001.png" alt=""></p>
<h4 id="后台网页background"><a href="#后台网页background" class="headerlink" title="后台网页background"></a>后台网页background</h4><p>后台网页，这是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p>
<p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 会一直常驻的后台JS或后台页面</span><br><span class="line">    "background":</span><br><span class="line">    &#123;</span><br><span class="line">        // 2种指定方式，如果指定JS，那么会自动生成一个背景页</span><br><span class="line">        "page": "background.html"</span><br><span class="line">        //"scripts": ["js/background.js"]</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户界面网页popup"><a href="#用户界面网页popup" class="headerlink" title="用户界面网页popup"></a>用户界面网页popup</h4><p>扩展程序可以包含普通的 HTML 网页，用来显示扩展程序的用户界面。例如，浏览器按钮可以包含弹出菜单，通过 HTML 文件实现。任何一个扩展程序都可以有选项页面，让用户自定义扩展程序的工作方式。</p>
<p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。</p>
<h4 id="内容脚本content-scripts"><a href="#内容脚本content-scripts" class="headerlink" title="内容脚本content-scripts"></a>内容脚本content-scripts</h4><p>如果您的扩展程序需要与网页交互，您就需要使用内容脚本。内容脚本是一些 JavaScript 代码，它们在浏览器中已加载页面的上下文中执行。借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS，最常见的比如：广告屏蔽、页面CSS定制，等等。</p>
<p>content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.*api，如果非要调用其它API的话，你还可以通过通信来实现让background来帮你调用。</p>
<h3 id="4-使用-chrome-API"><a href="#4-使用-chrome-API" class="headerlink" title="4. 使用 chrome.* API"></a>4. 使用 chrome.* API</h3><p>扩展程序除了能够使用网页和应用可以使用的所有 API 外，还能使用仅用于 Chrome 浏览器的 API（通常称为 chrome.* API）来更好地与浏览器集成。例如，任何扩展程序或网上应用可以使用标准的 window.open() 方法来打开一个网页，但是如果您想指定网页应该显示在哪个窗口中，您的扩展程序就可以使用仅用于 Chrome 浏览器的 tabs.create 方法。</p>
<p>异步方法与同步方法的区别<br>大部分 chrome.* API 的方法都是异步的，它们不等待操作完成就立即返回。如果您需要知道操作结果，您可以向方法传递一个回调函数，回调函数将稍后在方法返回后的某个时刻执行（可能很久之后）。下面是一个异步方法签名的例子：</p>
<p>chrome.tabs.create(object createProperties, function callback)</p>
<p>也有一些 chrome.* 方法是同步的。同步的方法没有回调参数，因为它们只有当所有操作完成后才返回。通常，同步方法有返回值类型。考虑 runtime.getURL 方法：</p>
<p>string chrome.runtime.getURL()</p>
<p>该方法没有回调参数，但是有返回值类型 string，因为它同步地返回 URL，不进行任何其他异步操作。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.tabs.query(&#123;<span class="string">'active'</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>) </span>&#123;</span><br><span class="line">  chrome.tabs.update(tabs[<span class="number">0</span>].id, &#123;<span class="attr">url</span>: newUrl&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="5-插件清单manifest-json"><a href="#5-插件清单manifest-json" class="headerlink" title="5. 插件清单manifest.json"></a>5. 插件清单manifest.json</h3><p>manifest.json是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。</p>
<p>下面给出的是一些常见的配置项：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> //必选</span><br><span class="line"> /*</span><br><span class="line">   指定您的应用包要求的清单文件格式的版本。从 Chrome 18 开始，开发人员应该指定 2</span><br><span class="line"> */</span><br><span class="line"> "manifest_version": 2,</span><br><span class="line"> "name":"我的应用名称",</span><br><span class="line"> "version":"我的应用版本",</span><br><span class="line"></span><br><span class="line"> //推荐</span><br><span class="line"> /*</span><br><span class="line">   清单文件-默认语言 指定_locales中的子目录，包含该应用默认字符串。</span><br><span class="line">   对于含有 _locales 目录的应用来说这一属性是必需的，</span><br><span class="line">   在没有 _locales 目录的应用中该属性不能存在</span><br><span class="line"> */</span><br><span class="line"> "default_locale":"en", </span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">   这个描述在安装应用之后可以看见</span><br><span class="line"> */</span><br><span class="line"> "description":"关于应用的描述", </span><br><span class="line"></span><br><span class="line"> /*一个或多个代表应用、应用或主题背景的图标*/</span><br><span class="line"> "icons":&#123;</span><br><span class="line">   "16":"icon16.png",</span><br><span class="line">   "48":"icon48.png"</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">  选择某一个（或者无）</span><br><span class="line">  browser_action（浏览器按钮）</span><br><span class="line">  page_action（页面按钮）</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> // 如果有 browser_action, 即在 chrome toolbar 的右边添加了一个 icon</span><br><span class="line"> "browser_action": &#123;</span><br><span class="line">   "default_icon": "logo.jpg",</span><br><span class="line">   "default_title": "Google Mail",      // tooltip, 光标停留在 icon 上时显示</span><br><span class="line">   "default_popup": "popup.html"  // 如果有 popup 的页面, 则用户点击图标就会渲染此 HTML 页面</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 如果并不是对每个网站页面都需要使用插件, 可以使用 page_action(页面按钮） 而不是 browser_action（浏览器按钮）</span><br><span class="line"> // browser_action 应用更加广泛</span><br><span class="line"> // 如果 page_action 并不应用在当前页面, 会显示灰色</span><br><span class="line"></span><br><span class="line"> "page_action":&#123;</span><br><span class="line">   "default_icon": &#123;                    // 可选</span><br><span class="line">     "19": "images/icon19.png",           // 可选</span><br><span class="line">     "38": "images/icon38.png"            // 可选</span><br><span class="line">   &#125;,</span><br><span class="line">   "default_title": "Google Mail",      // 可选，在工具提示中显示</span><br><span class="line">   "default_popup": "popup.html"        // 可选</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"> //可选</span><br><span class="line"> "author":"开发者",</span><br><span class="line"> "automation":"",</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line"> 后台网页</span><br><span class="line"> 1.应用通常需要有一个长时间运行的脚本来管理一些任务或状态，而后台网页就是为这一目的而设立。</span><br><span class="line"> 通常情况下，后台页面不需要任何 HTML 标记，这种情况下后台页面可以单独使用 JavaScript文件实现。</span><br><span class="line"> 后台页面将由应用系统生成，包含 scripts 属性中列出的每一个文件。</span><br><span class="line"></span><br><span class="line"> 2.page：如果您需要在您的后台页面中指定 HTML，您可以改用 page 属性：</span><br><span class="line"></span><br><span class="line"> 3.persistent：应用和应用通常需要长时间运行的脚本来管理某些任务或状态，这就是事件页面的作用。</span><br><span class="line"> 事件页面只在需要时加载，当事件页面不活动时就会卸载，以便释放内存和其他系统资源。</span><br><span class="line"> 如何得到事件页面 就是设置一个"persistent"键，如果没有设置，你将得到一个普通的后台页面。</span><br><span class="line"> */</span><br><span class="line"> "background":&#123;</span><br><span class="line">   "scripts":["background.js"],</span><br><span class="line">   "page": "background.html",</span><br><span class="line">   "persistent":false</span><br><span class="line"> &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> /*</span><br><span class="line">   内容脚本:其实就是向你想要的网页中插入一个脚本代码，执行你想要做的事情</span><br><span class="line">   内容脚本是在网页的上下文中运行的 JavaScript 文件，</span><br><span class="line">   它们可以通过标准的文档对象模型（DOM）来获取浏览器访问的网页详情，或者作出更改。</span><br><span class="line">   </span><br><span class="line">   1.run_at 可选。</span><br><span class="line">   控制 js 中的 JavaScript 文件何时插入，</span><br><span class="line">   可以为 "document_start"、</span><br><span class="line">   "document_end" 或 "document_idle"，默认为 "document_idle"。 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   1.1如果是 "document_start"，这些文件将在 css 中指定的文件之后，但是在所有其他 DOM 构造或脚本运行之前插入。 </span><br><span class="line"></span><br><span class="line">   1.2.如果是 "document_end"，文件将在 DOM 完成之后立即插入，但是在加载子资源（如图像与框架）之前插入。 </span><br><span class="line"></span><br><span class="line">   1.3.如果是 "document_idle"，浏览器将在 "document_end" 和刚发生 window.onload 事件这两个时刻之间选择合适的时候插入，</span><br><span class="line">   具体的插入时间取决于文档的复杂程度以及加载文档所花的时间，并且浏览器会尽可能地为加快页面加载速度而优化。 </span><br><span class="line"> </span><br><span class="line">   2.all_frames 可选。</span><br><span class="line">   控制内容脚本运行在匹配页面的所有框架中还是仅在顶层框架中。 默认为 false，意味着仅在顶层框架中运行</span><br><span class="line">   </span><br><span class="line">   content_scripts还有一些其他不是很常用的属性</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"> "content_scripts": [&#123;</span><br><span class="line">   "matches": ["https://*.lovek.vip/*"], //匹配的地址网页</span><br><span class="line">   "exclude_matches":[],</span><br><span class="line">   "js": ["jquery.js","ideacome.js"], //插入的js</span><br><span class="line">   "css": ["mystyles.css"], //css改变样式</span><br><span class="line">   "run_at":"document_idle",</span><br><span class="line">   "all_frames": true //该匹配下面的所有窗口</span><br><span class="line"> &#125;,&#123;</span><br><span class="line">   "matches": ["*://*/*.png", "*://*/*.jpg", "*://*/*.gif", "*://*/*.bmp"],</span><br><span class="line">   "js": ["js/show-image-content-size.js"] //可以针对不同的规则插入不同的内容</span><br><span class="line"> &#125;],</span><br><span class="line"></span><br><span class="line">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span><br><span class="line">"web_accessible_resources": [</span><br><span class="line">   "images/*.png",</span><br><span class="line">   "style/double-rainbow.css",</span><br><span class="line">   "script/double-rainbow.js",</span><br><span class="line">   "script/main.js",</span><br><span class="line">   <span class="string">"templates/*"</span></span><br><span class="line"> ],</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  如果不是通过 chrome web store 自动更新插件</span><br><span class="line"></span><br><span class="line">   我们希望扩展能自动升级，理由和让chrome自动升级一样：修改程序bug和安全漏洞 ，增加新功能，提升性能，改善体验。</span><br><span class="line">   一个扩展的manifest文件里面必须指定一个"update_url"来执行升级检测。</span><br><span class="line"></span><br><span class="line">   扩展可以托管在Chrome Web Store，也可以发布到极速浏览器应用开放平台上。</span><br><span class="line">   如果托管在Chrome Web Store则update_url应该是：http://clients2.google.com/service/update2/crx    </span><br><span class="line"> **/</span><br><span class="line"> "update_url": "https://clients2.google.com/service/update2/crx",</span><br><span class="line"></span><br><span class="line">// 插件主页，这个很重要，不要浪费了这个免费广告位</span><br><span class="line">"homepage_url": "https://www.lovek.vip",</span><br><span class="line"></span><br><span class="line">/*  </span><br><span class="line">   扩展或app将使用的一组权限。每个权限是一列已知字符串列表中的一个，</span><br><span class="line">   如geolocatioin或者一个匹配模式，来指定可以访问的一个或者多个主机。</span><br><span class="line">   权限可以帮助限定危险，如果你的扩展或者app被攻击。</span><br><span class="line">   一些权限在安装之前，会告知用户</span><br><span class="line"> */</span><br><span class="line"> "permissions":[</span><br><span class="line">   "tabs", //Required if the extension uses the chrome.tabs or chrome.windows module.</span><br><span class="line">   "bookmarks", //使用chrome.bookmarks模块来创建、组织和管理书签</span><br><span class="line">   "http://www.lovek.vip/",    </span><br><span class="line">   "http://*.google.com/",    </span><br><span class="line">   "unlimitedStorage", //提供了一个无限的HTML5配额来存储客户端数据,如数据库和本地存储文件。没有这个权限,扩展仅限于5 MB的本地存储</span><br><span class="line">   "history" //历史记录的使用权限  chrome.history </span><br><span class="line">   "notifications",//提示</span><br><span class="line">   "cookies",//Required if the extension uses the chrome.cookies module.</span><br><span class="line"> ],</span><br><span class="line"></span><br><span class="line">/**开发时为扩展指定的唯一标识值。</span><br><span class="line">注意：通常您并不需要直接使用这个值，而是在您的代码中使用相对路径或者chrome.extension.getURL()得到的绝对路径。</span><br><span class="line">这个值并不是开发时显式指定的，而是Chrome在安装.crx时辅助生成的。(开发时可以通过上传扩展或者手工打包生成crx文件)。 安装完crx，在Chrome的用户数据目录下的Default/Extensions/&lt;extensionId&gt;/&lt;versionString&gt;/manifest.json文件中，您可以看到这个扩展的key。**/</span><br><span class="line"></span><br><span class="line">key:'',</span><br><span class="line"></span><br><span class="line">"commands": &#123;</span><br><span class="line">     // commands API 用来添加快捷键</span><br><span class="line">     // 需要在 background page 上添加监听器绑定 handler</span><br><span class="line">   "toggle-feature-foo": &#123;</span><br><span class="line">     "suggested_key": &#123;</span><br><span class="line">       "default": "Ctrl+Shift+Y",</span><br><span class="line">       "mac": "Command+Shift+Y"</span><br><span class="line">     &#125;,</span><br><span class="line">     "description": "Toggle feature foo",</span><br><span class="line">     "global": true</span><br><span class="line">       // 当 chrome 没有 focus 时也可以生效的快捷键</span><br><span class="line">       // 仅限 Ctrl+Shift+[0..9]</span><br><span class="line">   &#125;,</span><br><span class="line">   "_execute_browser_action": &#123;</span><br><span class="line">     "suggested_key": &#123;</span><br><span class="line">       "windows": "Ctrl+Shift+Y",</span><br><span class="line">       "mac": "Command+Shift+Y",</span><br><span class="line">       "chromeos": "Ctrl+Shift+U",</span><br><span class="line">       "linux": "Ctrl+Shift+J"</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   "_execute_page_action": &#123;</span><br><span class="line">     "suggested_key": &#123;</span><br><span class="line">       "default": "Ctrl+Shift+E",</span><br><span class="line">       "windows": "Alt+Shift+P",</span><br><span class="line">       "mac": "Alt+Shift+P"</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   ...</span><br><span class="line"> &#125;,</span><br><span class="line"> "content_capabilities": ...,</span><br><span class="line"> "optional_permissions": ["tabs"], // 其他需要的 permission, 在使用 chrome.permissions API 时用到, 并非安装插件时需要</span><br><span class="line"></span><br><span class="line"> "short_name": "Short Name", // 插件名字简写</span><br><span class="line"></span><br><span class="line">"storage": &#123;</span><br><span class="line">   "managed_schema": "schema.json"</span><br><span class="line"> &#125;, //  使用 storage.managed api 的话, 需要一个 schema 文件指定存储字段类型等, 类似定义数据库表的 column</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">//还有很多其他的配置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转载请注明出处：<a href="https://blog.lovek.vip/2019/12/10/chrome-extension/">https://blog.lovek.vip/2019/12/10/chrome-extension/</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>Android小技巧OnClickListener去重</title>
    <url>/2020/09/06/web/debounce-onclick/</url>
    <content><![CDATA[<p>当View被快速多次点击，onClickListener事件的<code>onClick(View view)</code>会执行多次。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@linkplain</span> View.OnClickListener click listener&#125; that debounces multiple clicks posted in the</span></span><br><span class="line"><span class="comment"> * same frame. A click on one button disables all buttons for that frame.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DebouncingOnClickListener</span> <span class="title">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> Runnable ENABLE_AGAIN = () -&gt; enabled = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">private</span> static <span class="keyword">final</span> Handler MAIN = new Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">  static boolean enabled = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">final</span> void onClick(View v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">      enabled = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Post to the main looper directly rather than going through the view.</span></span><br><span class="line">      <span class="comment">// Ensure that ENABLE_AGAIN will be executed, avoid static field &#123;@link #enabled&#125;</span></span><br><span class="line">      <span class="comment">// staying in false state.</span></span><br><span class="line">      MAIN.post(ENABLE_AGAIN);</span><br><span class="line"></span><br><span class="line">      doClick(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> void doClick(View v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://github.com/JakeWharton/butterknife/blob/27232288409731720e46f198d1e388517f453d97/butterknife-runtime/src/main/java/butterknife/internal/DebouncingOnClickListener.java" target="_blank" rel="noopener">butterknife中DebouncingOnClickListener</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript中apply和call</title>
    <url>/2018/02/06/web/js-function-apply-call/</url>
    <content><![CDATA[<p>函数是一个特殊的对象，和对象的区别：函数通过对象的拷贝来完成赋值，对象是通过引用指向来完成。</p>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！</p>
<p>要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。</p>
<p>用apply修复getAge()调用：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</span><br><span class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">'小明'</span>,</span><br><span class="line">    birth: <span class="number">1990</span>,</span><br><span class="line">    age: getAge</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.age(); <span class="comment">// 25</span></span><br><span class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></span><br></pre></td></tr></table></figure><br>另一个与apply()类似的方法是call()，唯一区别是：</p>
<p>apply()把参数打包成Array再传入；</p>
<p>call()把参数按顺序传入。</p>
<p>比如调用Math.max(3, 5, 4)，分别用apply()和call()实现如下：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><br>对普通函数调用，我们通常把this绑定为null。</p>
<h3 id="apply-和-call-的区别"><a href="#apply-和-call-的区别" class="headerlink" title="apply 和 call 的区别"></a>apply 和 call 的区别</h3><p>ECMAScript 规范给所有函数都定义了 call 与 apply 两个方法，它们的应用非常广泛，它们的作用也是一模一样，只是传参的形式有区别而已。</p>
<h3 id="apply-1"><a href="#apply-1" class="headerlink" title="apply( )"></a>apply( )</h3><p>apply 方法传入两个参数：一个是作为函数上下文的对象，另外一个是作为函数参数所组成的数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name : <span class="string">'linxin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">firstName, lastName</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(firstName + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.apply(obj, [<span class="string">'A'</span>, <span class="string">'B'</span>]);    <span class="comment">// A linxin B</span></span><br></pre></td></tr></table></figure><br>可以看到，obj 是作为函数上下文的对象，函数 func 中 this 指向了 obj 这个对象。参数 A 和 B 是放在数组中传入 func 函数，分别对应 func 参数的列表元素。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call( )"></a>call( )</h3><p>call 方法第一个参数也是作为函数上下文的对象，但是后面传入的是一个参数列表，而不是单个数组。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'linxin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(firstName + <span class="string">' '</span> + <span class="keyword">this</span>.name + <span class="string">' '</span> + lastName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj, <span class="string">'C'</span>, <span class="string">'D'</span>);       <span class="comment">// C linxin D</span></span><br></pre></td></tr></table></figure><br>对比 apply 我们可以看到区别，C 和 D 是作为单独的参数传给 func 函数，而不是放到数组中。</p>
<p>对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。</p>
<h3 id="apply-和-call-的用法"><a href="#apply-和-call-的用法" class="headerlink" title="apply 和 call 的用法"></a>apply 和 call 的用法</h3><h4 id="1-改变-this-指向"><a href="#1-改变-this-指向" class="headerlink" title="1.改变 this 指向"></a>1.改变 this 指向</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'linxin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func.call(obj);       <span class="comment">// linxin</span></span><br></pre></td></tr></table></figure>
<p>我们知道，call 方法的第一个参数是作为函数上下文的对象，这里把 obj 作为参数传给了 func，此时函数里的 this 便指向了 obj 对象。此处 func 函数里其实相当于<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-借用别的对象的方法"><a href="#2-借用别的对象的方法" class="headerlink" title="2.借用别的对象的方法"></a>2.借用别的对象的方法</h4><p>先看例子<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Person1  = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'linxin'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Person2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.getname = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    Person1.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person2();</span><br><span class="line">person.getname();       <span class="comment">// linxin</span></span><br></pre></td></tr></table></figure><br>从上面我们看到，Person2 实例化出来的对象 person 通过 getname 方法拿到了 Person1 中的 name。因为在 Person2 中，Person1.call(this) 的作用就是使用 Person1 对象代替 this 对象，那么 Person2 就有了 Person1 中的所有属性和方法了，相当于 Person2 继承了 Person1 的属性和方法。</p>
<h4 id="3-调用函数"><a href="#3-调用函数" class="headerlink" title="3.调用函数"></a>3.调用函数</h4><p>apply、call 方法都会使函数立即执行，因此它们也可以用来调用函数。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'linxin'</span>);</span><br><span class="line">&#125;</span><br><span class="line">func.call();            <span class="comment">// linxin</span></span><br></pre></td></tr></table></figure></p>
<h3 id="call-和-bind-的区别"><a href="#call-和-bind-的区别" class="headerlink" title="call 和 bind 的区别"></a>call 和 bind 的区别</h3><p>在 EcmaScript5 中扩展了叫 bind 的方法，在低版本的 IE 中不兼容。它和 call 很相似，接受的参数有两部分，第一个参数是是作为函数上下文的对象，第二部分参数是个列表，可以接受多个参数。<br>它们之间的区别有以下两点。</p>
<h4 id="1-bind-发返回值是函数"><a href="#1-bind-发返回值是函数" class="headerlink" title="1.bind 发返回值是函数"></a>1.bind 发返回值是函数</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'linxin'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func1 = func.bind(obj);</span><br><span class="line">func1();                        <span class="comment">// linxin</span></span><br></pre></td></tr></table></figure>
<p>bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数 func 中的 this 并没有被改变，依旧指向全局对象 window。</p>
<h4 id="2-参数的使用"><a href="#2-参数的使用" class="headerlink" title="2.参数的使用"></a>2.参数的使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func1 = func.bind(<span class="literal">null</span>,<span class="string">'linxin'</span>);</span><br><span class="line"></span><br><span class="line">func(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);            <span class="comment">// A B C</span></span><br><span class="line">func1(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>);           <span class="comment">// linxin A B</span></span><br><span class="line">func1(<span class="string">'B'</span>, <span class="string">'C'</span>);                <span class="comment">// linxin B C</span></span><br><span class="line">func.call(<span class="literal">null</span>, <span class="string">'linxin'</span>);      <span class="comment">// linxin undefined undefined</span></span><br></pre></td></tr></table></figure>
<p>call 是把第二个及以后的参数作为 func 方法的实参传进去，而 func1 方法的实参实则是在 bind 中参数的基础上再往后排。</p>
<p>在低版本浏览器没有 bind 方法，我们也可以自己实现一个。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Function</span>.prototype.bind) &#123;</span><br><span class="line">        <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> self = <span class="keyword">this</span>,                        <span class="comment">// 保存原函数</span></span><br><span class="line">                context = [].shift.call(<span class="built_in">arguments</span>), <span class="comment">// 保存需要绑定的this上下文</span></span><br><span class="line">                args = [].slice.call(<span class="built_in">arguments</span>);    <span class="comment">// 剩余的参数转为数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;                    <span class="comment">// 返回一个新函数</span></span><br><span class="line">                self.apply(context,[].concat.call(args, [].slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://github.com/lin-xin/blog/issues/7" target="_blank" rel="noopener">apply 、call 的详解</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown入门</title>
    <url>/2014/10/11/web/markdown-intro/</url>
    <content><![CDATA[<p>本文转载自一篇<a href="http://zipperary.com/2013/08/31/easy-markdown/" target="_blank" rel="noopener">轻松搞定Markdown</a>，简单实用，适合快速入门。</p>
<h2 id="Markdown-免费编辑器"><a href="#Markdown-免费编辑器" class="headerlink" title="Markdown 免费编辑器"></a>Markdown 免费编辑器</h2><p>Windows 平台<br><a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a><br><a href="http://code52.org/DownmarkerWPF/" target="_blank" rel="noopener">MarkPad</a></p>
<p>Linux 平台<br><a href="http://sourceforge.net/p/retext/home/ReText/" target="_blank" rel="noopener">ReText</a></p>
<p>Mac 平台<br><a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a></p>
<p>在线编辑器<br><a href="https://zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown</a>(推荐)</p>
<p>浏览器插件<br><a href="https://chrome.google.com/webstore/detail/oknndfeeopgpibecfjljjfanledpbkog" target="_blank" rel="noopener">MaDe</a> (Chrome)</p>
<h2 id="以下是Markdown代码"><a href="#以下是Markdown代码" class="headerlink" title="以下是Markdown代码"></a>以下是Markdown代码</h2><pre><code># 这里是一级标题
### 这里是三级标题
###### 这里是六级标题

最大为六级，木有七级！
段落前面没有缩进，看到了吧。

要想使用缩进，在中文输入法中改成「全角」输入，再按两个空格

行尾一个回车换行，显示效果依然是是一行。
我说的对吧~

想要分成两行，需要在行尾输入两个空格。  
我说的对吧~

想要开始一个新的段落，乖乖的按两下回车吧

我说的对吧~

**两个星号包围的是粗体**

*一个星号包围的是斜体*

&gt; 引用内容，多行的话，用两个空格结尾吧  
是吧~

`反引号包围的是行内代码`，这个按键在「Tab」上边

``嵌套的话，可以使用`两个双引号`嵌套在外面``

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#三个反引号包围的是代码块。</span></span><br><span class="line"><span class="comment">#会显示行号。</span></span><br><span class="line"><span class="comment">#也有高亮显示</span></span><br><span class="line"><span class="comment">#我上面加了python，你也可以不加。如果不能高亮，那么还是加上吧。。另外，如果你的代码块包</span></span><br><span class="line"></span><br><span class="line">围的是html，那你应该写html而不是python</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">print</span> os.sep</span><br></pre></td></tr></table></figure>
嵌套的话，可以使用六个反引号嵌套在外面。

1. 有序列表1，注意点之后的空格。
2. 有序列表2.
1. 我这里写成1，在显示时还是3，厉害不。

1. 有序列表1
 详细内容，注意前面有一个空格
2. 有序列表2
详细内容

- 无序列表1
- 无序列表2
- 无序列表3
 - 小1，注意前面有一个空格
 - 小2

超级链接：[我的博客](http://dongyeforever.github.io/)

插入图片：![好看不](http://ww2.sinaimg.cn/large/5e8cb366jw1e62o63tkv3j20dh078q5a.jpg)

另外，markdown完全兼容html，你可以用html插入这些东西，例如：

&lt;iframe height=498 width=510 src=&quot;http://v.youku.com/v_show/id_XNzU5Njk2MTk2.html&quot; frameborder=0 allowfullscreen&gt;&lt;/iframe&gt;


~~删除线~~


分割线用`---`，注意单独一样，上面必须是一个空行

---

更多高级的格式，请果断插入html标签
</code></pre><hr>
<h2 id="以下是实现效果"><a href="#以下是实现效果" class="headerlink" title="以下是实现效果"></a>以下是实现效果</h2><h1 id="这里是一级标题"><a href="#这里是一级标题" class="headerlink" title="这里是一级标题"></a>这里是一级标题</h1><h3 id="这里是三级标题"><a href="#这里是三级标题" class="headerlink" title="这里是三级标题"></a>这里是三级标题</h3><h6 id="这里是六级标题"><a href="#这里是六级标题" class="headerlink" title="这里是六级标题"></a>这里是六级标题</h6><p>最大为六级，木有七级！<br>段落前面没有缩进，看到了吧。</p>
<p>　　要想使用缩进，在中文输入法中改成「全角」输入，再按两个空格</p>
<p>行尾一个回车换行，显示效果依然是是一行。<br>我说的对吧~</p>
<p>想要分成两行，需要在行尾输入两个空格。<br>我说的对吧~</p>
<p>想要开始一个新的段落，乖乖的按两下回车吧</p>
<p>我说的对吧~</p>
<p><strong>两个星号包围的是粗体</strong></p>
<p><em>一个星号包围的是斜体</em></p>
<blockquote>
<p>引用内容，多行的话，用两个空格结尾吧<br>是吧~</p>
</blockquote>
<p><code>反引号包围的是行内代码</code>，这个按键在「Tab」上边</p>
<p><code>嵌套的话，可以使用`两个双引号`嵌套在外面</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#三个反引号包围的是代码块。</span></span><br><span class="line"><span class="comment">#会显示行号。</span></span><br><span class="line"><span class="comment">#也有高亮显示</span></span><br><span class="line"><span class="comment">#我上面加了python，你也可以不加。如果不能高亮，那么还是加上吧。。另外，如果你的代码块包围的是html，那你应该写html而不是python</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">print</span> os.sep</span><br></pre></td></tr></table></figure>
<p>嵌套的话，可以使用六个反引号嵌套在外面。</p>
<ol>
<li>有序列表1，注意点之后的空格。</li>
<li>有序列表2.</li>
<li><p>我这里写成1，在显示时还是3，厉害不。</p>
</li>
<li><p>有序列表1<br>详细内容，注意前面有一个空格</p>
</li>
<li>有序列表2<br>详细内容</li>
</ol>
<ul>
<li>无序列表1</li>
<li>无序列表2</li>
<li>无序列表3<ul>
<li>小1，注意前面有一个空格</li>
<li>小2</li>
</ul>
</li>
</ul>
<p>超级链接：<a href="http://dongyeforever.github.io/" target="_blank" rel="noopener">我的博客</a></p>
<p>插入图片：<img src="http://ww2.sinaimg.cn/large/5e8cb366jw1e62o63tkv3j20dh078q5a.jpg" alt="好看不"></p>
<p>另外，markdown完全兼容html，你可以用html插入这些东西。</p>
<p><del>删除线</del></p>
<p>分割线用<code>---</code>，注意单独一样，上面必须是一个空行</p>
<hr>
<p>更多高级的格式，请果断插入html标签</p>
<p>转载请注明出处：<a href="https://blog.lovek.vip/2014/10/11/markdown-intro/">https://blog.lovek.vip/2014/10/11/markdown-intro/</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>WePY - 小程序敏捷开发实践（演讲内容整理）</title>
    <url>/2018/09/19/web/miniprogram-wepy/</url>
    <content><![CDATA[<blockquote>
<p>龚澄，常用ID: Gcaufy，小程序开源框架 WePY 作者，热爱技术，热爱开源。于2015年加入腾讯，负责腾讯手机充值相关业务的开发。2018年加入微信支付，负责微信支付商户侧业务小程序的开发。  </p>
</blockquote>
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>本主题虽然在其它地方讲了很多次，但还是有非常多新内容。因为很多东西正在做或者想要做。本次分享主要分为以下几个部分：<br><img src="http://user-gold-cdn.xitu.io/2018/9/18/165eb7bc3d412f8d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="WePY-的介绍"><a href="#WePY-的介绍" class="headerlink" title="WePY 的介绍"></a>WePY 的介绍</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebcab769b9a68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="WePY-的用户"><a href="#WePY-的用户" class="headerlink" title="WePY 的用户"></a>WePY 的用户</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165eb7ea3b0d0d3c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>上面展示的 WePY 用户不是全部的数据。因为没有办法让 WePY 用户主动上报自己在使用 WePY，所以我只列了我知道的在使用 WePY 的公司，数据比较有限。<br>就我所知道的，最近有一个刷爆朋友圈的小程序 —— 腾讯疫苗，前端采用的 WePY，后端用了腾讯开源的 TARS 项目。微信支付内部也有大量小程序在使用 WePY 框架。<br>右边贴的聊天记录是我在 WePY 交流群收集到的用户反馈，就反馈的内容来看，有很多感谢的话，说明 WePY 这个框架确实能帮助开发者提高自己的开发效率。嘿嘿，我没有贴 WePY 的负面反馈，因为我担心一页 PPT 不够贴 👀。</p>
<h3 id="WePY-的数据"><a href="#WePY-的数据" class="headerlink" title="WePY 的数据"></a>WePY 的数据</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165eb883544e7d08?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>WePY 项目在 Github 上现在有13900多个 Star。拿其它前端框架对比，Vue、React 等 Star 数可能达到了 10W+，但是它们都是国际的项目。WePY 这个项目由于微信小程序的原因，算是一个国内项目，能有13000多个 Star 还是相当不错的。Star 数多不一定代表 WePY 这个框架好，但是能表明小程序这块流量很大，开发小程序也非常有前景。 开发者们需要 WePY 这样的框架来提供帮助。这也是为什么后来出现了 Taro、mpvue 等类似的非常优秀的框架。<br>issues 目前有1300多个。这意味着我每天起床都有超过10条 to-do list 需要处理。加上每天还有公司的其它事情需要处理，比较头大。<br>pull requests 目前有320多条。相比其它开源项目，这个 PR 数量相当不错，非常感谢为 WePY 作贡献的开发者们。<br>用户数有4000多。这个数据的来源我是统计的我建立的 WePY 交流群，目前这个交流群里有 4000 多人。</p>
<h3 id="WePY-是什么"><a href="#WePY-是什么" class="headerlink" title="WePY 是什么"></a>WePY 是什么</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165eb94203b4af67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>将 Web App 和小程序进行对比。Web App 和小程序在功能上类似， Web App 在开发的时候，可能使用 Vue.js 作为其核心库，用 Webpack 进行打包。在微信小程序中，大家可以简单的将 WePY 理解为 Web App 里的 Vue.js + Webpack 的合体。</p>
<h3 id="WePY-的特点"><a href="#WePY-的特点" class="headerlink" title="WePY 的特点"></a>WePY 的特点</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165eb9d4ede41709?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>WePY 在开发中到底帮助开发者做了什么事情呢？WePY 又有哪些特点呢？</p>
<ol>
<li>脚手架：它提供了一个相当于 vue-cli 的脚手架，一行命令生成简单的 demo 项目。用户可以基于这个 demo 进行开发，省去了启动项目前繁琐的配置。</li>
<li>编译打包：原生开发小程序缺失了许多能力，比如 LESS、SASS。很多用户面对这个问题都是做一个简单的 Gulp 编译。WePY 自带了编译打包能力，想用 LESS、SASS、NPM 等可以直接使用 WePY 的打包工具输出小程序可以运行的代码。</li>
<li>核心库：核心库类似 Vue、React 等。WePY 核心库包含一些简单的 API 封装帮助处理一些事情。</li>
<li>特性与优化：开发上，WePY 提供了一些语法糖，可以简单方便的实现一些复杂功能。性能上，小程序本身的性能有一些问题，WePY 把性能上的问题抹平了，开发者不用关心性能这部分。</li>
<li>复用与扩展：复用方面，原生小程序使用 npm 资源需要将相对应的资源下载并放到代码目录中，利用 WePY 可以直接安装 npm 包并使用。扩展方面，在编译过程中，可以随意添加和扩展编译手段，比如 LESS、SASS、编译插件等。</li>
<li>多端：利用 WePY 可以将一份代码运行在小程序、H5 等端。</li>
</ol>
<h3 id="WePY-的规划"><a href="#WePY-的规划" class="headerlink" title="WePY 的规划"></a>WePY 的规划</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebbd3f85a471f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>16年8月参加小程序内测，10月份开始着手代码转换相关的工作。在不停的迭代中，我发现还有很多事情可以做。比如可以将相关的工作抽象出来提供给其它开发者。于是在11月我对代码进行了重构，将 Gulp 编译部分抛弃重写并于 Github 开源1.1版本。<br>开源之后有很多人关注到这个项目，说明还是有不少人遇到了相应的问题。因此我做了更加具体的优化，在1.1版本上又一次重构，把编译流程抽象，提出了编译器和插件两个概念，方便用户进行扩展。<br>17年1月份发布1.4版本，对整个开发流程和开发者使用框架时的体验进行了更多优化，包括性能优化等。<br>1.6 版本开始考虑多端问题：小程序一套代码多端复用。<br>17年11月左右，小程序推出了原生组件。WePY 本身就是为了解决小程序组件的问题，原生组件发布之后，WePY 的使用场景就没有以前那么强了，所以我开始思考， WePY 需要做一个完全重构的版本。<br>18年2月份启动了该重构版本，这个版本主要是为了解决小程序原生组件相关的问题，是一个全新的重构版本。但由于各种原因，这个版本还没有正式公布。敬请期待！</p>
<h3 id="WePY-的实现原理"><a href="#WePY-的实现原理" class="headerlink" title="WePY 的实现原理"></a>WePY 的实现原理</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebca1e3b7517d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>接下来我会讲一下 WePY 在技术上的实现原理。</p>
<h3 id="WePY-解决的问题"><a href="#WePY-解决的问题" class="headerlink" title="WePY 解决的问题"></a>WePY 解决的问题</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebcbd118e0bcd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>任何一个项目都是发现问题，解决问题的过程，WePY 要解决的问题就是：</p>
<p>组件化开发：小程序原生组件出现之前，小程序没有很好的组件化开发模式。比如我自己实现了一套 dialog，别人想使用的时候可能要把我的代码拷贝一份。实现了组件化之后，我只要把这个组件给他就好了。<br>npm 资源：Web 发展至今，npm 库上有非常庞大的资源。但是原生小程序没有使用 npm 资源的能力，WePY 提供了这个功能。<br>前端工程化：前面提及的打包构建部分<br>性能优化<br>友好的开发体验：体验优化<br>跨平台支持：多端这部分</p>
<p>总的来说，WePY 解决的问题就是开发中遇到的痛点问题。</p>
<h3 id="WePY-的架构"><a href="#WePY-的架构" class="headerlink" title="WePY 的架构"></a>WePY 的架构</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebd69f1111861?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>上面是我写的两个核心的部分：CLI 以及 Core。Core 通过 CLI 编译，生成小程序端运行的代码。CLI 部分又分为 wepy、wepy-web ，分别负责 wepy 的编译和 wepy-web 的编译。其上又分为编译器和插件两部分，编译器涉及到目前主流的预处理器，类似 Webpack 的 loader 。插件是在编译之后要做的事情，类似于 Webpack 的 plugin。Core 部分分为 wepy 核心库、小程序核心库和 wepy-web 核心库。wepy-web 核心库比小程序多了 wepy components 和 wepy API 。小程序本身的一些内置组件，比如弹窗组件，想要多端运行都需要封装起来放在 wepy components 。小程序原生 API 需要通过 wepy API 封装。<br>web 本身还分很多平台种类，比如 browser、微信 h5、QQ h5，这些都需要分别适配，所以 wepy-web 之上是一个适配层。<br>整个 Core 之上，是用户封装的一些组件，比如上报、异步。还有一些功能组件，比如用户做的弹窗、toast、imageloader 等。<br>纵观整个 WePY，我的代码会通过 CLI 基于 Core 输出小程序端运行的代码。</p>
<h3 id="WePY-的编译过程"><a href="#WePY-的编译过程" class="headerlink" title="WePY 的编译过程"></a>WePY 的编译过程</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebe8aba423dbf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>WePY 本身定义了一个文件后缀 .wpy 。编译时将该文件解析并拆分为 Style、Template、Script。拆分时，会解析并记录组件关系，包括事件、引用等。每个节点的信息都会被记录，在注入时生成到 JS 中，在 JS 中就可以知道组件关系并进行调用。生成完之后进入到 plugin，plugin 是用户自定义的，需要进行图片压缩、JS 混淆、wxml 压缩等处理。依次做完这些处理之后才会得到可以在小程序中运行的代码。<br>以上就是 WePY 的整个编译过程。</p>
<h3 id="多端的实现"><a href="#多端的实现" class="headerlink" title="多端的实现"></a>多端的实现</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ebf90fc9413cb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>在实现多端方面，面临着以下问题：</p>
<ul>
<li><p>开发模式<br>小程序开发模式自成一派，与现有开发模式都不相同。好在使用 WePY 开发时，WePY 使用的是类 Vue 的开发语法，跟 Vue 开发模式很贴近，所以开发模式问题借助 WePY 非常好解决。</p>
</li>
<li><p>标签与样式<br>小程序与 H5 的标签不一样，但是可以直接做一些简单的转换处理。比如 <code>&lt;view&gt;</code>转换为<code>&lt;div&gt;</code>。样式上小程序有一个 rpx 单位，在 750 px 的情况下直接 /2 将 rpx 转为 px。</p>
</li>
<li><p>模版语法<br>小程序有自己的模版语法，比如<code>&lt;wx-if&gt;</code> 等，解析时可以做简单的转换。</p>
</li>
<li><p>模块化<br>小程序原生可以使用 require,但是H5不可以。好在有很多工具值得借鉴，比如 webpack,browserify。</p>
</li>
<li><p>内置组件及内置 API<br>WePY 本身使用的是类 Vue 的语法，要转换为 Vue 运行在 Web 端的话，内置组件直接使用 Vue 的形式编写，使用时直接引入这个 Vue 组件。内置 API 使用 WePY 提供的 JSSDK 去模拟微信端、H5等提供的 API。</p>
</li>
</ul>
<p>因此，多端实现完全可行。我们的一些项目完全利用 WePY 实现多端。</p>
<h3 id="生态"><a href="#生态" class="headerlink" title="生态"></a>生态</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec0d8bc897efa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>左边是在 Github 上看到的一些 UI 库，大家在使用 WePY 开发的时候可以直接利用这些 UI 库进行二次开发。右边是网上收集到的开发资源，包括开发组件、第三方模块等。Github 上 WePY 关键字搜索结果有900多页。从用户反馈来看，用户选择 WePY 的一个原因也是 WePY 诞生的时间长，生态比较完善。</p>
<h2 id="WePY-的规划-1"><a href="#WePY-的规划-1" class="headerlink" title="WePY 的规划"></a>WePY 的规划</h2><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec119bd2a171f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="现有问题"><a href="#现有问题" class="headerlink" title="现有问题"></a>现有问题</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec121d63c5b79?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>WePY 目前存在的核心问题是</p>
<ul>
<li><p>静态组件编译<br>WePY 项目做的比较仓促，花了大概一个多月就上线了。最开始只是为了解决组件化的问题。因此它采用了静态组件编译这套方案，在编译组件时，直接将我写的组件进行静态替换，将我写的组件注入到页面中，做了一些隔离相关的事情。这导致动态 repeat 时会出现比较严重的 BUG。这是设计上的缺陷，也是急需解决的问题。</p>
</li>
<li><p>语法解析<br>xml 的解析用了一个存在问题的库，导致 xml 解析时经常出错。js 的解析设计之初没有考虑用语法树解析，而是使用正则进行解析。因为目前仅涉及解析和语法注入，实现起来都比较简单，所以没有考虑用 AST 语法树进行解析，导致用户没有按照规范写的一些代码在解析时会出现错误。</p>
</li>
<li><p>类 Vue 语法<br>从用户的反馈来看，大家更希望用 Vue 的语法而不是类 Vue 语法。这两个之间还是有一些差异的。</p>
</li>
<li><p>数据绑定性能优化<br>数据绑定时做了一些优化和处理。但这些优化和处理是通过脏数据进行的，帮助用户减少 setDate 的次数。但是后来再看，这块还是有可以优化的空间。</p>
</li>
<li><p>错误处理机制<br>目前 WePY 的错误处理还比较简单，没有一个通用的错误处理机制。用户在使用和编译时的报错很难追溯和定位。后面希望能做到在报错时可以定位到报错的文件和代码。</p>
</li>
<li><p>测试用例覆盖度<br>WePY 目前只有核心库被测试用例覆盖。CLI 部分很复杂没有做测试用例覆盖。这导致目前大部分问题都和 CLI 相关。在下一个版本要全部被测试用例覆盖。</p>
</li>
</ul>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p><img src="" alt=""><br>上图是2.0版本编译部分的对比。左边是 1.0 的编译，右边是2.0正在做的事。前面有讲到1.0的编译是把.wpy 文件放到 CLI 中进行编译。CLI 本身涉及编译器和插件。在2.0中，将文件编译修改为了入口编译，从 App 入口，通过 CLI 自动解析依赖，CLI 中也只有插件，所有的核心功能都将通过插件实现。最后生成的除了小程序文件，还有 Vendor 文件（Vendor 文件是指所有的 npm 包都会打包到这个文件内）、资源文件以及自己引用的模块的文件。</p>
<h3 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec2dfca815f22?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>编译的核心部分是参考 Webpack 做的插件化编译。插件化的概念参考我上面做的图：固定一块板子，板子上有固定数量的挂钩，每个挂钩都可以挂不同的东西。每个挂钩放什么不清楚，但是每个挂钩都可以实现不同的功能。我只需要规定编译的流程，通过在挂钩中写不同的内容实现整个编译流程。所以整个编译过程变为：配置初始化➡️核心编译➡️输出文件。<br>插件化可以提供更高的扩展性和可复用性。所有的核心功能都依赖插件进行。用户觉得某个功能不合适的时候，完全可以自己写一个插件替换掉核心功能。用户可以对编译的任何一个环节进行修改。</p>
<h3 id="数据绑定v1"><a href="#数据绑定v1" class="headerlink" title="数据绑定v1"></a>数据绑定v1</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec34a84cbc20a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>v1 的数据绑定：在初始化的时候对数据进行深拷贝做数据备份。每个流程都会预置 apply 动作，比如有一个点击事件，点击事件对数据进行修改后进入到 apply 流程，在 apply 流程中进行深比较得到脏数据，脏数据最终进入到 setDate 中。<br>右边是比较简单易懂的图：小明对文件 B 进行修改得到 B+,老师将 B+ 和 B 进行对比，得到修改的数据。这是一个同步流程。当小明叫小红修改 C 文件时，如果老师不再，需要小红主动叫老师对 C 文件进行对比。即手动调用 apply 流程。</p>
<h3 id="数据绑定v2"><a href="#数据绑定v2" class="headerlink" title="数据绑定v2"></a>数据绑定v2</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec3a637663c78?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>2.0 使用了 Vue 的数据绑定机制。在初始化时生成 Render Watcher，每个数据初始化时都会添加 observer。修改数据时记录修改的 key-path 并加入队列中，所有的修改动作都会触发 Watcher。在一个 nextTick 时间内会清空队列，并在 Render Watcher 中进行 setDate。setDate 环节根据记录的 key-path 进行 setDate。<br>相比小明和老师的故事：小明在修改文件时会主动记录修改的内容并发起通知，小红的操作方式与小明一致。当老师收到通知时，根据小明、小红的修改记录对修改的内容进行 setDate 的处理。<br>这种优化方式不需要手动调用 apply,也不需要关心异步流程。</p>
<h3 id="质量"><a href="#质量" class="headerlink" title="质量"></a>质量</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec4205c039f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>第二个版本会先在内部项目运用，内部实践之后没有问题再开源。另外2.0版本测试用例覆盖度要完全覆盖。</p>
<h2 id="开源经验分享"><a href="#开源经验分享" class="headerlink" title="开源经验分享"></a>开源经验分享</h2><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec4447bcb5d69?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p>
<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec44c87bc3b6e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>如何保证开源项目的质量？<br>第一是文档规范。Readme 部分要言简意赅的讲明这个项目能做什么，一个简单的示例说明如何启动项目。Readme 要简洁，大家一眼能看到他想要的东西。<br>第二是 CI。将对应的状态放在 Readme，让开发者可以更安心的使用这个项目。<br>第三是 license。<br>还有 contributer 文档，代码规范、Git 规范等。<br><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec5669b9a174c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>测试使用了 Mocha 和 Istanbul，集成使用了 TravisCI，部署使用了 npm 和 lerna。</p>
<h3 id="推广运营"><a href="#推广运营" class="headerlink" title="推广运营"></a>推广运营</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec58b1c74debd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>推广运营方面主要靠自己发文章，做外链。另外我在公众号和微信群推了自己的文章。微信群做了一个机器人放入群码。<br>还做了文档监控，官方文档修改之后，我可以第一时间知道官方文档都修改了什么。以及监控报告，每天都会给我的微信推送今天项目有多少 star 、多少 issue 。</p>
<h3 id="后期维护"><a href="#后期维护" class="headerlink" title="后期维护"></a>后期维护</h3><p><img src="http://user-gold-cdn.xitu.io/2018/9/18/165ec5dbbe12e88f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""><br>后期维护主要是文档、issue、pr 和新的计划维护。右边的图，灰色部分是我没打标签的 issue。下面闭合的是我在相应时间点处理完的 issue，没有闭合表明这个 issue 还在处理中。</p>
<p>WePY 2.0 目前处于内测阶段，10月底会发布公测版本。</p>
<p>链接：<a href="http://juejin.im/post/5ba09fbc5188255c880ab4b0" target="_blank" rel="noopener">http://juejin.im/post/5ba09fbc5188255c880ab4b0</a><br>来源：掘金<br>著作权归作者所有。</p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>vue 3 组合式API</title>
    <url>/2020/10/27/web/vue3-composition-api/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>利用 Vite 创建 Vue3 项目</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init vite-app project-name (or yarn create vite-app project-name)</span><br><span class="line">cd project-name</span><br><span class="line">npm install (or `yarn`)</span><br><span class="line">npm run dev (or `yarn dev`)</span><br></pre></td></tr></table></figure>
<h3 id="组合式-API"><a href="#组合式-API" class="headerlink" title="组合式 API"></a>组合式 API</h3><p>当我们的组件变得更大时，用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有用到。然而，这可能会导致组件难以阅读和理解。如果我们能够将与同一个逻辑关注点相关的代码配置在一起会更好。而这正是组合式 API 使我们能够做到的。</p>
<h4 id="setup-组件选项"><a href="#setup-组件选项" class="headerlink" title="setup 组件选项"></a><code>setup</code> 组件选项</h4><p>在 Vue 组件中，使用组合式 API的位置为 <code>setup</code>。</p>
<blockquote>
<p>Setup() 在 beforeCreated() 之前执行。因此在 <code>setup</code> 选项中没有 <code>this</code>。这意味着，除了 <code>props</code> 之外，你将无法访问组件中声明的任何属性。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p ref&#x3D;&quot;p1&quot;&gt;&#123;&#123; obj &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;p&gt;&#123;&#123; age &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;button @click&#x3D;&quot;myClick&quot;&gt;按钮&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref&#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    const obj &#x3D; &#123;name: &#39;zs&#39;, age: 18&#125;</span><br><span class="line">    const age &#x3D; ref(18)</span><br><span class="line"></span><br><span class="line">    function myClick() &#123;</span><br><span class="line">      age.value++</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;obj, age, myClick&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="setup内部生命周期钩子"><a href="#setup内部生命周期钩子" class="headerlink" title="setup内部生命周期钩子"></a><code>setup</code>内部生命周期钩子</h4><p>这些函数接受在组件调用钩子时将执行的回调。让我们将其添加到 <code>setup</code> 函数中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref, onMounted&#125; from &quot;vue&quot;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    let p1 &#x3D; ref(null)</span><br><span class="line"></span><br><span class="line">    onMounted(() &#x3D;&gt; &#123;</span><br><span class="line">      console.log(&#39;onMounted&#39;, p1.value) &#x2F;&#x2F;&lt;p&gt;&#123;&quot;name&quot;: &quot;zs&quot;, &quot;age&quot;: 18&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &#125;)</span><br><span class="line">    return &#123; p1 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="响应式变量"><a href="#响应式变量" class="headerlink" title="响应式变量"></a>响应式变量</h4><h5 id="带-ref-的响应式变量"><a href="#带-ref-的响应式变量" class="headerlink" title="带 ref 的响应式变量"></a>带 <code>ref</code> 的响应式变量</h5><p>在 Vue 3.0 中，我们可以通过一个新的 <code>ref</code> 函数使任何响应式变量在任何地方起作用，如下所示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ref&#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"><span class="keyword">const</span> age = ref(<span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(age) <span class="comment">// &#123; value: 18 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(age.value) <span class="comment">// 18</span></span><br><span class="line"><span class="comment">// 更新数据</span></span><br><span class="line">age.value = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h5 id="带-reactive-的响应式变量"><a href="#带-reactive-的响应式变量" class="headerlink" title="带 reactive 的响应式变量"></a>带 <code>reactive</code> 的响应式变量</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;reactive&#125; <span class="keyword">from</span> <span class="string">"vue"</span></span><br><span class="line"></span><br><span class="line">setup() &#123;</span><br><span class="line">  <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    time: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">myClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    state.time?.setDate(state.time.getDate() + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ref 与 reactive 的区别：</p>
<ul>
<li><p>reactive 必须传递一个对象，ref 底层本质是 reactive。</p>
<p>ref(xx) –&gt; reactive({value: xx})</p>
</li>
<li><p>在 js 中 ref 的值必须通过 value 获取。</p>
</li>
</ul>
</blockquote>
<h5 id="watch-响应式更改"><a href="#watch-响应式更改" class="headerlink" title="watch 响应式更改"></a><code>watch</code> 响应式更改</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, watch &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line">watch(counter, (newValue, oldValue) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'The new counter value is: '</span> + counter.value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>以下是等效的选项式 API：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      counter: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    counter(newValue, oldValue) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The new counter value is: '</span> + <span class="keyword">this</span>.counter)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="独立的-computed-属性"><a href="#独立的-computed-属性" class="headerlink" title="独立的 computed 属性"></a>独立的 <code>computed</code> 属性</h5><p>与 <code>ref</code> 和 <code>watch</code> 类似，也可以使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性。让我们回到我们的 counter 例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, computed &#125; <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> counter = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> twiceTheCounter = computed(<span class="function"><span class="params">()</span> =&gt;</span> counter.value * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">counter.value++</span><br><span class="line"><span class="built_in">console</span>.log(counter.value) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(twiceTheCounter.value) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>常用 markdown 格式</title>
    <url>/2021/02/23/web/%E5%B8%B8%E7%94%A8md%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<h4 id="常用格式"><a href="#常用格式" class="headerlink" title="常用格式"></a>常用格式</h4><h5 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 一级标题</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 二级标题</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">##### 六级标题，最大为六级</span></span></span><br></pre></td></tr></table></figure>
<h5 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h5><ul>
<li>无序列表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- Microsoft</span><br><span class="line">- Google</span><br><span class="line">- Apple</span><br><span class="line">  - iPhone</span><br><span class="line">  - iPad</span><br></pre></td></tr></table></figure>
<ul>
<li>有序列表</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. Microsoft // 序号后加一个空格</span><br><span class="line">2. Google</span><br><span class="line">3. Apple</span><br></pre></td></tr></table></figure>
<h5 id="强调和引用"><a href="#强调和引用" class="headerlink" title="强调和引用"></a>强调和引用</h5><ul>
<li>强调，<code>反引号包围的内容</code>会高亮显示。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">`反引号包围的内容`会高亮显示。</span><br><span class="line">``嵌套的话，可以使用`两个双引号`嵌套在外面``</span><br></pre></td></tr></table></figure>
<ul>
<li>引用</li>
</ul>
<p>使用<code>&gt;</code>符号，如果引用有多行，每行前面都加<code>&gt;</code> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 引用内容</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 注意事项</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 多行引用</span></span><br></pre></td></tr></table></figure>
<h5 id="粗体、斜体"><a href="#粗体、斜体" class="headerlink" title="粗体、斜体"></a>粗体、斜体</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">**两个星号包围的是粗体**</span><br><span class="line">*一个星号包围的是斜体*</span><br></pre></td></tr></table></figure>
<h5 id="删除线、分隔线"><a href="#删除线、分隔线" class="headerlink" title="删除线、分隔线"></a>删除线、分隔线</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">~~删除线~~</span><br><span class="line"></span><br><span class="line">分割线用`---`，注意单独一行，上面必须是一个空行</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h5 id="图片、超链接"><a href="#图片、超链接" class="headerlink" title="图片、超链接"></a>图片、超链接</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">图片格式：![腾讯网](https://mat1.gtimg.com/pingjs/ext2020/qqindex2018/dist/img/qq_logo_2x.png)</span><br><span class="line"></span><br><span class="line">超链接格式：[腾讯网](https://www.qq.com/)</span><br></pre></td></tr></table></figure>
<h5 id="CheckBox"><a href="#CheckBox" class="headerlink" title="CheckBox"></a>CheckBox</h5><p>可勾选的复选框。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">- [ ] 内容  // 注意空格</span><br><span class="line">- [x] 勾选内容</span><br></pre></td></tr></table></figure>
<h5 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h5><p>以 ```语言 开头，以 ``` 结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;<span class="name">title</span>&gt;</span>百度一下<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="预览效果"><a href="#预览效果" class="headerlink" title="预览效果"></a>预览效果</h4><hr>
<ul>
<li>Microsoft</li>
<li>Google</li>
<li>Apple<ul>
<li>iPhone</li>
<li>iPad</li>
</ul>
</li>
</ul>
<ol>
<li>Microsoft // 序号后加一个空格</li>
<li>Google</li>
<li>Apple</li>
</ol>
<p><code>反引号包围的内容</code>会高亮显示。<br><code>嵌套的话，可以使用`两个双引号`嵌套在外面</code></p>
<blockquote>
<p>引用内容<br>注意事项<br>多行引用</p>
</blockquote>
<p><strong>两个星号包围的是粗体</strong><br><em>一个星号包围的是斜体</em></p>
<p><del>删除线</del></p>
<p>图片格式：<img src="https://mat1.gtimg.com/pingjs/ext2020/qqindex2018/dist/img/qq_logo_2x.png" alt="腾讯网"></p>
<p>超链接格式：<a href="https://www.qq.com/" target="_blank" rel="noopener">腾讯网</a></p>
<ul>
<li style="list-style: none"><input type="checkbox"></input> 内容  // 注意空格</li>
<li style="list-style: none"><input type="checkbox" checked></input> 勾选内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>从图像提取主色</title>
    <url>/2020/10/14/web/background-color/</url>
    <content><![CDATA[<p>在web开发中有一个需求，可以根据图片内容动态提取主色改变背景颜色。满足需求的常用第三方库有<code>node-vibrant</code>，<code>rgbaster</code>，<code>Color Thief</code></p>
<h3 id="1-node-vibrant"><a href="#1-node-vibrant" class="headerlink" title="1.  node-vibrant"></a>1.  node-vibrant</h3><h5 id="添加依赖库"><a href="#添加依赖库" class="headerlink" title="添加依赖库"></a>添加依赖库</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"node-vibrant": "^3.1.5",</span><br></pre></td></tr></table></figure>
<h5 id="导入import"><a href="#导入import" class="headerlink" title="导入import"></a>导入import</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Vibrant <span class="keyword">from</span> <span class="string">'node-vibrant'</span></span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getColor() &#123;</span><br><span class="line">  <span class="keyword">const</span> imageUrl = <span class="keyword">this</span>.state.mediaCover</span><br><span class="line">  Vibrant.from(imageUrl)</span><br><span class="line">    .getPalette()</span><br><span class="line">    .then(<span class="function">(<span class="params">palette</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(palette)</span><br><span class="line">    	<span class="comment">// Vibrant：充满活力的</span></span><br><span class="line">    	<span class="comment">// LightVibrant：</span></span><br><span class="line">    	<span class="comment">// DarkVibrant：</span></span><br><span class="line">    	<span class="comment">// LightMuted：</span></span><br><span class="line">    </span><br><span class="line">    	<span class="comment">// 找到最匹配颜色</span></span><br><span class="line">    	<span class="keyword">this</span>.findBestColor()  </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findBestColor() &#123;</span><br><span class="line">  <span class="keyword">let</span> maxPopulation = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> maxKey</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> palette) &#123;</span><br><span class="line">    <span class="keyword">if</span> (palette.hasOwnProperty(key) &amp;&amp; maxPopulation &lt; palette[key].population) &#123;</span><br><span class="line">      maxPopulation = palette[key].population</span><br><span class="line">      maxKey = key</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> imgColor = palette[maxKey]</span><br><span class="line">  <span class="keyword">this</span>.handleImgColor(imgColor)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正为可视性颜色</span></span><br><span class="line">handleImgColor = <span class="function">(<span class="params">imgColor</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 若0≤S1&lt;20 ，则S1=20；若20≤S1≤70 ，则S2=S1；若70＜S1≤100 ，则S2=70</span></span><br><span class="line">  <span class="comment">// 若0≤L1&lt;20 ，则L2=20；若20≤L1≤50 ，则L2=L1；若50＜L1≤100 ，则L2=50</span></span><br><span class="line">  <span class="keyword">const</span> imgHsl = imgColor._hsl</span><br><span class="line">  <span class="keyword">const</span> s = imgHsl[<span class="number">1</span>] &lt; <span class="number">0.2</span> ? <span class="number">0.2</span> : (imgHsl[<span class="number">1</span>] &gt; <span class="number">0.7</span> ? <span class="number">0.7</span> : imgHsl[<span class="number">1</span>])</span><br><span class="line">  <span class="keyword">const</span> l = imgHsl[<span class="number">2</span>] &lt; <span class="number">0.2</span> ? <span class="number">0.2</span> : (imgHsl[<span class="number">2</span>] &gt; <span class="number">0.5</span> ? <span class="number">0.5</span> : imgHsl[<span class="number">2</span>])</span><br><span class="line">  <span class="keyword">const</span> newHsl = Vibrant.Util.hslToRgb(imgHsl[<span class="number">0</span>], s, l)</span><br><span class="line">  <span class="keyword">const</span> r = newHsl[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">const</span> g = newHsl[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> b = newHsl[<span class="number">2</span>]</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    bgColor: Vibrant.Util.rgbToHex(r, g, b)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-rgbaster-js"><a href="#2-rgbaster-js" class="headerlink" title="2. rgbaster.js"></a>2. rgbaster.js</h3><h5 id="添加依赖库-1"><a href="#添加依赖库-1" class="headerlink" title="添加依赖库"></a>添加依赖库</h5><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"rgbaster": "^2.1.1"</span><br></pre></td></tr></table></figure>
<h5 id="导入import-1"><a href="#导入import-1" class="headerlink" title="导入import"></a>导入import</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> rgbaster <span class="keyword">from</span> <span class="string">'rgbaster'</span></span><br></pre></td></tr></table></figure>
<h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> imageUrl = song.picture</span><br><span class="line">rgbaster(imageUrl, &#123;</span><br><span class="line">  ignore: [<span class="string">'rgb(255,255,255)'</span>, <span class="string">'rgb(0,0,0)'</span>],  <span class="comment">// 要忽略识别的颜色</span></span><br><span class="line">  scale: <span class="number">0.5</span> <span class="comment">// 查询时缩小图片，降低精度换取识别速度提高</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> imgColor = res[<span class="number">0</span>].color</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    bgColor: imgColor</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>参考文章:</p>
<p><a href="https://cloud.tencent.com/developer/article/1132389" target="_blank" rel="noopener">前端图片主题色提取</a></p>
<p><a href="http://y.qq.com/m/demo/2018/magic_color.html" target="_blank" rel="noopener">魔法色预览工具</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>北京巴士操作指南</title>
    <url>/2019/03/14/web/bus-miniprogram-intro/</url>
    <content><![CDATA[<h3 id="如何添加公交路线"><a href="#如何添加公交路线" class="headerlink" title="如何添加公交路线"></a>如何添加公交路线</h3><p>小程序首页头部展示的是当前位置的天气情况，包括实时温度和空气质量。天气下面的搜索框就是添加公交路线的入口。点击搜索框跳转到【添加公交路线】页面。<br><img src="/images/bus_1.webp" alt=""></p>
<p>输入你要添加的公交路线，如101，或者专101等…系统会匹配出相关公交路线。<br><img src="/images/bus_w.webp" alt=""></p>
<p>点击公交路线，跳转到【选择行车方向】页面。点击你要查询公交的方向<br><img src="/images/bus_3.webp" alt=""></p>
<p>同理点击公交行车方向后，跳转到【选择上车站】页面。这里点击你要乘坐公交的上车站即可。</p>
<p><img src="/images/bus_4.webp" alt=""><br><img src="/images/bus_5.webp" alt=""></p>
<p>添加完公交路线后，系统会自动保存您的乘车路线到首页列表，方便您下次快速选择。</p>
<h3 id="如何分享给好友"><a href="#如何分享给好友" class="headerlink" title="如何分享给好友"></a>如何分享给好友</h3><p>有两种方式分享小程序。</p>
<p>一是和所有微信小程序一样，可以通过点击右上角【···】按钮，选择弹出菜单中的转发；</p>
<p>二是在实时公交详情页面，点击分享按钮即可发送给微信好友。</p>
<p>希望大家多转发一下~~ 方便您的家人和朋友~~</p>
<p><em>-end-</em></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>git 知识点</title>
    <url>/2021/04/20/server/elk/</url>
    <content><![CDATA[<h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><p>elastic search 安装</p>
<h6 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 下载</span><br><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">tar -zxvf elasticsearch-7.12.0-linux-x86_64.tar.gz</span><br><span class="line">sudo mv elasticsearch-7.12.0 /usr/local/elasticsearch</span><br></pre></td></tr></table></figure>
<h6 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h6><p>修改 <code>config</code> 目录下 <code>elasticsearch.yml</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">去掉行开头的</span> <span class="comment"># 并重命名集群名，这里命名为 my-el</span></span><br><span class="line"><span class="string">cluster.name:</span> <span class="string">my-el</span></span><br><span class="line"><span class="string">node.name:</span> <span class="string">node-1</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">可以使用ip地址访问</span></span><br><span class="line"><span class="string">network.host:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="string">node.data</span> <span class="string">:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">discovery.seed_hosts</span> <span class="string">:</span> <span class="string">[]</span></span><br><span class="line"><span class="string">cluster.initial_master_nodes</span> <span class="string">:</span> <span class="string">["node-1"]</span></span><br></pre></td></tr></table></figure>
<p>启动之后测试是否正常运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./elasticsearch -d</span><br><span class="line"></span><br><span class="line">curl 127.0.0.1:9200</span><br></pre></td></tr></table></figure>
<p>返回</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">name: "node-1",</span><br><span class="line">cluster_name: "my-el",</span><br><span class="line">cluster_uuid: "MmEwssVBQUqOzbT5GNkq9g",</span><br><span class="line">version: &#123;</span><br><span class="line">number: "7.12.0",</span><br><span class="line">build_flavor: "default",</span><br><span class="line">build_type: "tar",</span><br><span class="line">build_hash: "78722783c38caa25a70982b5b042074cde5d3b3a",</span><br><span class="line">build_date: "2021-03-18T06:17:15.410153305Z",</span><br><span class="line">build_snapshot: false,</span><br><span class="line">lucene_version: "8.8.0",</span><br><span class="line">minimum_wire_compatibility_version: "6.8.0",</span><br><span class="line">minimum_index_compatibility_version: "6.0.0-beta1"</span><br><span class="line">&#125;,</span><br><span class="line">tagline: "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p> root 用户无法启动？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果是 root 用户，需要切换到普通账号或者新建 ES 账号</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> groupadd elasticsearch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> useradd -g elasticsearch elasticsearch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chown -R elasticsearch:elasticsearch elasticsearch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> su elasticsearch</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>内存不足？</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure>
<h5 id="elasticsearch-head"><a href="#elasticsearch-head" class="headerlink" title="elasticsearch-head"></a>elasticsearch-head</h5><p>安装 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone git://github.com/mobz/elasticsearch-head.git</span><br><span class="line">cd elasticsearch-head</span><br><span class="line">npm install</span><br><span class="line">npm run start</span><br><span class="line">open http://localhost:9100/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>跨域问题：Access to XMLHttpRequest at ‘<a href="http://xx.xx:9200/_stats&#39;" target="_blank" rel="noopener">http://xx.xx:9200/_stats&#39;</a> from origin ‘<a href="http://localhost:9100&#39;">http://localhost:9100&#39;</a> has been blocked by CORS policy</p>
</blockquote>
<p>修改<code>elasticsearch.yml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cors</span></span><br><span class="line"><span class="string">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">http.cors.allow-origin:</span> <span class="string">"*"</span></span><br></pre></td></tr></table></figure>
<h5 id="elastic-search-使用"><a href="#elastic-search-使用" class="headerlink" title="elastic search 使用"></a>elastic search 使用</h5><p><code>index</code>MySQL<code>database</code>概念，一个index就是一个数据库。</p>
<p><code>type</code>相当于MySQL中table的概念，一个type就是一个表。这个会在8.x废弃掉。</p>
<p><code>document</code>即文档，相当于MySQL中的一条数据，ES的数据类似于Mongo，如<code>[&quot;name&quot;: &quot;qii404&quot;, &quot;age&quot;: 23]</code>。我们通过<strong>复合查询</strong>功能框模拟Curl请求实现。</p>
<p><img src="https://ww1.sinaimg.cn/large/a489ef7dly1gpk44mombdj20x209un39.jpg" alt="image-20210415081505191"></p>
<blockquote>
<p>类型名称 8.X 会废弃，使用默认的 <code>_doc</code>。</p>
</blockquote>
<h6 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h6><ul>
<li>创建索引及对应的字段类型，相当于MySQL建表。</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT video_index2</span><br><span class="line">&#123;<span class="attr">"mappings"</span>:&#123;<span class="attr">"properties"</span>:&#123;<span class="attr">"name"</span>:&#123;<span class="attr">"type"</span>:<span class="string">"text"</span>&#125;,<span class="attr">"age"</span>:&#123;<span class="attr">"type"</span>:<span class="string">"long"</span>&#125;,<span class="attr">"birthday"</span>:&#123;<span class="attr">"type"</span>:<span class="string">"date"</span>&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>旧版写法：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT 索引名/~类型名~/文档id</span><br><span class="line">PUT video_index2/user/1 # 创建索引（type为user）并添加数据</span><br><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Rui"</span>, <span class="attr">"age"</span>: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>put 可以用来修改文档。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT video_index/user/1 # 修改age为3，同时会删除name属性</span><br><span class="line">&#123;"age": 3&#125;</span><br></pre></td></tr></table></figure>
<h6 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h6><p>更新 <code>name</code> 字段的值。每次修改 <code>version</code>会加1。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST video_index2/_doc/1/_update</span><br><span class="line">&#123;<span class="attr">"doc"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"Rui123"</span>&#125;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>更新建议用 POST xxx/_update ，避免 PUT 更新造成字段丢失。</p>
</blockquote>
<h6 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 删除索引</span><br><span class="line">DELETE video_index2/</span><br><span class="line">// 删除文档</span><br><span class="line">DELETE video_index2/_doc/1</span><br></pre></td></tr></table></figure>
<h6 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">// 得到索引信息</span><br><span class="line">GET video_index</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search?q=name:Rui</span><br><span class="line">// 等价于</span><br><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"Rui"</span>&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_source</code>指定过滤输出字段。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"Rui"</span>&#125;&#125;,</span><br><span class="line">  <span class="attr">"_source"</span>: [<span class="string">"name"</span>, <span class="string">"birthday"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sort</code>根据字段排序</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"Rui"</span>&#125;&#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [&#123;<span class="attr">"age"</span>: &#123;<span class="attr">"order"</span>: <span class="string">"desc"</span>&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>from</code> 和<code>size</code>分页</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>: &#123;<span class="attr">"match"</span>: &#123; <span class="attr">"name"</span>: <span class="string">"Rui"</span>&#125;&#125;,</span><br><span class="line">  <span class="attr">"sort"</span>: [&#123;<span class="attr">"age"</span>: &#123;<span class="attr">"order"</span>: <span class="string">"desc"</span>&#125;&#125;],</span><br><span class="line">  <span class="attr">"from"</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">"size"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>must</code> (and)  所有条件都要符合，where id = 1 and name = zhangsan</p>
<p><code>should</code>（or）where  name = xx  or age = 18</p>
<p><code>must_not</code>(not)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;<span class="attr">"query"</span>:&#123;<span class="attr">"bool"</span>:&#123;<span class="attr">"should"</span>:[&#123;<span class="attr">"match"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"Rui"</span>&#125;&#125;,&#123;<span class="attr">"match"</span>:&#123;<span class="attr">"age"</span>:<span class="number">18</span>&#125;&#125;]&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;<span class="attr">"query"</span>:&#123;<span class="attr">"bool"</span>:&#123;<span class="attr">"must"</span>:[&#123;<span class="attr">"match"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"Rui"</span>&#125;&#125;,&#123;<span class="attr">"match"</span>:&#123;<span class="attr">"age"</span>:<span class="number">18</span>&#125;&#125;]&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p><code>filter</code>过滤</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;<span class="attr">"query"</span>:&#123;<span class="attr">"bool"</span>:&#123;<span class="attr">"filter"</span>:&#123;<span class="attr">"range"</span>:&#123;<span class="attr">"age"</span>:&#123;<span class="attr">"gt"</span>:<span class="number">18</span>&#125;&#125;&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>gt/gte 大于/大于等于</li>
<li>lt/lte 小于/小于等于</li>
<li>eq 等于</li>
</ul>
<p>基础语法说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">关键词</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">match_all</td>
<td style="text-align:left">查询简单的 匹配所有文档。在没有指定查询方式时，它是默认的查询</td>
</tr>
<tr>
<td style="text-align:left">match</td>
<td style="text-align:left">用于全文搜索或者精确查询，如果在一个精确值的字段上使用它， 例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值</td>
</tr>
<tr>
<td style="text-align:left">range</td>
<td style="text-align:left">查询找出那些落在指定区间内的数字或者时间 gt 大于；gte 大于等于；lt 小于；lte 小于等于</td>
</tr>
<tr>
<td style="text-align:left">term</td>
<td style="text-align:left">被用于精确值 匹配</td>
</tr>
<tr>
<td style="text-align:left">terms</td>
<td style="text-align:left">terms 查询和 term 查询一样，但它允许你指定多值进行匹配</td>
</tr>
<tr>
<td style="text-align:left">exists</td>
<td style="text-align:left">查找那些指定字段中有值的文档</td>
</tr>
<tr>
<td style="text-align:left">missing</td>
<td style="text-align:left">查找那些指定字段中无值的文档</td>
</tr>
<tr>
<td style="text-align:left">must</td>
<td style="text-align:left">多组合查询 必须匹配这些条件才能被包含进来</td>
</tr>
<tr>
<td style="text-align:left">must_not</td>
<td style="text-align:left">多组合查询 必须不匹配这些条件才能被包含进来</td>
</tr>
<tr>
<td style="text-align:left">should</td>
<td style="text-align:left">多组合查询 如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分</td>
</tr>
<tr>
<td style="text-align:left">filter</td>
<td style="text-align:left">多组合查询 这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档</td>
</tr>
</tbody>
</table>
<h6 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h6><figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;<span class="attr">"query"</span>:&#123;<span class="attr">"match"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"qi"</span>&#125;&#125;,<span class="attr">"highlight"</span>:&#123;<span class="attr">"fields"</span>:&#123;<span class="attr">"name"</span>:&#123;&#125;&#125;&#125;&#125;</span><br><span class="line"></span><br><span class="line">// 返回结果</span><br><span class="line">"highlight":&#123;</span><br><span class="line">    "name":[</span><br><span class="line">        <span class="string">"&lt;em&gt;qi&lt;/em&gt;"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">GET video_index/_doc/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"query"</span>:&#123;<span class="attr">"match"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"qi"</span>&#125;&#125;,</span><br><span class="line">  <span class="attr">"highlight"</span>: &#123;</span><br><span class="line">    <span class="attr">"pre_tags"</span>: <span class="string">"&lt;span class='key' style='color:red'&gt;"</span>,</span><br><span class="line">    <span class="attr">"post_tags"</span>: <span class="string">"&lt;/span&gt;"</span>,</span><br><span class="line">    <span class="attr">"fields"</span>: &#123;</span><br><span class="line">      <span class="attr">"name"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回结果</span><br><span class="line">"highlight":&#123;</span><br><span class="line">    "name":[</span><br><span class="line">        &lt;span class='key' style='color:red'&gt;qi&lt;/span&gt;"</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ik-分词器"><a href="#ik-分词器" class="headerlink" title="ik 分词器"></a>ik 分词器</h5><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.12.0" target="_blank" rel="noopener">https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v7.12.0</a></p>
<p>复制到 <code>elasticsearch/plugins/</code>目录下，重启<code>elasticsearch</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 出现加载插件的 log</span><br><span class="line">[INFO ][o.e.p.PluginsService     ] [node-1] loaded plugin [analysis-ik]</span><br></pre></td></tr></table></figure>
<p><code>ik_smart</code> 最小粒度划分  <code>ik_max_word</code> 最细粒度划分。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>:<span class="string">"ik_smart"</span>,</span><br><span class="line">    <span class="attr">"text"</span>:<span class="string">"中华人民"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokens"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>:<span class="string">"中华人民"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>:<span class="number">7</span>,</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">POST _analyze</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"analyzer"</span>:<span class="string">"ik_max_word"</span>,</span><br><span class="line">    <span class="attr">"text"</span>:<span class="string">"中华人民"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"tokens"</span>:[</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>:<span class="string">"中华人民"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>:<span class="number">7</span>,</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>:<span class="number">0</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>:<span class="string">"中华"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>:<span class="number">0</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>:<span class="number">2</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>:<span class="string">"华人"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>:<span class="number">1</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>:<span class="number">3</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"token"</span>:<span class="string">"人民"</span>,</span><br><span class="line">            <span class="attr">"start_offset"</span>:<span class="number">2</span>,</span><br><span class="line">            <span class="attr">"end_offset"</span>:<span class="number">4</span>,</span><br><span class="line">            <span class="attr">"type"</span>:<span class="string">"CN_WORD"</span>,</span><br><span class="line">            <span class="attr">"position"</span>:<span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义词典：编辑<code>config/IKAnalyzer.cfg.xml</code>文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"ext_dict"</span>&gt;</span>my.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于分词</p>
</blockquote>
<ul>
<li>match 会根据分词器分词解析并进行查询。</li>
<li>term 查询直接通过倒排索引指定词条精确匹配。</li>
</ul>
<blockquote>
<p>两个类型</p>
</blockquote>
<ul>
<li>keyword 不会被分词器解析</li>
<li>text 可以被分词器解析</li>
</ul>
]]></content>
  </entry>
</search>
