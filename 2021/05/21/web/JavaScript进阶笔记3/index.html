<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.lovek.vip","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="5. 对象5.1 创建对象在 JavaScript 中，对象是一系列无序属性的集合，属性值可以为基本数据类型，对象或者函数，因此，对象实际就是一组键值对的组合。 123456789101112131415&#x2F;&#x2F; 对象let person &#x3D; &amp;#123;  &#x2F;&#x2F; 基本数据类型的属性  name: &#39;张三&#39;,  age: 28,  &#x2F;&#x2F; 函数类型的属性  sayName: function() &amp;#1">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript进阶笔记3">
<meta property="og:url" content="http://blog.lovek.vip/2021/05/21/web/JavaScript%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B03/index.html">
<meta property="og:site_name" content="Rui&#39;s blog">
<meta property="og:description" content="5. 对象5.1 创建对象在 JavaScript 中，对象是一系列无序属性的集合，属性值可以为基本数据类型，对象或者函数，因此，对象实际就是一组键值对的组合。 123456789101112131415&#x2F;&#x2F; 对象let person &#x3D; &amp;#123;  &#x2F;&#x2F; 基本数据类型的属性  name: &#39;张三&#39;,  age: 28,  &#x2F;&#x2F; 函数类型的属性  sayName: function() &amp;#1">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s2.loli.net/2021/12/09/e7yRJjgVv5lwBzK.jpg">
<meta property="article:published_time" content="2021-05-21T11:00:00.000Z">
<meta property="article:modified_time" content="2022-02-25T02:47:36.580Z">
<meta property="article:author" content="Rui">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2021/12/09/e7yRJjgVv5lwBzK.jpg">

<link rel="canonical" href="http://blog.lovek.vip/2021/05/21/web/JavaScript%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B03/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JavaScript进阶笔记3 | Rui's blog</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-76853415-1"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-76853415-1');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Rui's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">恰同学少年</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://blog.lovek.vip/2021/05/21/web/JavaScript%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/author.jpg">
      <meta itemprop="name" content="Rui">
      <meta itemprop="description" content="简单即是美">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rui's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript进阶笔记3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-05-21 19:00:00" itemprop="dateCreated datePublished" datetime="2021-05-21T19:00:00+08:00">2021-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-02-25 10:47:36" itemprop="dateModified" datetime="2022-02-25T10:47:36+08:00">2022-02-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="5-对象"><a href="#5-对象" class="headerlink" title="5. 对象"></a>5. 对象</h3><h4 id="5-1-创建对象"><a href="#5-1-创建对象" class="headerlink" title="5.1 创建对象"></a>5.1 创建对象</h4><p>在 JavaScript 中，对象是一系列无序属性的集合，属性值可以为基本数据类型，对象或者函数，因此，对象实际就是一组键值对的组合。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象</span></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="comment">// 基本数据类型的属性</span></span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  <span class="comment">// 函数类型的属性</span></span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 对象类型的属性</span></span><br><span class="line">  address: &#123;</span><br><span class="line">    name: <span class="string">'上海'</span>,</span><br><span class="line">    code: <span class="string">'10000'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象作为数据存储的最直接有效的方式，具有非常高的使用频率，接下来总结 JavaScript 中创建对象的 7 种方式。</p>
<h5 id="5-1-1-基于-Object-构造函数"><a href="#5-1-1-基于-Object-构造函数" class="headerlink" title="5.1.1 基于 Object() 构造函数"></a>5.1.1 基于 Object() 构造函数</h5><p>通过 Object() 对象的构造函数生成一个实例，然后给他们增加需要的各种属性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object() 构造函数生成实例</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="comment">// 为实例新增各种属性</span></span><br><span class="line">person.name = <span class="string">'张三'</span></span><br><span class="line">person.age = <span class="number">28</span></span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">person.address = &#123;</span><br><span class="line">  name: <span class="string">'上海'</span>,</span><br><span class="line">  code: <span class="string">'10000'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-1-2-基于对象字面量"><a href="#5-1-2-基于对象字面量" class="headerlink" title="5.1.2 基于对象字面量"></a>5.1.2 基于对象字面量</h5><p>对象字面量本身就是一系列键值对的组合，每个属性直接通过逗号分隔。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;,</span><br><span class="line">  address: &#123;</span><br><span class="line">    name: <span class="string">'上海'</span>,</span><br><span class="line">    code: <span class="string">'10000'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法和 5.1.1 创建对象具有相同的优点：简单，容易理解，但是对象的属性值通过对象自身进行设置，如果需要同时创建若干个属性相同，而只是属性值不同的对象时，则会产生很多重复代码。因此不推荐使用批量创建对象。</p>
<h5 id="5-1-3-基于工厂方法模式"><a href="#5-1-3-基于工厂方法模式" class="headerlink" title="5.1.3 基于工厂方法模式"></a>5.1.3 基于工厂方法模式</h5><p>工厂方法模式是一种比较重要的设计模式，用于创建对象，旨在抽象出创建对象和属性复制的过程，只对外暴露出需要设置的属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂分啊，对外暴露接收 name age address 属性值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, address</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  o.name = name</span><br><span class="line">  o.age = age</span><br><span class="line">  o.address = address</span><br><span class="line">  o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = createPerson(<span class="string">'张三'</span>, <span class="number">28</span>, &#123;</span><br><span class="line">  name: <span class="string">'上海'</span>,</span><br><span class="line">  code: <span class="string">'10000'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用工程方法可以减少很多重复的代码，但是创建的所有实例都是 Object 类型，无法更进一步区分具体类型。</p>
<h5 id="5-1-4-基于构造函数模式"><a href="#5-1-4-基于构造函数模式" class="headerlink" title="5.1.4 基于构造函数模式"></a>5.1.4 基于构造函数模式</h5><p>构造函数是通过 this 为对象添加属性的，属性值类型可以为基本类型，对象或者函数，然后通过 new 操作符创建对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, address</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.address = address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>, <span class="number">28</span>, &#123;</span><br><span class="line">  name: <span class="string">'上海'</span>,</span><br><span class="line">  code: <span class="string">'10000'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用构造函数创建的对像可以确定其所属类型，解决了 5.1.3 中的问题。</p>
<p>使用构造函数创建的对象存在一个问题，即相同实例的函数是不一样的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, address</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.address = address</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person1 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>, <span class="number">28</span>, &#123;</span><br><span class="line">  name: <span class="string">'上海'</span>,</span><br><span class="line">  code: <span class="string">'10000'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>, <span class="number">28</span>, &#123;</span><br><span class="line">  name: <span class="string">'上海'</span>,</span><br><span class="line">  code: <span class="string">'10000'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person1.getName === person2.getName) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这意味着每个实例的函数都会占据一定的内存空间，其实这是没必要的，会造成资源的浪费，另外函数也是没不要在代码执行前就绑定到对象上。</p>
<h5 id="5-1-5-基于原型对象的模式"><a href="#5-1-5-基于原型对象的模式" class="headerlink" title="5.1.5 基于原型对象的模式"></a>5.1.5 基于原型对象的模式</h5><p>基于原型对象的模式是将所有的函数和属性都封装在对象的 <code>prototype</code>属性上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过 prototype 属性增加属性和函数</span></span><br><span class="line">  Person.prototype.name = <span class="string">'张三'</span></span><br><span class="line">  Person.prototype.age = <span class="number">28</span></span><br><span class="line">  Person.prototype.address = &#123;</span><br><span class="line">    name: <span class="string">'上海'</span>,</span><br><span class="line">  	code: <span class="string">'10000'</span></span><br><span class="line">  &#125;</span><br><span class="line">  Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成两个实例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.getName === p2.getName) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name === p2.name) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>通过上面代码可以发现，使用基于原型对象的模式创建的实例，其属性和函数都是相等的，不同的实例会共享原型上的属性和函数，解决了 5.1.4 中存在的问题。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.name)  <span class="comment">// 张三</span></span><br><span class="line">p2.name = <span class="string">'李四'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name) <span class="comment">// 李四 （在自己的空间中找到，就不会去原型链中查找了）</span></span><br></pre></td></tr></table></figure>
<p>但是这种方式也存在一个问题，因为所有的实例会共享相同的属性，如果修改了原型中的引用数据，原型链中的数据共享，这并不是我们期望的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.address.name)  <span class="comment">// 上海</span></span><br><span class="line">p2.address.name = <span class="string">'武汉'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.address.name) <span class="comment">// 武汉 (引用数据被共享)</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.address.name) <span class="comment">// 武汉</span></span><br></pre></td></tr></table></figure>
<h5 id="5-1-6-构造函数和原型混合的模式"><a href="#5-1-6-构造函数和原型混合的模式" class="headerlink" title="5.1.6 构造函数和原型混合的模式"></a>5.1.6 构造函数和原型混合的模式</h5><p>构造函数和原型混合的模式是目前最重建的创建自定义类型对象的方式。</p>
<p>构造函数中用于定义实例的属性，原型对象中用于定义实例共享的属性和函数，通过构造函数传递参数，这样每个实例都能拥有自己的属性值，同时实例还能共享函数的引用，最大限度的节约了内存的空间，混合模式可谓集二者之长。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数中定义实例的属性</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, address</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.address = address</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型中添加实例共享的函数</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成两个实例</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">'张三'</span>, <span class="number">28</span>, &#123;</span><br><span class="line">    name: <span class="string">'上海'</span>,</span><br><span class="line">  	code: <span class="string">'10000'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person(<span class="string">'李四'</span>, <span class="number">28</span>, &#123;</span><br><span class="line">    name: <span class="string">'北京'</span>,</span><br><span class="line">  	code: <span class="string">'10000'</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 输出两个实例初始化的 name 属性</span></span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// 张三</span></span><br><span class="line"><span class="built_in">console</span>.log(p2.name) <span class="comment">// 李四</span></span><br><span class="line"><span class="comment">// 改变一个实例的属性</span></span><br><span class="line">p1.address.name = <span class="string">'广州'</span></span><br><span class="line">p1.address.code = <span class="string">'10003'</span></span><br><span class="line"><span class="built_in">console</span>.log(p1) <span class="comment">// Person &#123;name: '张三', age: 28, address: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p2) <span class="comment">// Person &#123;name: '李四', age: 28, address: &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>推荐构造函数和原型混合的模式创建自定义对象。ES6 后推荐使用 <code>class</code> 语法。</p>
</blockquote>
<h4 id="5-2-对象的属性-了解"><a href="#5-2-对象的属性-了解" class="headerlink" title="5.2 对象的属性(了解)"></a>5.2 对象的属性(了解)</h4><p>ECMA-262 将对象定义为一组属性的无序集合。严格来说，这意味着对象就是一组没有特定顺序的值。对象的每个属性或方法都有一个名称来标识，这个名称映射到一个值。其中的内容就是一组名/值对，值可以是数据或者函数。</p>
<h5 id="5-2-1-理解对象"><a href="#5-2-1-理解对象" class="headerlink" title="5.2.1 理解对象"></a>5.2.1 理解对象</h5><p>创建自定义对象的通常方式是创建 Object 的一个新实例，然后再给它添加属性和方法，如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">person.name = <span class="string">"张三"</span></span><br><span class="line">person.age = <span class="number">29</span></span><br><span class="line">person.job = <span class="string">'software engineer'</span></span><br><span class="line">person.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子创建了衣蛾名为 person 的对象，而且有三个属性（name、age和 job）和一个方法 sayName()。sayName() 方法会显示 this.name 的值，这个属性会解析为 person.name。早期 JavaScript 开发者频繁使用这种方式创建对象。几年后 ，<strong>对象字面量变</strong>成了更流行的方式。前面的例子如果使用对象字面量则可以这样写：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span>,</span><br><span class="line">  age: <span class="number">29</span>,</span><br><span class="line">  job: <span class="string">"software engineer"</span>,</span><br><span class="line">  sayName() &#123; <span class="comment">// 还可以这么写 sayName: function() &#123;console.log(this.name)&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中的 person 对象跟前面例子中的 person 对象是等价的，他们的属性和方法都一样。这些属性都有自己的特征，而这些特征决定了它们在 JavaScript 中的行为。</p>
<h5 id="5-2-2-数据属性"><a href="#5-2-2-数据属性" class="headerlink" title="5.2.2 数据属性"></a>5.2.2 数据属性</h5><p>【了解】数据属性有4个描述其行为的特性：</p>
<ul>
<li><strong>[[Configurable]]</strong> : 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。</li>
<li><strong>[[Enumerable]]</strong> : 表示能否通过 for-in 循环返回属性。</li>
<li><strong>[[Writable]]</strong> : 表示能否修改属性的值。</li>
<li><strong>[[Value]]</strong> : 包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值时，把新值保存在这个位置。默认值是 undefined。</li>
</ul>
<p>如果要修改属性的默认特性，就必须使用 <code>Object.defineProperty()</code>方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含 configurable、enumerable、writable和 value，跟相关特性的名称一一对应。根据要修改的特性，可设置其中一个或多个值。比如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,  <span class="comment">// name 属性的值不能修改</span></span><br><span class="line">  value: <span class="string">'张三'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 张三</span></span><br><span class="line">person.value = <span class="string">"李四"</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// 还是张三，不能修改</span></span><br></pre></td></tr></table></figure>
<p>这个例子创建了一个名为 name 的属性并赋值 “张三”。这个属性的值不能再修改了，在非严格模式下尝试给这个属性重新赋值会被忽略，在严格模式下，尝试修改只读属性的值会抛出错误。</p>
<h5 id="5-2-3-访问器属性"><a href="#5-2-3-访问器属性" class="headerlink" title="5.2.3 访问器属性"></a>5.2.3 访问器属性</h5><p>访问器属性不包含数据值。相反，它们包含一个获取（getter）函数和一个设置（setter）函数，不过这两个函数不是必须的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。</p>
<ul>
<li><strong>[[Configurable]]</strong>：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。</li>
<li><strong>[[Enumerable]]</strong>：表示能否通过 for-in 循环返回属性。</li>
<li><strong>[[Get]]</strong>：在读取属性时调用的函数。默认值为 undefined。</li>
<li><strong>[[Set]]</strong>：在写入属性时调用的函数。默认值为 undefined。</li>
</ul>
<p><strong>访问器属性不能直接定义，必须使用 <code>Object.defineProperty()</code> 来定义。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">    _year : <span class="number">2004</span>,</span><br><span class="line">    edition : <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123; </span><br><span class="line">    <span class="keyword">get</span> : function () &#123;</span><br><span class="line">        alert(<span class="keyword">this</span>._year);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span> : function (newValue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year;      <span class="comment">// 弹出窗口，显示 2004</span></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line"><span class="built_in">console</span>.log(book.edition);   <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-对象克隆"><a href="#5-3-对象克隆" class="headerlink" title="5.3 对象克隆"></a>5.3 对象克隆</h4><p>对象克隆是指通过一定的程序将某个变量的值复制到另一个变量的过程，根据复制后的变量与原始变量值的影响情况，克隆可以分为浅克隆（浅拷贝）和深克隆（深拷贝）两种方式。</p>
<p>针对不同的数据类型，浅克隆和深克隆会有不同的表现，主要表现于基本数据类型和引用数据类型在内存中存储的值不同。</p>
<p>对应基本数据类型的值，变量存储的是值本身，存放在内存的简单数据段中，可以直接进行访问。</p>
<p>对于引用数据类型的值，变量存储的是值在聂村中的地址，地址指向聂村中的某个位置，如果多个变量同时指向同一个内存地址，则其中一个变量对值进行修改时，会影响到其他的变量。</p>
<p>以下以数组为实例来看看效果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = arr1</span><br><span class="line">arr2[<span class="number">1</span>] = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(arr1) <span class="comment">// (3) [1, 4, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr2) <span class="comment">// (3) [1, 4, 3]</span></span><br></pre></td></tr></table></figure>
<p>正是由于数据类型的差异性导致了基本数据类型不管是浅克隆还是深克隆都是对值本身的克隆，对克隆后值的修改不会影响到值本身。</p>
<p>引用数据类型如果执行的是浅克隆，对克隆后的值的修改会影响到原始值，如果执行的是深克隆，则克隆对象和原始对象相互独立，不会彼此影响。</p>
<h5 id="5-3-1-对象浅克隆"><a href="#5-3-1-对象浅克隆" class="headerlink" title="5.3.1 对象浅克隆"></a>5.3.1 对象浅克隆</h5><p>浅克隆由于值克隆对象最外层的属性，如果对象存在更深层的属性，则不进行处理，这就会导致克隆对象和原始对象的深层属性仍然执行同一块内存。</p>
<h5 id="5-3-2-ES6-的-Object-assign-函数"><a href="#5-3-2-ES6-的-Object-assign-函数" class="headerlink" title="5.3.2 ES6 的 Object.assign() 函数"></a>5.3.2 ES6 的 Object.assign() 函数</h5><p>在 ES6 中，Object 对象新增了一个 <code>assign()</code> 函数，用于将源对象的可枚举属性赋值到目标对象中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始对象</span></span><br><span class="line"><span class="keyword">const</span> origin = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  b:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="string">'name'</span>,</span><br><span class="line">    f: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 assign 克隆对象</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Object</span>.assign(&#123;&#125;, origin)</span><br><span class="line">result.c.d = <span class="string">'new name'</span></span><br><span class="line"><span class="built_in">console</span>.log(origin)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<p> <code>Object.assign()</code>拷贝的是（可枚举）属性值。假如源值是一个对象的引用，它仅仅会复制其引用值。针对深拷贝，需要使用其他办法</p>
<h5 id="5-3-3-对象深克隆"><a href="#5-3-3-对象深克隆" class="headerlink" title="5.3.3 对象深克隆"></a>5.3.3 对象深克隆</h5><h6 id="JSON序列号和反序列化"><a href="#JSON序列号和反序列化" class="headerlink" title="JSON序列号和反序列化"></a>JSON序列号和反序列化</h6><p>如果一个雕像中的全部实数都是可以序列化的，那么我们可以使用 <code>JSON.stringify()</code>函数将原始对象序列化为字符串，再使用<code>JSON.parse()</code>函数将字符串反序列化为一个对象。这里得到的就是深克隆后的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> origin = &#123;</span><br><span class="line">  a:<span class="number">1</span>,</span><br><span class="line">  b:[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],</span><br><span class="line">  c: &#123;</span><br><span class="line">    d: <span class="string">'name'</span>,</span><br><span class="line">    f: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(origin))</span><br><span class="line">result.c.d = <span class="string">'new name'</span></span><br><span class="line"><span class="built_in">console</span>.log(origin)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>
<p>这种方式能解决大部分 JSON 类型对象的深克隆问题，但是对于以下几个问题不能很好解决。</p>
<ul>
<li>无法实现对函数，RegExp等特殊对象。</li>
<li>对象的 constructor 会被抛弃，所有的构造函数会指向 Object，原型链关系会破裂。</li>
<li>对象中如果存在循环引用，会抛出异常。</li>
</ul>
<h6 id="深克隆的第三方库"><a href="#深克隆的第三方库" class="headerlink" title="$.深克隆的第三方库"></a>$.深克隆的第三方库</h6><p><strong>函数库lodash的_.cloneDeep方法</strong></p>
<p>该函数库也有提供_.cloneDeep用来做深克隆。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = _.cloneDeep(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>jQuery</strong></p>
<p>jQuery 有提供一个$.extend可以用来做深克隆。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: &#123; <span class="attr">f</span>: &#123; <span class="attr">g</span>: <span class="number">1</span> &#125; &#125;,</span><br><span class="line">    c: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = $.extend(<span class="literal">true</span>, &#123;&#125;, obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.b.f === obj2.b.f); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><strong>使用Object.create()方法</strong></p>
<p>直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">initalObj, finalObj</span>) </span>&#123;    </span><br><span class="line">  <span class="keyword">var</span> obj = finalObj || &#123;&#125;;    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> initalObj) &#123;        </span><br><span class="line">    <span class="keyword">var</span> prop = initalObj[i];        <span class="comment">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span></span><br><span class="line">    <span class="keyword">if</span>(prop === obj) &#123;            </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> prop === <span class="string">'object'</span>) &#123;</span><br><span class="line">      obj[i] = (prop.constructor === <span class="built_in">Array</span>) ? [] : <span class="built_in">Object</span>.create(prop);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[i] = prop;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-原型对象"><a href="#5-4-原型对象" class="headerlink" title="5.4 原型对象"></a>5.4 原型对象</h4><p>每一个函数在创建时都会被赋予一个 <code>prototype</code>属性。它指向函数的原型对象，这个对象可以包含所有实例的共享的属性和函数，因此在使用 prototype 属性后，就可以将实例共享的属性和函数抽离出构造函数，将它添加在 prototype 属性中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p2.sayName === p2.sayName) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>实例共享的 sayName() 函数就被添加在了 Person.prototype 属性上，通过测试我们会发现不同的实例中的 sayName 属性是相同的。</p>
<p>因此使用 prototype 属性就很好的解决了，单纯通过构造函数创建实例会导致函数在不同实例中重复创建的问题。</p>
<h5 id="5-4-1-原型对象，构造函数和实例"><a href="#5-4-1-原型对象，构造函数和实例" class="headerlink" title="5.4.1 原型对象，构造函数和实例"></a>5.4.1 原型对象，构造函数和实例</h5><p>通过前面我们知道，构造函数的 prototype 属性会指向它的原型对象，而通过构造函数可以生成具体的实例，这里会涉及3个概念，分别是<strong>构造函数</strong>、<strong>原型对象</strong>和<strong>实例</strong>。</p>
<ol>
<li>原型对象，构造函数和实例之间的关系是什么样的？</li>
<li>使用原型对象创建了对象的实例后，实例的属性读取顺序是什么样的？</li>
<li>假如重写了原型对象，会带来什么样的问题？</li>
</ol>
<h5 id="5-4-2-原型对象、构造函数和实例之间的关系"><a href="#5-4-2-原型对象、构造函数和实例之间的关系" class="headerlink" title="5.4.2 原型对象、构造函数和实例之间的关系"></a>5.4.2 原型对象、构造函数和实例之间的关系</h5><p>每一个函数在创建时都会被赋予一个 prototype 属性，它指向函数的原型对象。在默认情况下，所有的原型对象都会增加一个 constructor 属性，指向 prototype 属性所在的函数，即构造函数。</p>
<p>当我们通过 new 操作符调用构造函数创建一个实例时，实例具有一个<code>__prop__</code>属性，指向构造函数的原型对象，因此<code>__prop__</code>属性可以看做是一个连接实例与构造函数的原型对象的桥梁。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'张三'</span></span><br><span class="line">Person.prototype.age = <span class="number">28</span></span><br><span class="line">Person.prototype.jon = <span class="string">'teacher'</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
<p>接下来我们以构造函数 Person 为例看看构造函数，原型和实例之间的关系。</p>
<p><img src="https://s2.loli.net/2021/12/09/e7yRJjgVv5lwBzK.jpg" alt="js原型"></p>
<p>构造函数 Person 有个 prototype 属性，指向的是 Person 的原型对象，在原型对象中有 constructor 属性和另外的4个原型对象上的属性，其中 constructor 属性指向构造函数本身。</p>
<p>通过 new 操作符创建的两个实例 p1 和 p2，都具有一个<code>__prop__</code>属性指向的是 Person 原型对象。</p>
<h5 id="5-4-3-实例的属性读取顺序"><a href="#5-4-3-实例的属性读取顺序" class="headerlink" title="5.4.3 实例的属性读取顺序"></a>5.4.3 实例的属性读取顺序</h5><p>当我们通过对象的实例读取某个属性时，是有一个搜索的过程的。它贤惠在实例本书去找指定的属性，如果找到了，则直接返回该属性的值，如果没找到，则会沿着原型对象去寻找，如果在原型对象中找到了该属性，则返回该属性的值。</p>
<p>按照前面的实例，假如我们需要输出 p1.name 属性，会在 p1 实例本身中寻找 name 属性，而 p1 本身并没有该属性，因此会继续沿着原型对象寻找，在 prototype 原型对象上寻找到了 name 属性值“张三”。</p>
<p>如果我们对上面代码进行简单修改，得到的结果又会不一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">"李四"</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">'张三'</span></span><br><span class="line">Person.prototype.age = <span class="number">28</span></span><br><span class="line">Person.prototype.jon = <span class="string">'teacher'</span></span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// 李四</span></span><br></pre></td></tr></table></figure>
<p>我们在 Person() 构造函数中新增了一个 name 属性，它是一个实例属性，当我们需要输出 p1.name 属性时，会先在 p1 实例本身中寻找 name 属性，能够找到该属性值为“李四”，因此输出“李四”。</p>
<p>同样，假如 Person() 构造函数同时具有相同名称的实例属性和原型对象上的属性，在生成实例后，删除了实例的实例属性，那么会输出原型对象上的属性值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的 name 属性是实例属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的 name 是原型对象上的属性</span></span><br><span class="line">Person.prototype.name = <span class="string">'张三'</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person(<span class="string">"王五"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// 王五</span></span><br><span class="line"><span class="comment">// 删除实例的属性</span></span><br><span class="line"><span class="keyword">delete</span> p1.name</span><br><span class="line"><span class="built_in">console</span>.log(p1.name) <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<h5 id="5-4-4-重写原型对象"><a href="#5-4-4-重写原型对象" class="headerlink" title="5.4.4 重写原型对象"></a>5.4.4 重写原型对象</h5><p>在之前的代码中，每次为原型对象添加一个属性或者函数时，都需要手动写上 Person.prototype ，除此之外，我们可以将所有需要绑定在原型对象上的属性，写成一个对象字面量的形式，并赋值给 prototype。<strong>注意不要忘记 constructor 属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: Person, // 不要忘记指定构造函数</span><br><span class="line">  name: "张三",</span><br><span class="line">  age: 28,</span><br><span class="line">  job: "teacher",</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们创建 Person 对象的实例时，仍然可以正常的访问各个原型对象上的属性。将一个对象字面量赋值给 prototype 属性的方式，应该在对象字面量中增加一个 constructor 属性，指向构造函数本身，否则原型的 constructor 属性会指向 Object 类型的构造函数，从而导致 constructor 属性与构造函数的脱离。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.constructor === Person) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>通过结果，我们发现 Person 的原型对象的 constructor 属性不再指向 Person() 构造函数，而是指向 Object 类型的构造函数了。</p>
<p>由于重写原型对象会切断构造函数和最初原型之间的关系，因此会带来一个隐患，那就是如果在重写原型对象之前，已经生成了对象实例，则该实例将无法访问到新的原型对象中的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 先生成一个实例 p1</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// 重写对象的原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再生成一个实例</span></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> Person()</span><br><span class="line">p1.sayName() <span class="comment">// TypeError: p1.sayName is not a function</span></span><br><span class="line">p2.sayName() <span class="comment">// 张三</span></span><br></pre></td></tr></table></figure>
<p>在上面的代码中，生成的实例 p1 实际指向的事最初的原型，而将原型对象手动重写以后，就脱离了最初的原型关系，最初原型中没有对应的属性和函数，因此在执行 p1.sayName() 函数时，会抛出异常，表示 p1 中不存在 sayName() 函数。</p>
<p>上面的实例就是在提醒我们，如果想要重写原型对象，需要保证不要在重写完成之前生成实例对象，否则会出现异常。</p>
<blockquote>
<p>不推荐重写原型对象。</p>
</blockquote>
<h4 id="5-5-原型链"><a href="#5-5-原型链" class="headerlink" title="5.5 原型链"></a>5.5 原型链</h4><p>对象的每个实例都具有一个<code>__prop__</code>属性，指向的事构造函数的原型对象，而原型对象同样存在一个<code>__prop__</code>属性指向上一级构造函数的原型对象，就这样层层往上，直到最上层某个原型对象为 null。</p>
<p>在 JavaScript 中几乎所有的对象都具有<code>__prop__</code>属性，由<code>__prop__</code>属性链接而成的链路构成了 JavaScript 的原型链，原型链的顶端 Object.prototype，它的<code>__prop__</code>属性为 null。</p>
<p>我们通过一个实例来看看一个简单的原型链过程，首先定义一个构造函数，并生成一个实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure>
<p>然后 person 实例沿着原型链第一次追溯，<code>__prop__</code>属性指向 Person() 构造函数的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.__prop__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>person 实例沿着原型链第二次追溯，Person 原型对象的<code>__prop__</code>属性指向 Object 类型的原型对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.__prop__.__prop__ === Person.prototype__prop__ === <span class="built_in">Object</span>.prototype)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>person 实例沿着原型链第三次追溯，Object 类型的原型对象的 <code>__prop__</code>属性为 null。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.__prop__.__prop__.__prop__ === Person.prototype__prop__.__prop__ === <span class="built_in">Object</span>.prototype.__prop__ === <span class="literal">null</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="5-5-1-原型链的特点"><a href="#5-5-1-原型链的特点" class="headerlink" title="5.5.1 原型链的特点"></a>5.5.1 原型链的特点</h5><p>原型链的特点主要有以下两个：</p>
<ol>
<li>由于原型链的存在，属性查找的过程不再是查找自身的原型对象，而是会沿着整个原型链一直向上，知道追溯到 Object.prototype，如果 Object.prototype 上也找不到该属性，则返回‘undefined’，如果期间在实例本身或者某个原型对象上找到该属性，则会直接返回结果，因此会存在属性覆盖的问题。</li>
</ol>
<p>由于特点1的存在，我们在生成自定义对象实例时，也可以调用到某些未在自定义构造函数上的函数，例如 toString() 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line">p.toString() <span class="comment">// Obbject 实际调用的是 Object.toString() 函数</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>由于属性查找会经历整个原型链，因此查找的链路越长，对性能的影响越大。</li>
</ol>
<h5 id="5-5-2-属性的区分"><a href="#5-5-2-属性的区分" class="headerlink" title="5.5.2 属性的区分"></a>5.5.2 属性的区分</h5><p>对象的属性的寻找往往会涉及这个原型链，那么该怎么区分属性是实例自身还是从原型链中继承的呢？</p>
<p>Object() 构造函数的原型对象中提供了一个 <code>hasOwnProperty()</code> 函数，用于判断属性是否为自身用于的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 实例属性 name</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型对象上的属性 age</span></span><br><span class="line">Person.prototype.age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'张三'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'name'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(person.hasOwnProperty(<span class="string">'age'</span>)) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h5 id="5-5-3-内置构造函数"><a href="#5-5-3-内置构造函数" class="headerlink" title="5.5.3 内置构造函数"></a>5.5.3 内置构造函数</h5><p>JavaScript 中有一些特定的内置构造函数，如 String() 构造函数，Array() 构造函数，Object() 构造函数等。</p>
<p>它们本身的<code>__proto__</code>属性都统一指向<code>Function.prototype</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype)</span><br></pre></td></tr></table></figure>
<h5 id="5-5-4-prooto-属性"><a href="#5-5-4-prooto-属性" class="headerlink" title="5.5.4 __prooto__属性"></a>5.5.4 __prooto__属性</h5><p>在 JavaScript 的原型链体系中，最重要的莫过于 <code>__proto__</code>属性，只有通过它才能将原型链串联起来。</p>
<blockquote>
<p><strong>已废弃:</strong> 该特性已经从 Web 标准中删除，虽然一些浏览器目前仍然支持它，但也许会在未来的某个时间停止支持，请尽量不要使用该特性。</p>
</blockquote>
<blockquote>
<p><strong>警告:</strong> 当<code>Object.prototype.__proto__</code> 已被大多数浏览器厂商所支持的今天，其存在和确切行为仅在ECMAScript 2015规范中被标准化为传统功能，以确保Web浏览器的兼容性。为了更好的支持，建议只使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a>。</p>
</blockquote>
<p>我们先实例化一个字符串，然后输出字符串的值，具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"张三"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(str)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">String &#123;'张三'&#125;</span></span><br><span class="line"><span class="comment">0: "张"</span></span><br><span class="line"><span class="comment">1: "三"</span></span><br><span class="line"><span class="comment">length: 2</span></span><br><span class="line"><span class="comment">[[Prototype]]: String</span></span><br><span class="line"><span class="comment">[[PrimitiveValue]]: "张三</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>str 的值包含2个字符和一个 length 属性。</p>
<p>但是我们在调用 str.substring(1, 2) 时，却不会报错，这是为什么呢？</p>
<p>因为<code>__proto__</code>属性（[[Prototype]]）可以沿着原型链找到 String.prototype 中的函数，而 substring() 函数就在其中。在控制台展开<code>__proto__</code>属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">split: ƒ split()</span><br><span class="line">startsWith: ƒ startsWith()</span><br><span class="line">substr: ƒ substr()</span><br><span class="line">substring: ƒ substring()</span><br><span class="line">toLocaleUpperCase: ƒ toLocaleUpperCase()</span><br><span class="line">toLowerCase: ƒ toLowerCase()</span><br><span class="line">toString: ƒ toString()</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>所以就可以通过 str 正常调用 substring() 函数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.a = <span class="string">'a'</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.b = <span class="string">'b'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p.a'</span>, p.a); <span class="comment">// p.a undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'p.b'</span>, p.b); <span class="comment">// p.b b</span></span><br></pre></td></tr></table></figure>
<p>上面的代码要输出实例 p 的 a 属性和 b 属性的值，所以我们需要先了解实例 p 的属性查找过程，属性查找是根据 <code>__proto__</code>属性沿着原型链来完成的，因此我们需要先梳理出 实例 p 的原型链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例 p 的原型链</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype)</span><br><span class="line"><span class="comment">// Person 原型对象的原型</span></span><br><span class="line"><span class="built_in">console</span>.log(Person,prototype.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>
<p>因此实例输出 p 的属性是，最终会找到 Object.prototype 中去，根据一开始定义的值可以得到以上的结果。</p>
<h4 id="5-6-继承"><a href="#5-6-继承" class="headerlink" title="5.6 继承"></a>5.6 继承</h4><p>继承作为面向对象语言的三大特性之一，三大特性是继承、封装、多态。可以在不影响父类对象的情况下，使得子类对象具有父类对象的特性，同时还能在不影响父类对象行为的情况下扩展紫烈对象特有的特性，为编码带来了极大的遍历。</p>
<p>虽然 JavaScript 并不是一门面向对象的语言，不直接具备继承的特性，但是我们可以通过某些方式间接实现继承，从而利用继承的优势，增强代码的复用性和扩展性。</p>
<h5 id="5-6-1-原型链继承"><a href="#5-6-1-原型链继承" class="headerlink" title="5.6.1 原型链继承"></a>5.6.1 原型链继承</h5><p>原型链继承的主要思想是：重写子类的 prototype 属性，将其指向父类的实例。、</p>
<p>我们定义一个子类 Cat 用于继承父类 Animal，子类 Cat 的实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'Animal'</span></span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'动物'</span></span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型函数</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span>+ food)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义子类：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子类 Cat</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line"><span class="comment">// 很关键的一句，将 Cat 的构造函数指向自身</span></span><br><span class="line">Cat.prototype.constructor = Cat</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">"加菲猫"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cat.type) <span class="comment">// Animal</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">// 加菲猫</span></span><br><span class="line">cat.sleep() <span class="comment">// 加菲猫正在睡觉</span></span><br><span class="line">cat.eat(<span class="string">"猫粮"</span>) <span class="comment">// 加菲猫正在吃猫粮</span></span><br></pre></td></tr></table></figure>
<p>在子类 Cat 中，我们没有增加 type 属性，因此会直接继承父类 Animal 的 type 属性，输出字符串 ‘Animal’。</p>
<p>在子类 Cat 中，，我们增加了 name 属性，在声称子类 Cat 实例时，name 属性值会覆盖父类 Animal 的 name 属性值，因此输出字符串‘加菲猫’，并不会输出父类 Animal 的 name 属性“动物”。</p>
<p>同样因为 Cat 的 prototype 属性指向了 Animal 类型的实例，因此在生成实例 Cat 时，会继承实例函数和原型函数，在调用 sleep() 函数和 eat() 函数时，this 指向了实例 cat，从而输出‘加菲猫正在睡觉’和‘加菲猫正在吃猫粮’。</p>
<p>需要注意其中很关键的一句代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 很关键的一句，将 Cat 的构造函数指向自身</span></span><br><span class="line">Cat.prototype.constructor = Cat</span><br></pre></td></tr></table></figure>
<p>这是因为如果不将 Cat 原型对象的 constructor 属性指向自身的构造函数的话，那将会指向父类 Animal 的构造函数。</p>
<p><strong>原型链继承优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>简单，很容易实现</li>
</ol>
<p>​            只需要设置子类的 prototype 属性为父类的实例即可，实现起来简单。</p>
<ol start="2">
<li>继承关系纯粹</li>
</ol>
<p>​            生成的实例即是子类的实例，也是父类的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Cat) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat <span class="keyword">instanceof</span> Animal) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>可以通过子类直接访问父类原型链属性和函数</li>
</ol>
<p>​            通过原型链继承的资料，可以直接访问到父类原型链上新增的函数和属性。</p>
<p>​            继续沿用前面的代码，我们通过在父类原型链上添加属性和函数进行测试，代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类原型链上增加属性</span></span><br><span class="line">Animal.prototype.bodyType = <span class="string">'small'</span></span><br><span class="line"><span class="comment">// 父类原型链上增加函数</span></span><br><span class="line">Animal.prototype.run = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">'正在奔跑'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果验证</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.bodyType) <span class="comment">// small</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.run()) <span class="comment">// 加菲猫正在奔跑</span></span><br></pre></td></tr></table></figure>
<p><strong>缺点</strong></p>
<ol>
<li>子类的所有实例将共享父类的属性。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br></pre></td></tr></table></figure>
<p>在使用原型链继承是，直接改写了子类 Cat 的 prototype 属性，将其指向一个 Animal 的实例，那么所有生成 Cat 对象的实例都将会共享 Animal 实例的属性。</p>
<p>这将会带来一个很验证的问题，如果父类 Animal中有个值为引用类型，那么改变 Cat 某个实例的属性值将会影响其他实例的属性值。</p>
<ol start="2">
<li><p>在创建子类实现时，无法想父类的构造函数传递参数。</p>
<p>在通过 new 操作符创建子类的实例时，会调用子类的构造函数，而在子类的构造函数中并没有设置与父类的关联，从而导致无法想父类的构造函数传递参数。</p>
</li>
<li><p>为子类增加原型链对象上的属性和函数时，必须放在 new Animal() 函数之后。</p>
</li>
</ol>
<h5 id="5-6-2-构造继承"><a href="#5-6-2-构造继承" class="headerlink" title="5.6.2 构造继承"></a>5.6.2 构造继承</h5><p>构造继承的思想是在子类的构造函数中通过 call() 函数改变 this 的指向，调用父类的构造函数，从而能将父类的实例的属性和函数绑定到子类的 this 上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Animal'</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型函数</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span>+ food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 核心通过 call()函数实现 Animal 的实例的属性和函数的继承</span></span><br><span class="line">  Animal.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成子类的实例</span></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'tony'</span>)</span><br><span class="line"><span class="comment">// 可以正常调用父类实例函数</span></span><br><span class="line">cat.sleep() <span class="comment">// tony正在睡觉</span></span><br><span class="line"><span class="comment">// 不能调用父类原型函数</span></span><br><span class="line">cat.eat() <span class="comment">// TypeError: cat.eat is not a function</span></span><br></pre></td></tr></table></figure>
<p>通过代码可以发现，子类可以正常调用父类的实例函数，而无法调用父类原型对象上的函数，这是因为子类并没有通过某种方式来调用父类原型对象上的函数。</p>
<p><strong>构造继承的优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li><p>可以解决子类实例共享父类属性的问题。</p>
<p>call() 函数实际是改变了父类 Animal构造函数中 this 的指向，调用后 this 指向了子类 Cat，相当于父类的 type，age和 sleep等属性和函数直接绑定到子类的 this 中，成了子类实例的属性和函数，因此生成的子类实例中是各自拥有自己的type，age和 sleep，不会互相影响。</p>
</li>
<li><p>创建子类的实例时，可以想父类传递参数</p>
<p>在 call() 函数中，我们可以传递参数，我们就可以对父类的属性进行设置，同时由子类继承下来。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Animal'</span></span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="comment">// 方法</span></span><br><span class="line">  <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型函数</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span>+ food)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, parentAge</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 传递参数给 call() 函数，间接地传递给父类，然后被子类继承</span></span><br><span class="line">  Animal.call(<span class="keyword">this</span>, parentAge)</span><br><span class="line">  <span class="keyword">this</span>.name = name || <span class="string">'Tom'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生成子类的实例</span></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'tony'</span>, <span class="number">11</span>)</span><br><span class="line"><span class="comment">// 可以正常调用父类实例函数</span></span><br><span class="line">cat.sleep() <span class="comment">// tony正在睡觉</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.age)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li><p>可以实现多继承</p>
<p>在子类构造函数中，可以通哦该多次调用 call() 函数来继承多个父对象，每调用一次 call() 函数就会将父类的实例属性和函数绑定到子类的 this 中。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>实例只是子类的实例，并不是父类的实例</p>
<p>因为我没并没有通过原型对象将子类与父类进行串联，所以生成的实例与父类并没有关系，这样就失去了继承的意义。</p>
</li>
<li><p>只能继承父类实例的属性和函数，并不能继承原型对象上的属性和函数。</p>
</li>
<li><p>无法复用父类的实例函数。</p>
</li>
</ol>
<p>​            由于父类的实例函数将通过 call() 函数绑定到子类的 this 中，因此子类生成的每个实例都会拥有父类实例函数的引用，这会造成不必要的内存消耗，影响性能。</p>
<h5 id="5-6-3-复制继承"><a href="#5-6-3-复制继承" class="headerlink" title="5.6.3 复制继承"></a>5.6.3 复制继承</h5><p>复制继承的主要思想是首先生成父类的实例，然后通过 <code>for...in</code>遍历父类实例的属性和函数，并将其一次设置为子类实例的属性和函数或者原型对象上的属性和函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Animal'</span></span><br><span class="line">    <span class="keyword">this</span>.age = age</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型函数</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span> + food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> animal = <span class="keyword">new</span> Animal(age)</span><br><span class="line">  <span class="comment">// 父类的属性和函数添加到子类中</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> animal) &#123;</span><br><span class="line">  	<span class="comment">// 实例属性和函数</span></span><br><span class="line">  	<span class="keyword">if</span>(animal.hasOwnProperty(key)) &#123;</span><br><span class="line">  		<span class="keyword">this</span>[key] = animal[key]</span><br><span class="line">  	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  		<span class="comment">// 原型对象上的属性和函数</span></span><br><span class="line">  		Cat.prototype[key]= animal[key]</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 子类自身的属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类自身原型函数</span></span><br><span class="line">Cat.prototype.eat= <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span> + food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成子类的实例</span></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'tony'</span>, <span class="number">12</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cat.age) <span class="comment">// 12</span></span><br><span class="line">cat.sleep() <span class="comment">// tony正在睡觉</span></span><br><span class="line">cat.eat(<span class="string">'猫粮'</span>) <span class="comment">// tony正在吃猫粮</span></span><br></pre></td></tr></table></figure>
<p>在子类的构造函数中，对父实例的所有属性进行 for…in 遍历，如果 animal.hasOwnProperty(key) 返回 true，则表示实例的属性和函数，则直接绑定到子类的 this 上，成为子类实例的属性和函数。如果为 false，则表示是原型对象上的属性和函数，则将其添加到子类的 prototype 属性上，成为子类的原型对象上的属性和函数。</p>
<p><strong>复制继承的优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li>能同时继承实例的属性和函数与原型对象上的属性和函数。</li>
<li>可以向父类构造函数传递值。</li>
<li>支持多继承。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li><p>父类的锁边属性都需要复制，消耗内存。</p>
</li>
<li><p>实例只是子类的实例，并不是父类的实例。</p>
<p>实际上我们只是通过遍历父类的属性和函数并将其复制到子类上，并没有通过原型对象串联其父类和子类，因此子类的实例不是父类的实例。</p>
</li>
</ol>
<h5 id="5-6-4-组合继承"><a href="#5-6-4-组合继承" class="headerlink" title="5.6.4 组合继承"></a>5.6.4 组合继承</h5><p>组合继承的主要思想是组合了构造继承和原型继承两种方法，一方面在子类构造函数中通过 call() 函数调用父类的构造函数，将父类的实例的属性和函数绑定到子类的 this 中，另一方面，通过改变子类的 prototype 属性，继承父类的原型对象上的属性和函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">parentAge</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Animal'</span></span><br><span class="line">    <span class="keyword">this</span>.age = parentAge</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.feature = [<span class="string">'fat'</span>, <span class="string">'thin'</span>, <span class="string">'tall'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型函数</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span> + food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数继承实例的属性和函数</span></span><br><span class="line">  Animal.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 子类自身的属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过原型链继承原型对象上的属性和函数</span></span><br><span class="line">Cat.prototype = <span class="keyword">new</span> Animal()</span><br><span class="line">Cat.prototype.constructor = Cat</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'tony'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">// tony</span></span><br><span class="line">cat.sleep() <span class="comment">// tony正在睡觉</span></span><br><span class="line">cat.eat(<span class="string">'猫粮'</span>) <span class="comment">// tony正在吃猫粮</span></span><br></pre></td></tr></table></figure>
<p><strong>组合继承优缺点</strong></p>
<p><strong>优点</strong></p>
<ol>
<li><p>既能继承父类实例的属性和函数，又能继承原型对象的属性和函数。</p>
</li>
<li><p>即是子类实例，又是父类实例。</p>
</li>
<li><p>不存在引用属性共享的问题。</p>
<p>因为在子类的构造函数中已经将父类的实例属性指向了子类的 this，所以即是后面将父类的实例属性绑定到子类的 prototype 属性中，也会因为构造函数作用域优先级比原型链优先级高，所以不会出现引用属性共享的问题。</p>
</li>
<li><p>可以向父类的构造函数中传递参数。</p>
<p>通过 call() 函数可以向父类的构造函数中传递参数。</p>
</li>
</ol>
<p><strong>缺点</strong></p>
<p>组合继承的缺点为父类的实例属性会绑定两次。</p>
<p>在子类构造函数中，通过 call() 函数调用了一次父类的构造函数，在改写了类的 prototype 属性，生成父类的实例时调用了一次父类的构造函数。</p>
<h5 id="5-6-5-寄生组合继承"><a href="#5-6-5-寄生组合继承" class="headerlink" title="5.6.5 寄生组合继承"></a>5.6.5 寄生组合继承</h5><p>事实上组合继承的方法已经够好了，但是我们针对它的缺点再进行一下优化。</p>
<p>在进行子类的 prototype 属性的设置时，可以去掉父类实例的属性和函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类 Animal</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">parentAge</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'Animal'</span></span><br><span class="line">    <span class="keyword">this</span>.age = parentAge</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="keyword">this</span>.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在睡觉'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.feature = [<span class="string">'fat'</span>, <span class="string">'thin'</span>, <span class="string">'tall'</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 父类原型函数</span></span><br><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">'正在吃'</span> + food)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 通过构造函数继承实例的属性和函数</span></span><br><span class="line">  Animal.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="comment">// 子类自身的属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即执行函数</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置任意函数 Super()</span></span><br><span class="line">  <span class="keyword">const</span> Super = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  Super.prototype = Animal.prototype</span><br><span class="line">  Cat.prototype = <span class="keyword">new</span> Super()</span><br><span class="line">	Cat.prototype.constructor = Cat</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat(<span class="string">'tony'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(cat.name) <span class="comment">// tony</span></span><br><span class="line">cat.sleep() <span class="comment">// tony正在睡觉</span></span><br><span class="line">cat.eat(<span class="string">'猫粮'</span>) <span class="comment">// tony正在吃猫粮</span></span><br></pre></td></tr></table></figure>
<p>其中最关键的是如下所示的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Super.prototype = Animal.prototype</span><br></pre></td></tr></table></figure>
<h4 id="5-7-Object-类型和实例"><a href="#5-7-Object-类型和实例" class="headerlink" title="5.7 Object 类型和实例"></a>5.7 Object 类型和实例</h4><h5 id="5-7-1-new-运算符"><a href="#5-7-1-new-运算符" class="headerlink" title="5.7.1 new 运算符"></a>5.7.1 new 运算符</h5><p>Object 类型是目前 JavaScript 中使用最多的一个类型，目前大家使用的大部分引用数据类型都是 Object 类型，使用频率搞的原因是其对于数据存储和传输是非常理想的。由于引用数据类型的实例都需要通过 new 操作符来生成。</p>
<p>new 操作符在执行过程中会改变 this 的指向，所以了解 new 操作符之前，我们先了解一下 this 的用法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Cat(<span class="string">'miao'</span>, <span class="number">8</span>)) <span class="comment">// Cat &#123;name: 'miao', age: 8&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出的结果包含了 name 和 age 的信息，事实上我们并未通过 return 返回任何值，为什么输出的信息中会包含 name 和 age 属性呢？其中起作用的就是 this 这个关键字了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Cat(<span class="string">'miao'</span>, <span class="number">8</span>) <span class="comment">// Cat &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现 this 的实际值是 Cat 的空对象，后两句就相当于给 Cat 对象添加 name 和 age 属性，结果真的是这样吗？不如我们改写一下 Cat 函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Cat = &#123;&#125;</span><br><span class="line">  Cat.name = name</span><br><span class="line">  Cat.age = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Cat(<span class="string">'miao'</span>, <span class="number">8</span>)) <span class="comment">// Cat &#123;&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现输出的结果中并没有包含 name 和 age 属性，这是为什么呢？</p>
<p>因为在 JavaScript 中，如果函数没有 return 值，则默认 return this。而上面代码中的 this 实际是一个 Cat 空对象， name 和 age 属性只是被添加到了临时变量 Cat 中，为了呢个让输出结果包含 name 和 age 属性，我们将临时变量 Cat 进行 return 就行了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> Cat = &#123;&#125;</span><br><span class="line">  Cat.name = name</span><br><span class="line">  Cat.age = age</span><br><span class="line">  <span class="keyword">return</span> Cat</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Cat(<span class="string">'miao'</span>, <span class="number">8</span>)) <span class="comment">// &#123;name: 'miao', age: 8&#125;</span></span><br></pre></td></tr></table></figure>
<p>最后的返回值包含了 name 和 age 属性，通过以上的分析，我们了解了构造函数中 this 的用法，那么它与  new 操作符之间有什么关系呢？</p>
<p>我们先来看看下面这行简单的代码，该代码的作用是通过 new 操作符生成一个 Cat 对象的实例。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat()</span><br></pre></td></tr></table></figure>
<p>从表面上看这行代码的主要作用是创建一个车 Cat 对象的实例，并将这个实例值赋予 cat 变量， cat 变量就会包含 Cat 对象的属性和函数。</p>
<p>其实使用 new 操作符做了三件事情，如下代码所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cat = &#123;&#125;</span><br><span class="line">cat.__proto__ = Cat.prototype</span><br><span class="line">Cat.call(cat)</span><br></pre></td></tr></table></figure>
<p>第一行：创建一个空对象。</p>
<p>第二行：将空对象的<code>__proto__</code>属性指向 Cat 对象的 prototype 属性。</p>
<p>第三行：将 Cat() 函数中的 this 指向 cat变量。</p>
<p>于是 cat 变量就是 Call 对象的一个实例。</p>
<p>我们自定义一个类似 new 功能的函数，来具体讲解上面的三行代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> res = Cat.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(New((<span class="string">'miao'</span>, <span class="number">8</span>))) <span class="comment">// &#123;name: 'miao', age: 8&#125;</span></span><br></pre></td></tr></table></figure>
<p>返回的结果中包含 name 和 age 属性，这就证明了 new 运算符对 this 指向的改变。Cat.apply(obj, arguments) 执行后 Cat 对象中的 this 就指向了 obj 对象，这样 obj 对象就具有了 name 和 age 属性。</p>
<p>因此， 不仅要关注 new 操作符函数本身，也要关注他的原型属性。</p>
<p>我们对上面的代码进行改动，在 Cat 对象的原型链上增加一个 sayHi() 函数，然后通过 New() 函数返回对象，去调用 sayHi() 函数，看看执行情况如何。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> res = Cat.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(New(<span class="string">'miao'</span>, <span class="number">8</span>)) <span class="comment">// &#123;name: 'miao', age: 8&#125;</span></span><br><span class="line">New(<span class="string">'miao'</span>, <span class="number">8</span>).sayHi() <span class="comment">// TypeError: New(...).sayHi is not a function</span></span><br></pre></td></tr></table></figure>
<p>我们发现执行报错了，New() 函数返回的对象并没有调用 sayHi() 函数，这是因为 sayHi() 函数是属于 Cat 原型的函数，只有 Cat 原型链上的对象才能继承 sayHi() 函数，那么我们应该怎么做呢？</p>
<p>这里需要用到的就是<code>__pro__</code> 属性，实例的<code>__pro__</code> 属性指向的事创建实例对象时，对应的函数的原型。设置 obj 对象的<code>__pro__</code> 值为 Cat 对象的 prototype 属性，那么 obj 对象就继承了 Cat 原型上的 sayHi() 函数，这样就可以调用 sayHi() 函数了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Cat.prototype <span class="comment">// 核心代码，用于继承</span></span><br><span class="line">  <span class="keyword">const</span> res = Cat.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> res === <span class="string">'object'</span> ? res : obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(New(<span class="string">'miao'</span>, <span class="number">8</span>)) <span class="comment">// &#123;name: 'miao', age: 8&#125;</span></span><br><span class="line">New(<span class="string">'miao'</span>, <span class="number">8</span>).sayHi() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

    </div>

    
    
    
        <div class="reward-container">
  <div>赞赏是最好的支持</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    Donate
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Rui WeChat Pay">
        <p>WeChat Pay</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>Post author:  </strong>Rui
  </li>
  <li class="post-copyright-link">
    <strong>Post link: </strong>
    <a href="http://blog.lovek.vip/2021/05/21/web/JavaScript%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B03/" title="JavaScript进阶笔记3">http://blog.lovek.vip/2021/05/21/web/JavaScript进阶笔记3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/13/web/JavaScript%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B02/" rel="prev" title="JavaScript进阶笔记2">
      <i class="fa fa-chevron-left"></i> JavaScript进阶笔记2
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/06/10/web/JavaScript%E8%BF%9B%E9%98%B6%E7%AC%94%E8%AE%B04/" rel="next" title="JavaScript进阶笔记4">
      JavaScript进阶笔记4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-对象"><span class="nav-number">1.</span> <span class="nav-text">5. 对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-创建对象"><span class="nav-number">1.1.</span> <span class="nav-text">5.1 创建对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-1-基于-Object-构造函数"><span class="nav-number">1.1.1.</span> <span class="nav-text">5.1.1 基于 Object() 构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-2-基于对象字面量"><span class="nav-number">1.1.2.</span> <span class="nav-text">5.1.2 基于对象字面量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-3-基于工厂方法模式"><span class="nav-number">1.1.3.</span> <span class="nav-text">5.1.3 基于工厂方法模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-4-基于构造函数模式"><span class="nav-number">1.1.4.</span> <span class="nav-text">5.1.4 基于构造函数模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-5-基于原型对象的模式"><span class="nav-number">1.1.5.</span> <span class="nav-text">5.1.5 基于原型对象的模式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1-6-构造函数和原型混合的模式"><span class="nav-number">1.1.6.</span> <span class="nav-text">5.1.6 构造函数和原型混合的模式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-对象的属性-了解"><span class="nav-number">1.2.</span> <span class="nav-text">5.2 对象的属性(了解)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-1-理解对象"><span class="nav-number">1.2.1.</span> <span class="nav-text">5.2.1 理解对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-2-数据属性"><span class="nav-number">1.2.2.</span> <span class="nav-text">5.2.2 数据属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2-3-访问器属性"><span class="nav-number">1.2.3.</span> <span class="nav-text">5.2.3 访问器属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-对象克隆"><span class="nav-number">1.3.</span> <span class="nav-text">5.3 对象克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-1-对象浅克隆"><span class="nav-number">1.3.1.</span> <span class="nav-text">5.3.1 对象浅克隆</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-2-ES6-的-Object-assign-函数"><span class="nav-number">1.3.2.</span> <span class="nav-text">5.3.2 ES6 的 Object.assign() 函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-3-对象深克隆"><span class="nav-number">1.3.3.</span> <span class="nav-text">5.3.3 对象深克隆</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#JSON序列号和反序列化"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">JSON序列号和反序列化</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#深克隆的第三方库"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">$.深克隆的第三方库</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-原型对象"><span class="nav-number">1.4.</span> <span class="nav-text">5.4 原型对象</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-1-原型对象，构造函数和实例"><span class="nav-number">1.4.1.</span> <span class="nav-text">5.4.1 原型对象，构造函数和实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-2-原型对象、构造函数和实例之间的关系"><span class="nav-number">1.4.2.</span> <span class="nav-text">5.4.2 原型对象、构造函数和实例之间的关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-3-实例的属性读取顺序"><span class="nav-number">1.4.3.</span> <span class="nav-text">5.4.3 实例的属性读取顺序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4-4-重写原型对象"><span class="nav-number">1.4.4.</span> <span class="nav-text">5.4.4 重写原型对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-原型链"><span class="nav-number">1.5.</span> <span class="nav-text">5.5 原型链</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-原型链的特点"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.5.1 原型链的特点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-属性的区分"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.5.2 属性的区分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-3-内置构造函数"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.5.3 内置构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-4-prooto-属性"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.5.4 __prooto__属性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-继承"><span class="nav-number">1.6.</span> <span class="nav-text">5.6 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-1-原型链继承"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.6.1 原型链继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-2-构造继承"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.6.2 构造继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-3-复制继承"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.6.3 复制继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-4-组合继承"><span class="nav-number">1.6.4.</span> <span class="nav-text">5.6.4 组合继承</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-6-5-寄生组合继承"><span class="nav-number">1.6.5.</span> <span class="nav-text">5.6.5 寄生组合继承</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-7-Object-类型和实例"><span class="nav-number">1.7.</span> <span class="nav-text">5.7 Object 类型和实例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-7-1-new-运算符"><span class="nav-number">1.7.1.</span> <span class="nav-text">5.7.1 new 运算符</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rui"
      src="/images/author.jpg">
  <p class="site-author-name" itemprop="name">Rui</p>
  <div class="site-description" itemprop="description">简单即是美</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">41</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/dongyeforever" title="GitHub → https://github.com/dongyeforever" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:rui@lovek.vip" title="E-Mail → mailto:rui@lovek.vip" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  <span class="author">Copyright </span>
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui</span>
  <span class="author"> Powered by Hexo</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '075768b5cc6d617a818d',
      clientSecret: '12a4af5fd77c65a4ab68791bce732d6c9e3b7364',
      repo        : 'dongyeforever.github.io',
      owner       : 'dongyeforever',
      admin       : ['dongyeforever'],
      id          : 'f3907043b06336ba81a7c0f8a6ce2bcb',
      proxy       : 'https://shielded-brushlands-08810.herokuapp.com/https://github.com/login/oauth/access_token',
        language: 'zh-CN',
      distractionFreeMode: false
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
